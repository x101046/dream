{
  "version": 3,
  "sources": ["../../../../dev/core/src/Meshes/abstractMesh.decalMap.ts", "../../../../dev/core/src/Misc/workerPool.ts", "../../../../dev/core/src/Meshes/Compression/dracoCompression.ts", "../../../../dev/core/src/Meshes/Compression/meshoptCompression.ts", "../../../../dev/core/src/Meshes/csg.ts", "../../../../dev/core/src/Materials/shaderMaterial.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRenderer.vertex.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRenderer.fragment.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRendererMasker.vertex.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRendererMasker.fragment.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRendererFinaliser.fragment.ts", "../../../../dev/core/src/Shaders/meshUVSpaceRendererFinaliser.vertex.ts", "../../../../dev/core/src/Meshes/meshUVSpaceRenderer.ts", "../../../../dev/core/src/Meshes/goldbergMesh.ts", "../../../../dev/core/src/Meshes/trailMesh.ts", "../../../../dev/core/src/Meshes/instancedMesh.ts", "../../../../dev/core/src/Shaders/color.fragment.ts", "../../../../dev/core/src/Shaders/color.vertex.ts", "../../../../dev/core/src/Meshes/linesMesh.ts", "../../../../dev/core/src/Meshes/Builders/ribbonBuilder.ts", "../../../../dev/core/src/Meshes/Builders/discBuilder.ts", "../../../../dev/core/src/Meshes/Builders/boxBuilder.ts", "../../../../dev/core/src/Meshes/Builders/tiledPlaneBuilder.ts", "../../../../dev/core/src/Meshes/Builders/tiledBoxBuilder.ts", "../../../../dev/core/src/Meshes/Builders/sphereBuilder.ts", "../../../../dev/core/src/Meshes/Builders/cylinderBuilder.ts", "../../../../dev/core/src/Meshes/Builders/torusKnotBuilder.ts", "../../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../../dev/core/src/Meshes/polygonMesh.ts", "../../../../dev/core/src/Meshes/Builders/polygonBuilder.ts", "../../../../dev/core/src/Meshes/Builders/shapeBuilder.ts", "../../../../dev/core/src/Meshes/Builders/latheBuilder.ts", "../../../../dev/core/src/Meshes/Builders/planeBuilder.ts", "../../../../dev/core/src/Meshes/Builders/tubeBuilder.ts", "../../../../dev/core/src/Meshes/Builders/polyhedronBuilder.ts", "../../../../dev/core/src/Meshes/Builders/icoSphereBuilder.ts", "../../../../dev/core/src/Meshes/Builders/decalBuilder.ts", "../../../../dev/core/src/Meshes/Builders/capsuleBuilder.ts", "../../../../dev/core/src/Maths/math.isovector.ts", "../../../../dev/core/src/Meshes/geodesicMesh.ts", "../../../../dev/core/src/Meshes/Builders/geodesicBuilder.ts", "../../../../dev/core/src/Meshes/Builders/goldbergBuilder.ts", "../../../../dev/core/src/Meshes/Builders/textBuilder.ts", "../../../../dev/core/src/Meshes/meshBuilder.ts", "../../../../dev/core/src/Meshes/meshSimplification.ts", "../../../../dev/core/src/Meshes/meshSimplificationSceneComponent.ts", "../../../../dev/core/src/Meshes/subMesh.project.ts", "../../../../dev/core/src/Meshes/Builders/hemisphereBuilder.ts", "../../../../dev/core/src/Shaders/rgbdDecode.fragment.ts", "../../../../dev/core/src/Misc/textureTools.ts", "../../../../dev/core/src/Misc/rgbdTextureTools.ts", "../../../../dev/core/src/Misc/brdfTextureTools.ts", "../../../../dev/core/src/Materials/PBR/pbrBRDFConfiguration.ts", "../../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts", "../../../../dev/core/src/Materials/Textures/baseTexture.polynomial.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrFragmentDeclaration.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrUboDeclaration.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.ts", "../../../../dev/core/src/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.ts", "../../../../dev/core/src/Shaders/ShadersInclude/subSurfaceScatteringFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/importanceSampling.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrHelperFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/harmonicsFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBRDFFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/hdrFilteringFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrDirectLightingFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrIBLFunctions.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockReflectivity.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockAlphaFresnel.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockAnisotropic.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockReflection.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockSheen.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockClearcoat.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockIridescence.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockSubSurface.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockNormalGeometric.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockNormalFinal.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockLightmapInit.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockGeometryInfo.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockReflectance0.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockReflectance.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockDirectLighting.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockFinalLitComponents.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockFinalColorComposition.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrBlockImageProcessing.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrDebug.ts", "../../../../dev/core/src/Shaders/pbr.fragment.ts", "../../../../dev/core/src/Shaders/ShadersInclude/pbrVertexDeclaration.ts", "../../../../dev/core/src/Shaders/pbr.vertex.ts", "../../../../dev/core/src/Materials/PBR/pbrClearCoatConfiguration.ts", "../../../../dev/core/src/Materials/PBR/pbrIridescenceConfiguration.ts", "../../../../dev/core/src/Materials/PBR/pbrAnisotropicConfiguration.ts", "../../../../dev/core/src/Materials/PBR/pbrSheenConfiguration.ts", "../../../../dev/core/src/Materials/PBR/pbrSubSurfaceConfiguration.ts", "../../../../dev/core/src/Materials/PBR/pbrBaseMaterial.ts", "../../../../dev/core/src/Materials/PBR/pbrMaterial.ts", "../../../../dev/core/src/Engines/Extensions/engine.rawTexture.ts", "../../../../dev/core/src/Materials/Textures/rawTexture.ts", "../../../../dev/core/src/Materials/GreasedLine/greasedLineMaterialDefaults.ts", "../../../../dev/core/src/Misc/greasedLineTools.ts", "../../../../dev/core/src/Materials/GreasedLine/greasedLineMaterialInterfaces.ts", "../../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterial.ts", "../../../../dev/core/src/Shaders/greasedLine.fragment.ts", "../../../../dev/core/src/Shaders/greasedLine.vertex.ts", "../../../../dev/core/src/Materials/GreasedLine/greasedLineSimpleMaterial.ts", "../../../../dev/core/src/Meshes/GreasedLine/greasedLineBaseMesh.ts", "../../../../dev/core/src/Meshes/GreasedLine/greasedLineMesh.ts", "../../../../dev/core/src/Meshes/GreasedLine/greasedLineRibbonMesh.ts", "../../../../dev/core/src/Meshes/Builders/greasedLineBuilder.ts", "../../../../dev/core/src/Meshes/WebGPU/webgpuDataBuffer.ts", "../../../../dev/core/src/Meshes/thinInstanceMesh.ts", "../../../../dev/core/src/Meshes/Node/Enums/nodeGeometryConnectionPointTypes.ts", "../../../../dev/core/src/Meshes/Node/nodeGeometryBlockConnectionPoint.ts", "../../../../dev/core/src/Meshes/Node/nodeGeometryBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryOutputBlock.ts", "../../../../dev/core/src/Meshes/Node/Enums/nodeGeometryContextualSources.ts", "../../../../dev/core/src/Meshes/Node/nodeGeometryBuildState.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryInputBlock.ts", "../../../../dev/core/src/Decorators/nodeDecorator.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/boxBlock.ts", "../../../../dev/core/src/Meshes/Node/nodeGeometry.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryOptimizeBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/planeBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/meshBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/icoSphereBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/sphereBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/gridBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/torusBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/cylinderBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/capsuleBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/discBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Sources/nullBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setPositionsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setNormalsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setUVsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setColorsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setTangentsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/mathBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/mapRangeBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/conditionBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/randomBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/noiseBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/mergeGeometryBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryCollectionBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryElbowBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/computeNormalsBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/vectorConverterBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/normalizeVectorBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Set/setMaterialIDBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryTrigonometryBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryTransformBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/rotationXBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/rotationYBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/rotationZBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/scalingBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/alignBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Matrices/translationBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnVerticesBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnFacesBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateOnVolumeBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateBaseBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateLinearBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Instances/instantiateRadialBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/intFloatConverterBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/debugBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/geometryInfoBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/mappingBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/matrixComposeBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Teleport/teleportInBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Teleport/teleportOutBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Textures/geometryTextureBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/Textures/geometryTextureFetchBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/boundingBlock.ts", "../../../../dev/core/src/Meshes/Node/Blocks/booleanGeometryBlock.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { MeshUVSpaceRenderer } from \"./meshUVSpaceRenderer\";\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _decalMap: Nullable<MeshUVSpaceRenderer>;\r\n\r\n        /**\r\n         * Gets or sets the decal map for this mesh\r\n         */\r\n        decalMap: Nullable<MeshUVSpaceRenderer>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"decalMap\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._decalMap;\r\n    },\r\n    set: function (this: AbstractMesh, decalMap: Nullable<MeshUVSpaceRenderer>) {\r\n        this._decalMap = decalMap;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n", "import type { IDisposable } from \"../scene\";\r\n\r\n/** @ignore */\r\ninterface WorkerInfo {\r\n    workerPromise: Promise<Worker>;\r\n    idle: boolean;\r\n    timeoutId?: ReturnType<typeof setTimeout>;\r\n}\r\n\r\n/**\r\n * Helper class to push actions to a pool of workers.\r\n */\r\nexport class WorkerPool implements IDisposable {\r\n    protected _workerInfos: Array<WorkerInfo>;\r\n    protected _pendingActions = new Array<(worker: Worker, onComplete: () => void) => void>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param workers Array of workers to use for actions\r\n     */\r\n    constructor(workers: Array<Worker>) {\r\n        this._workerInfos = workers.map((worker) => ({\r\n            workerPromise: Promise.resolve(worker),\r\n            idle: true,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Terminates all workers and clears any pending actions.\r\n     */\r\n    public dispose(): void {\r\n        for (const workerInfo of this._workerInfos) {\r\n            workerInfo.workerPromise.then((worker) => {\r\n                worker.terminate();\r\n            });\r\n        }\r\n\r\n        this._workerInfos.length = 0;\r\n        this._pendingActions.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\r\n     * pended until a worker has completed its action.\r\n     * @param action The action to perform. Call onComplete when the action is complete.\r\n     */\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            this._pendingActions.push(action);\r\n        }\r\n    }\r\n\r\n    protected _executeOnIdleWorker(action: (worker: Worker, onComplete: () => void) => void): boolean {\r\n        for (const workerInfo of this._workerInfos) {\r\n            if (workerInfo.idle) {\r\n                this._execute(workerInfo, action);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        workerInfo.idle = false;\r\n        workerInfo.workerPromise.then((worker) => {\r\n            action(worker, () => {\r\n                const nextAction = this._pendingActions.shift();\r\n                if (nextAction) {\r\n                    this._execute(workerInfo, nextAction);\r\n                } else {\r\n                    workerInfo.idle = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Options for AutoReleaseWorkerPool\r\n */\r\nexport interface AutoReleaseWorkerPoolOptions {\r\n    /**\r\n     * Idle time elapsed before workers are terminated.\r\n     */\r\n    idleTimeElapsedBeforeRelease: number;\r\n}\r\n\r\n/**\r\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\r\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\r\n */\r\nexport class AutoReleaseWorkerPool extends WorkerPool {\r\n    /**\r\n     * Default options for the constructor.\r\n     * Override to change the defaults.\r\n     */\r\n    public static DefaultOptions: AutoReleaseWorkerPoolOptions = {\r\n        idleTimeElapsedBeforeRelease: 1000,\r\n    };\r\n\r\n    private readonly _maxWorkers: number;\r\n    private readonly _createWorkerAsync: () => Promise<Worker>;\r\n    private readonly _options: AutoReleaseWorkerPoolOptions;\r\n\r\n    constructor(maxWorkers: number, createWorkerAsync: () => Promise<Worker>, options = AutoReleaseWorkerPool.DefaultOptions) {\r\n        super([]);\r\n\r\n        this._maxWorkers = maxWorkers;\r\n        this._createWorkerAsync = createWorkerAsync;\r\n        this._options = options;\r\n    }\r\n\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            if (this._workerInfos.length < this._maxWorkers) {\r\n                const workerInfo: WorkerInfo = {\r\n                    workerPromise: this._createWorkerAsync(),\r\n                    idle: false,\r\n                };\r\n                this._workerInfos.push(workerInfo);\r\n                this._execute(workerInfo, action);\r\n            } else {\r\n                this._pendingActions.push(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        // Reset the idle timeout.\r\n        if (workerInfo.timeoutId) {\r\n            clearTimeout(workerInfo.timeoutId);\r\n            delete workerInfo.timeoutId;\r\n        }\r\n\r\n        super._execute(workerInfo, (worker, onComplete) => {\r\n            action(worker, () => {\r\n                onComplete();\r\n\r\n                if (workerInfo.idle) {\r\n                    // Schedule the worker to be terminated after the elapsed time.\r\n                    workerInfo.timeoutId = setTimeout(() => {\r\n                        workerInfo.workerPromise.then((worker) => {\r\n                            worker.terminate();\r\n                        });\r\n\r\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\r\n                        if (indexOf !== -1) {\r\n                            this._workerInfos.splice(indexOf, 1);\r\n                        }\r\n                    }, this._options.idleTimeElapsedBeforeRelease);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { DecoderModule, DecoderBuffer, Decoder, Mesh, PointCloud, Status } from \"draco3dgltf\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\ninterface AttributeData {\r\n    kind: string;\r\n    data: ArrayBufferView;\r\n    size: number;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    normalized: boolean;\r\n}\r\n\r\ninterface MeshData {\r\n    indices?: Uint16Array | Uint32Array;\r\n    attributes: Array<AttributeData>;\r\n    totalVertices: number;\r\n}\r\n\r\ninterface InitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\ninterface DecodeMeshDoneMessage {\r\n    id: \"decodeMeshDone\";\r\n    totalVertices: number;\r\n}\r\n\r\ninterface IndicesMessage {\r\n    id: \"indices\";\r\n    data: Uint16Array | Uint32Array;\r\n}\r\n\r\ninterface AttributeMessage extends AttributeData {\r\n    id: \"attribute\";\r\n}\r\n\r\ntype Message = InitDoneMessage | DecodeMeshDoneMessage | IndicesMessage | AttributeMessage;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: Message, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<{ module: DecoderModule }> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(\r\n    decoderModule: DecoderModule,\r\n    data: Int8Array,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: { [kind: string]: number } = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                const decoder = message.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = decodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<{ module: DecoderModule }>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n            wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n            fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: Tools.GetBabylonScriptURL(decoder.wasmUrl, true),\r\n                      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: Tools.GetBabylonScriptURL(decoder.fallbackUrl!),\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numWorkers, () => {\r\n                    return new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            if (event.data.id === \"initDone\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: decoderInfo.url,\r\n                                wasmBinary: decoderWasmBinary,\r\n                            },\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        } else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadBabylonScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => {});\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => {});\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _decodeMeshAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<AttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<AttributeData> = [];\r\n\r\n                const numPoints = decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean }\r\n    ): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes, gltfNormalizedOverride).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\r\n     */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const vertexData = new VertexData();\r\n\r\n            if (meshData.indices) {\r\n                vertexData.indices = meshData.indices;\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                const floatData = VertexBuffer.GetFloatData(\r\n                    attribute.data,\r\n                    attribute.size,\r\n                    VertexBuffer.GetDataType(attribute.data),\r\n                    attribute.byteOffset,\r\n                    attribute.byteStride,\r\n                    attribute.normalized,\r\n                    meshData.totalVertices\r\n                );\r\n\r\n                vertexData.set(floatData, attribute.kind);\r\n            }\r\n\r\n            return vertexData;\r\n        });\r\n    }\r\n}\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let MeshoptDecoder: any;\r\n\r\n/**\r\n * Configuration for meshoptimizer compression\r\n */\r\nexport interface IMeshoptCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the meshopt decoder library.\r\n         */\r\n        url: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Meshopt compression (https://github.com/zeux/meshoptimizer)\r\n *\r\n * This class wraps the meshopt library from https://github.com/zeux/meshoptimizer/tree/master/js.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the meshopt files on the Babylon.js preview CDN (e.g. https://preview.babylonjs.com/meshopt_decoder.js).\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     MeshoptCompression.Configuration = {\r\n *         decoder: {\r\n *             url: \"<url to the meshopt decoder library>\"\r\n *         }\r\n *     };\r\n * ```\r\n */\r\nexport class MeshoptCompression implements IDisposable {\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following:\r\n     * ```javascript\r\n     * decoder: {\r\n     *   url: \"https://cdn.babylonjs.com/meshopt_decoder.js\"\r\n     * }\r\n     * ```\r\n     */\r\n    public static Configuration: IMeshoptCompressionConfiguration = {\r\n        decoder: {\r\n            url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`,\r\n        },\r\n    };\r\n\r\n    private static _Default: Nullable<MeshoptCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the meshoptimizer object.\r\n     */\r\n    public static get Default(): MeshoptCompression {\r\n        if (!MeshoptCompression._Default) {\r\n            MeshoptCompression._Default = new MeshoptCompression();\r\n        }\r\n\r\n        return MeshoptCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() {\r\n        const decoder = MeshoptCompression.Configuration.decoder;\r\n\r\n        this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {\r\n            // Wait for WebAssembly compilation before resolving promise\r\n            return MeshoptDecoder.ready;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Decode meshopt data.\r\n     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder\r\n     * @param source The input data.\r\n     * @param count The number of elements.\r\n     * @param stride The stride in bytes.\r\n     * @param mode The compression mode.\r\n     * @param filter The compression filter.\r\n     * @returns a Promise<Uint8Array> that resolves to the decoded data\r\n     */\r\n    public decodeGltfBufferAsync(source: Uint8Array, count: number, stride: number, mode: \"ATTRIBUTES\" | \"TRIANGLES\" | \"INDICES\", filter?: string): Promise<Uint8Array> {\r\n        return this._decoderModulePromise!.then(() => {\r\n            const result = new Uint8Array(count * stride);\r\n            MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);\r\n            return result;\r\n        });\r\n    }\r\n}\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass CSGPlane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(\r\n        public normal: Vector3,\r\n        public w: number\r\n    ) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<CSGPlane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new CSGPlane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): CSGPlane {\r\n        return new CSGPlane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: CSGPolygon, coplanarFront: CSGPolygon[], coplanarBack: CSGPolygon[], front: CSGPolygon[], back: CSGPolygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -CSGPlane.EPSILON ? BACK : t > CSGPlane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: CSGPolygon;\r\n                if (f.length >= 3) {\r\n                    poly = new CSGPolygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new CSGPolygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass CSGPolygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: CSGPlane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <CSGPlane>CSGPlane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): CSGPolygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new CSGPolygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<CSGPlane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<CSGPolygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<CSGPolygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: CSGPolygon[]): CSGPolygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front: CSGPolygon[] = [],\r\n            back = [] as CSGPolygon[];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): CSGPolygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: CSGPolygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front: CSGPolygon[] = [],\r\n            back = [] as CSGPolygon[];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<CSGPolygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert a VertexData to CSG\r\n     * @param mesh defines the VertexData to convert to CSG\r\n     * @returns the new CSG\r\n     */\r\n    public static FromVertexData(data: VertexData): CSG {\r\n        let vertex: Vertex, polygon: CSGPolygon, vertices: Vertex[];\r\n        const polygons: CSGPolygon[] = [];\r\n\r\n        const indices = data.indices;\r\n        const positions = data.positions;\r\n        const normals = data.normals;\r\n        const uvs = data.uvs;\r\n        const vertColors = data.colors;\r\n\r\n        if (!indices || !positions) {\r\n            throw \"BABYLON.CSG: VertexData must at least contain positions and indices\";\r\n        }\r\n\r\n        for (let i = 0; i < indices.length; i += 3) {\r\n            vertices = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                const indexIndices = i + j;\r\n                const offset = indices[indexIndices];\r\n\r\n                const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();\r\n                const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : undefined;\r\n                const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : undefined;\r\n\r\n                const position = Vector3.FromArray(positions, offset * 3);\r\n\r\n                vertex = new Vertex(position, normal, uv, vertColor);\r\n                vertices.push(vertex);\r\n            }\r\n\r\n            polygon = new CSGPolygon(vertices, { subMeshId: 0, meshId: currentCSGMeshId, materialIndex: 0 });\r\n\r\n            // To handle the case of degenerated triangle\r\n            // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n            if (polygon.plane) {\r\n                polygons.push(polygon);\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = Matrix.Identity();\r\n        csg.position = Vector3.Zero();\r\n        csg.rotation = Vector3.Zero();\r\n        csg.scaling = Vector3.One();\r\n        csg.rotationQuaternion = Quaternion.Identity();\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: CSGPolygon,\r\n            vertices: Vertex[];\r\n        const polygons: CSGPolygon[] = [];\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new CSGPolygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: CSGPolygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build vertex data from CSG\r\n     * Coordinates here are in world space\r\n     * @returns the final vertex data\r\n     */\r\n    public toVertexData(onBeforePolygonProcessing: Nullable<(polygon: CSGPolygon) => void> = null, onAfterPolygonProcessing: Nullable<() => void> = null): VertexData {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const polygons = this._polygons;\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygonIndices = [0, 0, 0];\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            const polygon = polygons[i];\r\n\r\n            if (onBeforePolygonProcessing) {\r\n                onBeforePolygonProcessing(polygon);\r\n            }\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    if (onAfterPolygonProcessing) {\r\n                        onAfterPolygonProcessing();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const result = new VertexData();\r\n        result.positions = vertices;\r\n        result.normals = normals;\r\n        if (uvs) {\r\n            result.uvs = uvs;\r\n        }\r\n        if (vertColors) {\r\n            result.colors = vertColors;\r\n        }\r\n        result.indices = indices;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = new Mesh(name, scene);\r\n        const polygons = this._polygons;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj: {\r\n            materialIndex: number;\r\n            indexStart: number;\r\n            indexEnd: number;\r\n        };\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        const vertexData = this.toVertexData(\r\n            (polygon) => {\r\n                // Building SubMeshes\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n                }\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                        indexStart: +Infinity,\r\n                        indexEnd: -Infinity,\r\n                        materialIndex: polygon.shared.materialIndex,\r\n                    };\r\n                }\r\n                subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n            },\r\n            () => {\r\n                subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                currentIndex++;\r\n            }\r\n        );\r\n\r\n        vertexData.applyToMesh(mesh);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = [] as SubMesh[];\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n", "import { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            if (storeEffectOnSubMeshes) {\r\n                if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                const effect = this._drawWrapper.effect;\r\n                if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    this._options.uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        // Misc\r\n        if (this._useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n            if (this._options.uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\r\n                this._options.uniforms.push(\"logarithmicDepthConstant\");\r\n            }\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        effect!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        MaterialHelper.BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\r\n                        scene.finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, mesh.visibility) : scene.getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", scene.getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", scene.activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Misc\r\n            if (this._useLogarithmicDepth) {\r\n                MaterialHelper.BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\r\n            }\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                MaterialHelper.BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!effect._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray: Texture[] = [];\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"meshUVSpaceRendererVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 projMatrix;varying vec2 vDecalTC;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nvoid main(void) {vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);mat3 normWorldSM=mat3(finalWorld);vec3 vNormalW;\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvNormalW=normalize(normWorldSM*normalUpdated);\n#endif\nvec3 normalView=normalize((projMatrix*vec4(vNormalW,0.0)).xyz);vec3 decalTC=(projMatrix*worldPos).xyz;vDecalTC=decalTC.xy;gl_Position=vec4(uv*2.0-1.0,normalView.z>0.0 ? 2. : decalTC.z,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererPixelShader\";\nconst shader = `precision highp float;varying vec2 vDecalTC;uniform sampler2D textureSampler;void main(void) {if (vDecalTC.x<0. || vDecalTC.x>1. || vDecalTC.y<0. || vDecalTC.y>1.) {discard;}\ngl_FragColor=texture2D(textureSampler,vDecalTC);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererMaskerVertexShader\";\nconst shader = `attribute vec2 uv;varying vec2 vUV;void main(void) {gl_Position=vec4(vec2(uv.x,uv.y)*2.0-1.0,0.,1.0);vUV=uv;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererMaskerVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererMaskerPixelShader\";\nconst shader = `varying vec2 vUV;void main(void) {gl_FragColor=vec4(1.0,1.0,1.0,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererMaskerPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererFinaliserPixelShader\";\nconst shader = `precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D maskTextureSampler;uniform vec2 textureSize;void main() {vec4 mask=texture2D(maskTextureSampler,vUV).rgba;if (mask.r>0.5) {gl_FragColor=texture2D(textureSampler,vUV);} else {vec2 texelSize=4.0/textureSize;vec2 uv_p01=vUV+vec2(-1.0,0.0)*texelSize;vec2 uv_p21=vUV+vec2(1.0,0.0)*texelSize;vec2 uv_p10=vUV+vec2(0.0,-1.0)*texelSize;vec2 uv_p12=vUV+vec2(0.0,1.0)*texelSize;float mask_p01=texture2D(maskTextureSampler,uv_p01).r;float mask_p21=texture2D(maskTextureSampler,uv_p21).r;float mask_p10=texture2D(maskTextureSampler,uv_p10).r;float mask_p12=texture2D(maskTextureSampler,uv_p12).r;vec4 col=vec4(0.0,0.0,0.0,0.0);float total_weight=0.0;if (mask_p01>0.5) {col+=texture2D(textureSampler,uv_p01);total_weight+=1.0;}\nif (mask_p21>0.5) {col+=texture2D(textureSampler,uv_p21);total_weight+=1.0;}\nif (mask_p10>0.5) {col+=texture2D(textureSampler,uv_p10);total_weight+=1.0;}\nif (mask_p12>0.5) {col+=texture2D(textureSampler,uv_p12);total_weight+=1.0;}\nif (total_weight>0.0) {gl_FragColor=col/total_weight;} else {gl_FragColor=col;}}}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererFinaliserPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererFinaliserVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec2 uv;uniform mat4 worldViewProjection;varying vec2 vUV;void main() {gl_Position=worldViewProjection*vec4(position,1.0);vUV=uv;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererFinaliserVertexShader = { name, shader };\n", "import type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Matrix } from \"core/Maths/math.vector\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { PostProcess } from \"core/PostProcesses/postProcess\";\r\n\r\nimport \"../Shaders/meshUVSpaceRenderer.vertex\";\r\nimport \"../Shaders/meshUVSpaceRenderer.fragment\";\r\n\r\nimport \"../Shaders/meshUVSpaceRendererMasker.vertex\";\r\nimport \"../Shaders/meshUVSpaceRendererMasker.fragment\";\r\n\r\nimport \"../Shaders/meshUVSpaceRendererFinaliser.fragment\";\r\nimport \"../Shaders/meshUVSpaceRendererFinaliser.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _meshUVSpaceRendererShader: Nullable<ShaderMaterial>;\r\n        /** @internal */\r\n        _meshUVSpaceRendererMaskShader: Nullable<ShaderMaterial>;\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the MeshUVSpaceRenderer\r\n * @since 5.49.1\r\n */\r\nexport interface IMeshUVSpaceRendererOptions {\r\n    /**\r\n     * Width of the texture. Default: 1024\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Height of the texture. Default: 1024\r\n     */\r\n    height?: number;\r\n    /**\r\n     * Type of the texture. Default: Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n     */\r\n    textureType?: number;\r\n    /**\r\n     * Generate mip maps. Default: true\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Optimize UV allocation. Default: true\r\n     * If you plan to use the texture as a decal map and rotate / offset the texture, you should set this to false\r\n     */\r\n    optimizeUVAllocation?: boolean;\r\n    /**\r\n     * If true, a post processing effect will be applied to the texture to fix seams. Default: false\r\n     */\r\n    uvEdgeBlending?: boolean;\r\n}\r\n\r\n/**\r\n * Class used to render in the mesh UV space\r\n * @since 5.49.1\r\n */\r\nexport class MeshUVSpaceRenderer {\r\n    private _mesh: AbstractMesh;\r\n    private _scene: Scene;\r\n    private _options: Required<IMeshUVSpaceRendererOptions>;\r\n    private _textureCreatedInternally = false;\r\n    private _configureUserCreatedTexture = true;\r\n    private _maskTexture: Nullable<RenderTargetTexture> = null;\r\n    private _finalPostProcess: Nullable<PostProcess> = null;\r\n\r\n    private static _GetShader(scene: Scene): ShaderMaterial {\r\n        if (!scene._meshUVSpaceRendererShader) {\r\n            const shader = new ShaderMaterial(\r\n                \"meshUVSpaceRendererShader\",\r\n                scene,\r\n                {\r\n                    vertex: \"meshUVSpaceRenderer\",\r\n                    fragment: \"meshUVSpaceRenderer\",\r\n                },\r\n                {\r\n                    attributes: [\"position\", \"normal\", \"uv\"],\r\n                    uniforms: [\"world\", \"projMatrix\"],\r\n                    samplers: [\"textureSampler\"],\r\n                    needAlphaBlending: true,\r\n                }\r\n            );\r\n            shader.backFaceCulling = false;\r\n            shader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            scene.onDisposeObservable.add(() => {\r\n                scene._meshUVSpaceRendererShader?.dispose();\r\n                scene._meshUVSpaceRendererShader = null;\r\n            });\r\n\r\n            scene._meshUVSpaceRendererShader = shader;\r\n        }\r\n\r\n        return scene._meshUVSpaceRendererShader;\r\n    }\r\n\r\n    private static _GetMaskShader(scene: Scene): ShaderMaterial {\r\n        if (!scene._meshUVSpaceRendererMaskShader) {\r\n            const shader = new ShaderMaterial(\r\n                \"meshUVSpaceRendererMaskShader\",\r\n                scene,\r\n                {\r\n                    vertex: \"meshUVSpaceRendererMasker\",\r\n                    fragment: \"meshUVSpaceRendererMasker\",\r\n                },\r\n                {\r\n                    attributes: [\"position\", \"uv\"],\r\n                    uniforms: [\"worldViewProjection\"],\r\n                }\r\n            );\r\n            shader.backFaceCulling = false;\r\n            shader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            scene.onDisposeObservable.add(() => {\r\n                scene._meshUVSpaceRendererMaskShader?.dispose();\r\n                scene._meshUVSpaceRendererMaskShader = null;\r\n            });\r\n\r\n            scene._meshUVSpaceRendererMaskShader = shader;\r\n        }\r\n        return scene._meshUVSpaceRendererMaskShader;\r\n    }\r\n\r\n    private static _IsRenderTargetTexture(texture: ThinTexture | RenderTargetTexture): texture is RenderTargetTexture {\r\n        return (texture as RenderTargetTexture).renderList !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Clear color of the texture\r\n     */\r\n    public clearColor = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Target texture used for rendering\r\n     * If you don't set the property, a RenderTargetTexture will be created internally given the options provided to the constructor.\r\n     * If you provide a RenderTargetTexture, it will be used directly.\r\n     */\r\n    public texture: Texture;\r\n\r\n    /**\r\n     * Creates a new MeshUVSpaceRenderer\r\n     * @param mesh The mesh used for the source UV space\r\n     * @param scene The scene the mesh belongs to\r\n     * @param options The options to use when creating the texture\r\n     */\r\n    constructor(mesh: AbstractMesh, scene: Scene, options?: IMeshUVSpaceRendererOptions) {\r\n        this._mesh = mesh;\r\n        this._scene = scene;\r\n        this._options = {\r\n            width: 1024,\r\n            height: 1024,\r\n            textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            generateMipMaps: true,\r\n            optimizeUVAllocation: true,\r\n            uvEdgeBlending: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture is ready to be used\r\n     * @returns true if the texture is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.texture) {\r\n            this._createDiffuseRTT();\r\n        }\r\n\r\n        const textureIsReady = MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) ? this.texture.isReadyForRendering() : this.texture.isReady();\r\n        const maskIsReady = this._maskTexture?.isReadyForRendering() ?? true;\r\n        const postProcessIsReady = this._finalPostProcess?.isReady() ?? true;\r\n\r\n        return textureIsReady && maskIsReady && postProcessIsReady;\r\n    }\r\n\r\n    /**\r\n     * Projects and renders a texture in the mesh UV space\r\n     * @param texture The texture\r\n     * @param position The position of the center of projection (world space coordinates)\r\n     * @param normal The direction of the projection (world space coordinates)\r\n     * @param size The size of the projection\r\n     * @param angle The rotation angle around the direction of the projection\r\n     */\r\n    public renderTexture(texture: BaseTexture, position: Vector3, normal: Vector3, size: Vector3, angle = 0): void {\r\n        if (!this.texture) {\r\n            this._createDiffuseRTT();\r\n        } else if (this._configureUserCreatedTexture) {\r\n            this._configureUserCreatedRTT();\r\n        }\r\n\r\n        if (MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {\r\n            const matrix = this._createProjectionMatrix(position, normal, size, angle);\r\n            const shader = MeshUVSpaceRenderer._GetShader(this._scene);\r\n\r\n            shader.setTexture(\"textureSampler\", texture);\r\n            shader.setMatrix(\"projMatrix\", matrix);\r\n\r\n            this.texture.render();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the texture map\r\n     */\r\n    public clear(): void {\r\n        if (MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) && this.texture.renderTarget) {\r\n            const engine = this._scene.getEngine();\r\n\r\n            engine.bindFramebuffer(this.texture.renderTarget);\r\n            engine.clear(this.clearColor, true, true, true);\r\n            engine.unBindFramebuffer(this.texture.renderTarget);\r\n        }\r\n        if (this._finalPostProcess?.inputTexture) {\r\n            const engine = this._scene.getEngine();\r\n\r\n            engine.bindFramebuffer(this._finalPostProcess?.inputTexture);\r\n            engine.clear(this.clearColor, true, true, true);\r\n            engine.unBindFramebuffer(this._finalPostProcess?.inputTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the resources\r\n     */\r\n    public dispose() {\r\n        if (this._textureCreatedInternally) {\r\n            this.texture.dispose();\r\n            this._textureCreatedInternally = false;\r\n        }\r\n        this._configureUserCreatedTexture = true;\r\n        this._maskTexture?.dispose();\r\n        this._maskTexture = null;\r\n        this._finalPostProcess?.dispose();\r\n        this._finalPostProcess = null;\r\n    }\r\n\r\n    private _configureUserCreatedRTT(): void {\r\n        this._configureUserCreatedTexture = false;\r\n        if (MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {\r\n            this.texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene));\r\n            this.texture.onClearObservable.add(() => {});\r\n            this.texture.renderList = [this._mesh];\r\n            if (this._options.uvEdgeBlending) {\r\n                this._createMaskTexture();\r\n                this._createPostProcess();\r\n                this.texture.addPostProcess(this._finalPostProcess!);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createDiffuseRTT(): void {\r\n        this._textureCreatedInternally = true;\r\n\r\n        const texture = this._createRenderTargetTexture(this._options.width, this._options.height);\r\n\r\n        texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene));\r\n\r\n        this.texture = texture;\r\n        this._configureUserCreatedTexture = false;\r\n        if (this._options.uvEdgeBlending) {\r\n            this._createMaskTexture();\r\n            this._createPostProcess();\r\n            texture.addPostProcess(this._finalPostProcess!);\r\n        }\r\n    }\r\n\r\n    private _createMaskTexture(): void {\r\n        if (this._maskTexture) {\r\n            return;\r\n        }\r\n\r\n        this._maskTexture = new RenderTargetTexture(\r\n            this._mesh.name + \"_maskTexture\",\r\n            { width: this._options.width, height: this._options.height },\r\n            this._scene,\r\n            false, // No mipmaps for the mask texture\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            false,\r\n            Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            Constants.TEXTUREFORMAT_R\r\n        );\r\n\r\n        this._maskTexture.clearColor = new Color4(0, 0, 0, 0);\r\n\r\n        // Render the mesh with the mask material to the mask texture\r\n        this._maskTexture.renderList!.push(this._mesh);\r\n        this._maskTexture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetMaskShader(this._scene));\r\n\r\n        // Ensure the mask texture is updated\r\n        this._maskTexture.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        this._scene.customRenderTargets.push(this._maskTexture);\r\n    }\r\n\r\n    private _createPostProcess(): void {\r\n        if (this._finalPostProcess) {\r\n            return;\r\n        }\r\n\r\n        this._finalPostProcess = new PostProcess(\r\n            this._mesh.name + \"_fixSeamsPostProcess\",\r\n            \"meshUVSpaceRendererFinaliser\",\r\n            [\"textureSize\"],\r\n            [\"textureSampler\", \"maskTextureSampler\"],\r\n            1.0,\r\n            null,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            null,\r\n            this._options.textureType\r\n        );\r\n\r\n        this._finalPostProcess.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"maskTextureSampler\", this._maskTexture);\r\n            effect.setFloat2(\"textureSize\", this._options.width, this._options.height);\r\n        });\r\n    }\r\n\r\n    private _createRenderTargetTexture(width: number, height: number): RenderTargetTexture {\r\n        const rtt = new RenderTargetTexture(\r\n            this._mesh.name + \"_uvspaceTexture\",\r\n            { width, height },\r\n            this._scene,\r\n            this._options.generateMipMaps,\r\n            true,\r\n            this._options.textureType,\r\n            false,\r\n            this._options.generateMipMaps ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            false,\r\n            false,\r\n            false,\r\n            Constants.TEXTUREFORMAT_RGBA\r\n        );\r\n\r\n        rtt.renderParticles = false;\r\n        rtt.optimizeUVAllocation = !!this._options.optimizeUVAllocation;\r\n\r\n        rtt.onClearObservable.addOnce(() => {\r\n            this._scene.getEngine().clear(this.clearColor, true, true, true);\r\n            rtt.onClearObservable.add(() => {}); // this disables clearing the texture for the next frames\r\n        });\r\n\r\n        rtt.renderList = [this._mesh];\r\n\r\n        return rtt;\r\n    }\r\n\r\n    private _createProjectionMatrix(position: Vector3, normal: Vector3, size: Vector3, angle = 0): Matrix {\r\n        const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n        const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n        const pitch = Math.atan2(normal.y, len);\r\n\r\n        const p = position.add(normal.scale(size.z * 0.5));\r\n\r\n        const projWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(p.x, p.y, p.z));\r\n        const inverseProjWorldMatrix = Matrix.Invert(projWorldMatrix);\r\n\r\n        const projMatrix = Matrix.FromArray([2 / size.x, 0, 0, 0, 0, 2 / size.y, 0, 0, 0, 0, 1 / size.z, 0, 0, 0, 0, 1]);\r\n\r\n        const screenMatrix = Matrix.FromArray([0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 1, 0, 0.5, 0.5, 0.0, 1]);\r\n\r\n        return inverseProjWorldMatrix.multiply(projMatrix).multiply(screenMatrix);\r\n    }\r\n}\r\n", "import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n", "import { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\n\r\nMesh._TrailMeshParser = (parsedMesh: any, scene: Scene) => {\r\n    return TrailMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Class used to create a trail following a mesh\r\n */\r\nexport class TrailMesh extends Mesh {\r\n    /**\r\n     * The diameter of the trail, i.e. the width of the ribbon.\r\n     */\r\n    public diameter: number;\r\n\r\n    private _generator: TransformNode;\r\n    private _autoStart: boolean;\r\n    private _running: boolean;\r\n    private _length: number;\r\n    private _sectionPolygonPointsCount: number = 4;\r\n    private _sectionVectors: Array<Vector3>;\r\n    private _sectionNormalVectors: Array<Vector3>;\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n\r\n    /**\r\n     * Creates a new TrailMesh.\r\n     * @param name The value used by scene.getMeshByName() to do a lookup.\r\n     * @param generator The mesh or transform node to generate a trail.\r\n     * @param scene The scene to add this mesh to.\r\n     * @param diameter Diameter of trailing mesh. Default is 1.\r\n     * @param length Length of trailing mesh. Default is 60.\r\n     * @param autoStart Automatically start trailing mesh. Default true.\r\n     */\r\n    constructor(name: string, generator: TransformNode, scene?: Scene, diameter: number = 1, length: number = 60, autoStart: boolean = true) {\r\n        super(name, scene);\r\n\r\n        this._running = false;\r\n        this._autoStart = autoStart;\r\n        this._generator = generator;\r\n        this.diameter = diameter;\r\n        this._length = length;\r\n        this._sectionVectors = [];\r\n        this._sectionNormalVectors = [];\r\n        for (let i: number = 0; i < this._sectionPolygonPointsCount; i++) {\r\n            this._sectionVectors[i] = Vector3.Zero();\r\n            this._sectionNormalVectors[i] = Vector3.Zero();\r\n        }\r\n        this._createMesh();\r\n    }\r\n\r\n    /**\r\n     * \"TrailMesh\"\r\n     * @returns \"TrailMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TrailMesh\";\r\n    }\r\n\r\n    private _createMesh(): void {\r\n        const data: VertexData = new VertexData();\r\n        const positions: Array<number> = [];\r\n        const normals: Array<number> = [];\r\n        const indices: Array<number> = [];\r\n        let meshCenter = Vector3.Zero();\r\n        if (this._generator instanceof AbstractMesh && this._generator.hasBoundingInfo) {\r\n            meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;\r\n        } else {\r\n            meshCenter = this._generator.position;\r\n        }\r\n        const alpha: number = (2 * Math.PI) / this._sectionPolygonPointsCount;\r\n        for (let i: number = 0; i < this._sectionPolygonPointsCount; i++) {\r\n            positions.push(meshCenter.x + Math.cos(i * alpha) * this.diameter, meshCenter.y + Math.sin(i * alpha) * this.diameter, meshCenter.z);\r\n        }\r\n        for (let i: number = 1; i <= this._length; i++) {\r\n            for (let j: number = 0; j < this._sectionPolygonPointsCount; j++) {\r\n                positions.push(meshCenter.x + Math.cos(j * alpha) * this.diameter, meshCenter.y + Math.sin(j * alpha) * this.diameter, meshCenter.z);\r\n            }\r\n            const l: number = positions.length / 3 - 2 * this._sectionPolygonPointsCount;\r\n            for (let j: number = 0; j < this._sectionPolygonPointsCount - 1; j++) {\r\n                indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);\r\n                indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);\r\n            }\r\n            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);\r\n            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);\r\n        }\r\n        VertexData.ComputeNormals(positions, indices, normals);\r\n        data.positions = positions;\r\n        data.normals = normals;\r\n        data.indices = indices;\r\n        data.applyToMesh(this, true);\r\n        if (this._autoStart) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start trailing mesh.\r\n     */\r\n    public start(): void {\r\n        if (!this._running) {\r\n            this._running = true;\r\n            this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(() => {\r\n                this.update();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop trailing mesh.\r\n     */\r\n    public stop(): void {\r\n        if (this._beforeRenderObserver && this._running) {\r\n            this._running = false;\r\n            this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update trailing mesh geometry.\r\n     */\r\n    public update(): void {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        const wm = this._generator.getWorldMatrix();\r\n        if (positions && normals) {\r\n            for (let i: number = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {\r\n                positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - (normals[i] / this._length) * this.diameter;\r\n            }\r\n            for (let i: number = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {\r\n                normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];\r\n            }\r\n            const l: number = positions.length - 3 * this._sectionPolygonPointsCount;\r\n            const alpha: number = (2 * Math.PI) / this._sectionPolygonPointsCount;\r\n            for (let i: number = 0; i < this._sectionPolygonPointsCount; i++) {\r\n                this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this.diameter, Math.sin(i * alpha) * this.diameter, 0);\r\n                this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);\r\n                Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);\r\n                Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);\r\n            }\r\n            for (let i: number = 0; i < this._sectionPolygonPointsCount; i++) {\r\n                positions[l + 3 * i] = this._sectionVectors[i].x;\r\n                positions[l + 3 * i + 1] = this._sectionVectors[i].y;\r\n                positions[l + 3 * i + 2] = this._sectionVectors[i].z;\r\n                normals[l + 3 * i] = this._sectionNormalVectors[i].x;\r\n                normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;\r\n                normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;\r\n            }\r\n            this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new TrailMesh object.\r\n     * @param name is a string, the name given to the new mesh\r\n     * @param newGenerator use new generator object for cloned trail mesh\r\n     * @returns a new mesh\r\n     */\r\n    public clone(name: string = \"\", newGenerator: TransformNode): TrailMesh {\r\n        return new TrailMesh(name, newGenerator === undefined ? this._generator : newGenerator, this.getScene(), this.diameter, this._length, this._autoStart);\r\n    }\r\n\r\n    /**\r\n     * Serializes this trail mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n\r\n        serializationObject.generatorId = this._generator.id;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized trail mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the trail mesh in\r\n     * @returns the created trail mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): TrailMesh {\r\n        const generator = scene.getLastMeshById(parsedMesh.generatorId) ?? scene.getLastTransformNodeById(parsedMesh.generatorId);\r\n\r\n        if (!generator) {\r\n            throw new Error(\"TrailMesh: generator not found with ID \" + parsedMesh.generatorId);\r\n        }\r\n\r\n        return new TrailMesh(parsedMesh.name, generator, scene, parsedMesh.diameter ?? parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);\r\n    }\r\n}\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {\r\n                // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            } else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\nMesh.CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the Disc or regular Polygon\r\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n * * radius the radius of the disc, optional default 0.5\r\n * * tessellation the number of polygon sides, optional, default 64\r\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.arc\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateDiscVertexData(options: {\r\n    radius?: number;\r\n    tessellation?: number;\r\n    arc?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const radius = options.radius || 0.5;\r\n    const tessellation = options.tessellation || 64;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0); // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    const theta = Math.PI * 2 * arc;\r\n    const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    let a = 0;\r\n    for (let t = 0; t < tessellation; t++) {\r\n        const x = Math.cos(a);\r\n        const y = Math.sin(a);\r\n        const u = (x + 1) / 2;\r\n        const v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    const vertexNb = positions.length / 3;\r\n    for (let i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane polygonal mesh.  By default, this is a disc\r\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the plane polygonal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#disc-or-regular-polygon\r\n */\r\nexport function CreateDisc(\r\n    name: string,\r\n    options: { radius?: number; tessellation?: number; arc?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const disc = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateDiscVertexData(options);\r\n\r\n    vertexData.applyToMesh(disc, options.updatable);\r\n\r\n    return disc;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateDisc directly\r\n */\r\nexport const DiscBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDisc,\r\n};\r\n\r\nVertexData.CreateDisc = CreateDiscVertexData;\r\n\r\nMesh.CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateDisc(name, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\nimport { CreateGroundVertexData } from \"./groundBuilder\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a segmented box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * segments sets the number of segments on the all axis (1 by default)\r\n * * widthSegments sets the number of segments on the x axis (1 by default)\r\n * * heightSegments sets the number of segments on the y axis (1 by default)\r\n * * depthSegments sets the number of segments on the z axis (1 by default)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.segments\r\n * @param options.widthSegments\r\n * @param options.heightSegments\r\n * @param options.depthSegments\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateSegmentedBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    segments?: number;\r\n    widthSegments?: number;\r\n    heightSegments?: number;\r\n    depthSegments?: number;\r\n}): VertexData {\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const widthSegments = (options.widthSegments || options.segments || 1) | 0;\r\n    const heightSegments = (options.heightSegments || options.segments || 1) | 0;\r\n    const depthSegments = (options.depthSegments || options.segments || 1) | 0;\r\n    const rotationMatrix = new Matrix();\r\n    const translationMatrix = new Matrix();\r\n    const transformMatrix = new Matrix();\r\n\r\n    const bottomPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    bottomPlane.transform(transformMatrix);\r\n\r\n    const topPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);\r\n    topPlane.transform(transformMatrix);\r\n\r\n    const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negXPlane.transform(transformMatrix);\r\n\r\n    const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posXPlane.transform(transformMatrix);\r\n\r\n    const negZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negZPlane.transform(transformMatrix);\r\n\r\n    const posZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posZPlane.transform(transformMatrix);\r\n\r\n    // Result\r\n    bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);\r\n\r\n    return bottomPlane;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\nMesh.CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled plane\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the tiled plane\r\n */\r\nexport function CreateTiledPlaneVertexData(options: {\r\n    pattern?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const tilesX = Math.floor(width / tileWidth);\r\n    let offsetX = width - tilesX * tileWidth;\r\n\r\n    const height = options.height || options.size || 1;\r\n    const tilesY = Math.floor(height / tileHeight);\r\n    let offsetY = height - tilesY * tileHeight;\r\n\r\n    const halfWidth = (tileWidth * tilesX) / 2;\r\n    const halfHeight = (tileHeight * tilesY) / 2;\r\n\r\n    let adjustX = 0;\r\n    let adjustY = 0;\r\n    let startX = 0;\r\n    let startY = 0;\r\n    let endX = 0;\r\n    let endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        endX = halfWidth;\r\n        endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    let uvs: Array<number> = [];\r\n    const colors = [];\r\n    const indices = [];\r\n    let index = 0;\r\n    for (let y = 0; y < tilesY; y++) {\r\n        for (let x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\r\n            } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            } else {\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        const partialBottomRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\r\n        const partialTopRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\r\n        const partialLeftCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\r\n        const partialRightCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\r\n        let uvPart: Array<number> = [];\r\n        let a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) {\r\n            //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) {\r\n            //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {\r\n            //top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) {\r\n            //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            const uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            const uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            const uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            const uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledPlane(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledPlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledPlane instead\r\n */\r\nexport const TiledPlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledPlane,\r\n};\r\n\r\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled box\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * @param options.pattern\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @returns the VertexData of the TiledBox\r\n */\r\nexport function CreateTiledBoxVertexData(options: {\r\n    pattern?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n    const halfDepth = depth / 2;\r\n\r\n    const faceVertexData: Array<VertexData> = [];\r\n\r\n    for (let f = 0; f < 2; f++) {\r\n        //front and back\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    for (let f = 2; f < 4; f++) {\r\n        //sides\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    } else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (let f = 4; f < 6; f++) {\r\n        //top and bottom\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let positions: Array<number> = [];\r\n    let normals: Array<number> = [];\r\n    let uvs: Array<number> = [];\r\n    let indices: Array<number> = [];\r\n    const colors: Array<number> = [];\r\n    const facePositions: Array<Array<Vector3>> = [];\r\n    const faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    const newFaceUV: Array<Array<number>> = [];\r\n    let lu: number = 0;\r\n\r\n    let li: number = 0;\r\n\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        const len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (let p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (let i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\r\n            }\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    const vec0 = new Vector3(0, 0, halfDepth);\r\n    const mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    normals = faceNormals[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    positions = positions.concat(\r\n        facePositions[1]\r\n            .map((entry) => entry.subtract(vec0))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []));\r\n\r\n    const vec2 = new Vector3(halfWidth, 0, 0);\r\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    const vec4 = new Vector3(0, halfHeight, 0);\r\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled box mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param options.pattern\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledBox(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledBox instead\r\n */\r\nexport const TiledBoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledBox,\r\n};\r\n\r\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n", "import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = (options.tessellation || 24) | 0;\r\n    const subdivisions: number = (options.subdivisions || 1) | 0;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.updatable\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\nMesh.CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n * * radius the radius of the torus knot, optional, default 2\r\n * * tube the thickness of the tube, optional, default 0.5\r\n * * radialSegments the number of sides on each tube segments, optional, default 32\r\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n * * p the number of windings around the z axis, optional,  default 2\r\n * * q the number of windings around the x axis, optional,  default 3\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: {\r\n    radius?: number;\r\n    tube?: number;\r\n    radialSegments?: number;\r\n    tubularSegments?: number;\r\n    p?: number;\r\n    q?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const radius = options.radius || 2;\r\n    const tube = options.tube || 0.5;\r\n    const radialSegments = options.radialSegments || 32;\r\n    const tubularSegments = options.tubularSegments || 32;\r\n    const p = options.p || 2;\r\n    const q = options.q || 3;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    const getPos = (angle: number) => {\r\n        const cu = Math.cos(angle);\r\n        const su = Math.sin(angle);\r\n        const quOverP = (q / p) * angle;\r\n        const cs = Math.cos(quOverP);\r\n\r\n        const tx = radius * (2 + cs) * 0.5 * cu;\r\n        const ty = radius * (2 + cs) * su * 0.5;\r\n        const tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    let i: number;\r\n    let j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        const modI = i % radialSegments;\r\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\r\n        const p1 = getPos(u);\r\n        const p2 = getPos(u + 0.01);\r\n        const tang = p2.subtract(p1);\r\n        let n = p2.add(p1);\r\n\r\n        const bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const modJ = j % tubularSegments;\r\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\r\n            const cx = -tube * Math.cos(v);\r\n            const cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const jNext = (j + 1) % tubularSegments;\r\n            const a = i * tubularSegments + j;\r\n            const b = (i + 1) * tubularSegments + j;\r\n            const c = (i + 1) * tubularSegments + jNext;\r\n            const d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\r\n */\r\nexport function CreateTorusKnot(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorusKnot,\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\nMesh.CreateTorusKnot = (\r\n    name: string,\r\n    radius: number,\r\n    tube: number,\r\n    radialSegments: number,\r\n    tubularSegments: number,\r\n    p: number,\r\n    q: number,\r\n    scene?: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = [] as IndexedVector2[];\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result: IndexedVector2[] = [];\r\n        originalPoints.forEach((point) => {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result: Vector2[] = [];\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals: number[] = [];\r\n        const positions: number[] = [];\r\n        const uvs: number[] = [];\r\n\r\n        const bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        const indices: number[] = [];\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vc_norm = vc.normalizeToNew();\r\n            let vp_norm = vp.normalizeToNew();\r\n            let vn_norm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vp_norm, vc_norm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vp_norm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vp_norm = vc_norm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vn_norm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vn_norm = vc_norm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n * All parameters are provided by CreatePolygon as needed\r\n * @param polygon a mesh built from polygonTriangulation.build()\r\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n * @returns the VertexData of the Polygon\r\n */\r\nexport function CreatePolygonVertexData(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    const faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    const faceColors = fColors;\r\n    const colors = [];\r\n    const wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    const indices = <IndicesArray>polygon.getIndices();\r\n    const startIndex = positions.length / 9;\r\n    let disp = 0;\r\n    let distX = 0;\r\n    let distZ = 0;\r\n    let dist = 0;\r\n    let totalLen = 0;\r\n    const cumulate = [0];\r\n    if (wrap) {\r\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    let idx: number = 0;\r\n    let face: number = 0;\r\n    for (let index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            } else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\r\n            } else {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\r\n            }\r\n        } else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\r\n            }\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polygon mesh\r\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n * * Remember you can only change the shape positions, not their number when updating a polygon\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.smoothingThreshold\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function CreatePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        smoothingThreshold?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const shape = options.shape;\r\n    const holes = options.holes || [];\r\n    const depth = options.depth || 0;\r\n    const smoothingThreshold = options.smoothingThreshold || 2;\r\n    const contours: Array<Vector2> = [];\r\n    let hole: Array<Vector2> = [];\r\n\r\n    for (let i = 0; i < shape.length; i++) {\r\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n    }\r\n    const epsilon = 0.00000001;\r\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n        contours.pop();\r\n    }\r\n\r\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n    for (let hNb = 0; hNb < holes.length; hNb++) {\r\n        hole = [];\r\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n        }\r\n        polygonTriangulation.addHole(hole);\r\n    }\r\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\r\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\r\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n    vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n    return polygon;\r\n}\r\n\r\n/**\r\n * Creates an extruded polygon mesh, with depth in the Y direction.\r\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function ExtrudePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const PolygonBuilder = {\r\n    ExtrudePolygon,\r\n    CreatePolygon,\r\n};\r\n\r\nVertexData.CreatePolygon = CreatePolygonVertexData;\r\nMesh.CreatePolygon = (name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\nMesh.ExtrudePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    depth: number,\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scale\r\n * @param options.rotation\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        options.firstNormal || null,\r\n        options.adjustFrame ? true : false\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scaleFunction\r\n * @param options.rotationFunction\r\n * @param options.ribbonCloseArray\r\n * @param options.ribbonClosePath\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const firstNormal = options.firstNormal || null;\r\n    const adjustFrame = options.adjustFrame || false;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        firstNormal,\r\n        adjustFrame\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>,\r\n    firstNormal: Nullable<Vector3>,\r\n    adjustFrame: boolean\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean,\r\n        adjustFrame: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n        if (adjustFrame) {\r\n            /* fix tangents,normals, binormals */\r\n            for (let i = 0; i < tangents.length; i++) {\r\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\r\n                    tangents[i].copyFrom(tangents[i - 1]);\r\n                }\r\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\r\n                    normals[i].copyFrom(normals[i - 1]);\r\n                }\r\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\r\n                    binormals[i].copyFrom(binormals[i - 1]);\r\n                }\r\n                if (i > 0) {\r\n                    let v = tangents[i - 1];\r\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\r\n                        tangents[i].scaleInPlace(-1);\r\n                    }\r\n                    v = normals[i - 1];\r\n                    if (Vector3.Dot(v, normals[i]) < 0) {\r\n                        normals[i].scaleInPlace(-1);\r\n                    }\r\n                    v = binormals[i - 1];\r\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\r\n                        binormals[i].scaleInPlace(-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath: Vector3[] = [];\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\nMesh.ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Creates lathe mesh.\r\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.clip\r\n * @param options.arc\r\n * @param options.closed\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.cap\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the lathe mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\r\n */\r\nexport function CreateLathe(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        clip?: number;\r\n        arc?: number;\r\n        closed?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        cap?: number;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const arc: number = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\r\n    const closed: boolean = options.closed === undefined ? true : options.closed;\r\n    const shape = options.shape;\r\n    const radius = options.radius || 1;\r\n    const tessellation = options.tessellation || 64;\r\n    const clip = options.clip || 0;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const cap = options.cap || Mesh.NO_CAP;\r\n    const pi2 = Math.PI * 2;\r\n    const paths = [];\r\n    const invertUV = options.invertUV || false;\r\n\r\n    let i = 0;\r\n    let p = 0;\r\n    const step = (pi2 / tessellation) * arc;\r\n    let rotated;\r\n    let path: Array<Vector3>;\r\n    for (i = 0; i <= tessellation - clip; i++) {\r\n        path = [];\r\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(0, shape[0].y, 0));\r\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n        }\r\n        for (p = 0; p < shape.length; p++) {\r\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n            path.push(rotated);\r\n        }\r\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n        }\r\n        paths.push(path);\r\n    }\r\n\r\n    // lathe ribbon\r\n    const lathe = CreateRibbon(\r\n        name,\r\n        { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs },\r\n        scene\r\n    );\r\n    return lathe;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function direction from the module\r\n */\r\nexport const LatheBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateLathe,\r\n};\r\n\r\nMesh.CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateLathe(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Plane\r\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n * * size sets the width and height of the plane to the value of size, optional default 1\r\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreatePlaneVertexData(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    const halfWidth = width / 2.0;\r\n    const halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane mesh\r\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param options.sourcePlane\r\n * @param scene defines the hosting scene\r\n * @returns the plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#plane\r\n */\r\nexport function CreatePlane(\r\n    name: string,\r\n    options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; updatable?: boolean; sourcePlane?: Plane } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    if (options.sourcePlane) {\r\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n    }\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePlane,\r\n};\r\n\r\nVertexData.CreatePlane = CreatePlaneVertexData;\r\nMesh.CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreatePlane(name, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates a tube mesh.\r\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\r\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.path\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.radiusFunction\r\n * @param options.cap\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the tube mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\r\n */\r\nexport function CreateTube(\r\n    name: string,\r\n    options: {\r\n        path: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        radiusFunction?: { (i: number, distance: number): number };\r\n        cap?: number;\r\n        arc?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    let instance = options.instance;\r\n    let radius = 1.0;\r\n\r\n    if (options.radius !== undefined) {\r\n        radius = options.radius;\r\n    } else if (instance) {\r\n        radius = instance._creationDataStorage!.radius;\r\n    }\r\n\r\n    const tessellation = options.tessellation || 64 | 0;\r\n    const radiusFunction = options.radiusFunction || null;\r\n    let cap = options.cap || Mesh.NO_CAP;\r\n    const invertUV = options.invertUV || false;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n    // tube geometry\r\n    const tubePathArray = (\r\n        path: Vector3[],\r\n        path3D: Path3D,\r\n        circlePaths: Vector3[][],\r\n        radius: number,\r\n        tessellation: number,\r\n        radiusFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        arc: number\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const distances = path3D.getDistances();\r\n        const pi2 = Math.PI * 2;\r\n        const step = (pi2 / tessellation) * arc;\r\n        const returnRadius: { (i: number, distance: number): number } = () => radius;\r\n        const radiusFunctionFinal: { (i: number, distance: number): number } = radiusFunction || returnRadius;\r\n\r\n        let circlePath: Vector3[];\r\n        let rad: number;\r\n        let normal: Vector3;\r\n        let rotated: Vector3;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        for (let i = 0; i < path.length; i++) {\r\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n            circlePath = Array<Vector3>(); // current circle array\r\n            normal = normals[i]; // current normal\r\n            for (let t = 0; t < tessellation; t++) {\r\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                circlePath[t] = rotated;\r\n            }\r\n            circlePaths[index] = circlePath;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n            const pointCap = Array<Vector3>();\r\n            for (let i = 0; i < nbPoints; i++) {\r\n                pointCap.push(path[pathIndex]);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                break;\r\n            case Mesh.CAP_END:\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return circlePaths;\r\n    };\r\n\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // tube update\r\n        const storage = instance._creationDataStorage!;\r\n        const arc = options.arc || storage.arc;\r\n        path3D = storage.path3D.update(path);\r\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n        // Update mode, no need to recreate the storage.\r\n        storage.path3D = path3D;\r\n        storage.pathArray = pathArray;\r\n        storage.arc = arc;\r\n        storage.radius = radius;\r\n\r\n        return instance;\r\n    }\r\n\r\n    // tube creation\r\n    path3D = <any>new Path3D(path);\r\n    const newPathArray = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n    const tube = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closePath: true,\r\n            closeArray: false,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            invertUV: invertUV,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs,\r\n        },\r\n        scene\r\n    );\r\n    tube._creationDataStorage!.pathArray = pathArray;\r\n    tube._creationDataStorage!.path3D = path3D;\r\n    tube._creationDataStorage!.tessellation = tessellation;\r\n    tube._creationDataStorage!.cap = cap;\r\n    tube._creationDataStorage!.arc = options.arc;\r\n    tube._creationDataStorage!.radius = radius;\r\n\r\n    return tube;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTube directly\r\n */\r\nexport const TubeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTube,\r\n};\r\n\r\nMesh.CreateTube = (\r\n    name: string,\r\n    path: Vector3[],\r\n    radius: number,\r\n    tessellation: number,\r\n    radiusFunction: { (i: number, distance: number): number },\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n    };\r\n    return CreateTube(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n/**\r\n * Creates the VertexData for a Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * type provided types are:\r\n *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n * * size the size of the IcoSphere, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.type\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.custom\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Polyhedron\r\n */\r\nexport function CreatePolyhedronVertexData(options: {\r\n    type?: number;\r\n    size?: number;\r\n    sizeX?: number;\r\n    sizeY?: number;\r\n    sizeZ?: number;\r\n    custom?: any;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    flat?: boolean;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    // provided polyhedron types :\r\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n    const polyhedra: { vertex: number[][]; face: number[][] }[] = [];\r\n    polyhedra[0] = {\r\n        vertex: [\r\n            [0, 0, 1.732051],\r\n            [1.632993, 0, -0.5773503],\r\n            [-0.8164966, 1.414214, -0.5773503],\r\n            [-0.8164966, -1.414214, -0.5773503],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 1],\r\n            [1, 3, 2],\r\n        ],\r\n    };\r\n    polyhedra[1] = {\r\n        vertex: [\r\n            [0, 0, 1.414214],\r\n            [1.414214, 0, 0],\r\n            [0, 1.414214, 0],\r\n            [-1.414214, 0, 0],\r\n            [0, -1.414214, 0],\r\n            [0, 0, -1.414214],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 1],\r\n            [1, 4, 5],\r\n            [1, 5, 2],\r\n            [2, 5, 3],\r\n            [3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[2] = {\r\n        vertex: [\r\n            [0, 0, 1.070466],\r\n            [0.7136442, 0, 0.7978784],\r\n            [-0.3568221, 0.618034, 0.7978784],\r\n            [-0.3568221, -0.618034, 0.7978784],\r\n            [0.7978784, 0.618034, 0.3568221],\r\n            [0.7978784, -0.618034, 0.3568221],\r\n            [-0.9341724, 0.381966, 0.3568221],\r\n            [0.1362939, 1, 0.3568221],\r\n            [0.1362939, -1, 0.3568221],\r\n            [-0.9341724, -0.381966, 0.3568221],\r\n            [0.9341724, 0.381966, -0.3568221],\r\n            [0.9341724, -0.381966, -0.3568221],\r\n            [-0.7978784, 0.618034, -0.3568221],\r\n            [-0.1362939, 1, -0.3568221],\r\n            [-0.1362939, -1, -0.3568221],\r\n            [-0.7978784, -0.618034, -0.3568221],\r\n            [0.3568221, 0.618034, -0.7978784],\r\n            [0.3568221, -0.618034, -0.7978784],\r\n            [-0.7136442, 0, -0.7978784],\r\n            [0, 0, -1.070466],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 7, 2],\r\n            [0, 2, 6, 9, 3],\r\n            [0, 3, 8, 5, 1],\r\n            [1, 5, 11, 10, 4],\r\n            [2, 7, 13, 12, 6],\r\n            [3, 9, 15, 14, 8],\r\n            [4, 10, 16, 13, 7],\r\n            [5, 8, 14, 17, 11],\r\n            [6, 12, 18, 15, 9],\r\n            [10, 11, 17, 19, 16],\r\n            [12, 13, 16, 19, 18],\r\n            [14, 15, 18, 19, 17],\r\n        ],\r\n    };\r\n    polyhedra[3] = {\r\n        vertex: [\r\n            [0, 0, 1.175571],\r\n            [1.051462, 0, 0.5257311],\r\n            [0.3249197, 1, 0.5257311],\r\n            [-0.8506508, 0.618034, 0.5257311],\r\n            [-0.8506508, -0.618034, 0.5257311],\r\n            [0.3249197, -1, 0.5257311],\r\n            [0.8506508, 0.618034, -0.5257311],\r\n            [0.8506508, -0.618034, -0.5257311],\r\n            [-0.3249197, 1, -0.5257311],\r\n            [-1.051462, 0, -0.5257311],\r\n            [-0.3249197, -1, -0.5257311],\r\n            [0, 0, -1.175571],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 5],\r\n            [0, 5, 1],\r\n            [1, 5, 7],\r\n            [1, 7, 6],\r\n            [1, 6, 2],\r\n            [2, 6, 8],\r\n            [2, 8, 3],\r\n            [3, 8, 9],\r\n            [3, 9, 4],\r\n            [4, 9, 10],\r\n            [4, 10, 5],\r\n            [5, 10, 7],\r\n            [6, 7, 11],\r\n            [6, 11, 8],\r\n            [7, 10, 11],\r\n            [8, 11, 9],\r\n            [9, 11, 10],\r\n        ],\r\n    };\r\n    polyhedra[4] = {\r\n        vertex: [\r\n            [0, 0, 1.070722],\r\n            [0.7148135, 0, 0.7971752],\r\n            [-0.104682, 0.7071068, 0.7971752],\r\n            [-0.6841528, 0.2071068, 0.7971752],\r\n            [-0.104682, -0.7071068, 0.7971752],\r\n            [0.6101315, 0.7071068, 0.5236279],\r\n            [1.04156, 0.2071068, 0.1367736],\r\n            [0.6101315, -0.7071068, 0.5236279],\r\n            [-0.3574067, 1, 0.1367736],\r\n            [-0.7888348, -0.5, 0.5236279],\r\n            [-0.9368776, 0.5, 0.1367736],\r\n            [-0.3574067, -1, 0.1367736],\r\n            [0.3574067, 1, -0.1367736],\r\n            [0.9368776, -0.5, -0.1367736],\r\n            [0.7888348, 0.5, -0.5236279],\r\n            [0.3574067, -1, -0.1367736],\r\n            [-0.6101315, 0.7071068, -0.5236279],\r\n            [-1.04156, -0.2071068, -0.1367736],\r\n            [-0.6101315, -0.7071068, -0.5236279],\r\n            [0.104682, 0.7071068, -0.7971752],\r\n            [0.6841528, -0.2071068, -0.7971752],\r\n            [0.104682, -0.7071068, -0.7971752],\r\n            [-0.7148135, 0, -0.7971752],\r\n            [0, 0, -1.070722],\r\n        ],\r\n        face: [\r\n            [0, 2, 3],\r\n            [1, 6, 5],\r\n            [4, 9, 11],\r\n            [7, 15, 13],\r\n            [8, 16, 10],\r\n            [12, 14, 19],\r\n            [17, 22, 18],\r\n            [20, 21, 23],\r\n            [0, 1, 5, 2],\r\n            [0, 3, 9, 4],\r\n            [0, 4, 7, 1],\r\n            [1, 7, 13, 6],\r\n            [2, 5, 12, 8],\r\n            [2, 8, 10, 3],\r\n            [3, 10, 17, 9],\r\n            [4, 11, 15, 7],\r\n            [5, 6, 14, 12],\r\n            [6, 13, 20, 14],\r\n            [8, 12, 19, 16],\r\n            [9, 17, 18, 11],\r\n            [10, 16, 22, 17],\r\n            [11, 18, 21, 15],\r\n            [13, 15, 21, 20],\r\n            [14, 20, 23, 19],\r\n            [16, 19, 23, 22],\r\n            [18, 22, 23, 21],\r\n        ],\r\n    };\r\n    polyhedra[5] = {\r\n        vertex: [\r\n            [0, 0, 1.322876],\r\n            [1.309307, 0, 0.1889822],\r\n            [-0.9819805, 0.8660254, 0.1889822],\r\n            [0.1636634, -1.299038, 0.1889822],\r\n            [0.3273268, 0.8660254, -0.9449112],\r\n            [-0.8183171, -0.4330127, -0.9449112],\r\n        ],\r\n        face: [\r\n            [0, 3, 1],\r\n            [2, 4, 5],\r\n            [0, 1, 4, 2],\r\n            [0, 2, 5, 3],\r\n            [1, 3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[6] = {\r\n        vertex: [\r\n            [0, 0, 1.159953],\r\n            [1.013464, 0, 0.5642542],\r\n            [-0.3501431, 0.9510565, 0.5642542],\r\n            [-0.7715208, -0.6571639, 0.5642542],\r\n            [0.6633206, 0.9510565, -0.03144481],\r\n            [0.8682979, -0.6571639, -0.3996071],\r\n            [-1.121664, 0.2938926, -0.03144481],\r\n            [-0.2348831, -1.063314, -0.3996071],\r\n            [0.5181548, 0.2938926, -0.9953061],\r\n            [-0.5850262, -0.112257, -0.9953061],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 9, 7],\r\n            [5, 7, 9, 8],\r\n            [0, 3, 7, 5, 1],\r\n            [2, 4, 8, 9, 6],\r\n        ],\r\n    };\r\n    polyhedra[7] = {\r\n        vertex: [\r\n            [0, 0, 1.118034],\r\n            [0.8944272, 0, 0.6708204],\r\n            [-0.2236068, 0.8660254, 0.6708204],\r\n            [-0.7826238, -0.4330127, 0.6708204],\r\n            [0.6708204, 0.8660254, 0.2236068],\r\n            [1.006231, -0.4330127, -0.2236068],\r\n            [-1.006231, 0.4330127, 0.2236068],\r\n            [-0.6708204, -0.8660254, -0.2236068],\r\n            [0.7826238, 0.4330127, -0.6708204],\r\n            [0.2236068, -0.8660254, -0.6708204],\r\n            [-0.8944272, 0, -0.6708204],\r\n            [0, 0, -1.118034],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 10, 7],\r\n            [5, 9, 11, 8],\r\n            [7, 10, 11, 9],\r\n            [0, 3, 7, 9, 5, 1],\r\n            [2, 4, 8, 11, 10, 6],\r\n        ],\r\n    };\r\n    polyhedra[8] = {\r\n        vertex: [\r\n            [-0.729665, 0.670121, 0.319155],\r\n            [-0.655235, -0.29213, -0.754096],\r\n            [-0.093922, -0.607123, 0.537818],\r\n            [0.702196, 0.595691, 0.485187],\r\n            [0.776626, -0.36656, -0.588064],\r\n        ],\r\n        face: [\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [3, 0, 2],\r\n            [4, 3, 2],\r\n            [4, 1, 0, 3],\r\n        ],\r\n    };\r\n    polyhedra[9] = {\r\n        vertex: [\r\n            [-0.868849, -0.100041, 0.61257],\r\n            [-0.329458, 0.976099, 0.28078],\r\n            [-0.26629, -0.013796, -0.477654],\r\n            [-0.13392, -1.034115, 0.229829],\r\n            [0.738834, 0.707117, -0.307018],\r\n            [0.859683, -0.535264, -0.338508],\r\n        ],\r\n        face: [\r\n            [3, 0, 2],\r\n            [5, 3, 2],\r\n            [4, 5, 2],\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [0, 3, 5, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[10] = {\r\n        vertex: [\r\n            [-0.610389, 0.243975, 0.531213],\r\n            [-0.187812, -0.48795, -0.664016],\r\n            [-0.187812, 0.9759, -0.664016],\r\n            [0.187812, -0.9759, 0.664016],\r\n            [0.798201, 0.243975, 0.132803],\r\n        ],\r\n        face: [\r\n            [1, 3, 0],\r\n            [3, 4, 0],\r\n            [3, 1, 4],\r\n            [0, 2, 1],\r\n            [0, 4, 2],\r\n            [2, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[11] = {\r\n        vertex: [\r\n            [-1.028778, 0.392027, -0.048786],\r\n            [-0.640503, -0.646161, 0.621837],\r\n            [-0.125162, -0.395663, -0.540059],\r\n            [0.004683, 0.888447, -0.651988],\r\n            [0.125161, 0.395663, 0.540059],\r\n            [0.632925, -0.791376, 0.433102],\r\n            [1.031672, 0.157063, -0.354165],\r\n        ],\r\n        face: [\r\n            [3, 2, 0],\r\n            [2, 1, 0],\r\n            [2, 5, 1],\r\n            [0, 4, 3],\r\n            [0, 1, 4],\r\n            [4, 1, 5],\r\n            [2, 3, 6],\r\n            [3, 4, 6],\r\n            [5, 2, 6],\r\n            [4, 5, 6],\r\n        ],\r\n    };\r\n    polyhedra[12] = {\r\n        vertex: [\r\n            [-0.669867, 0.334933, -0.529576],\r\n            [-0.669867, 0.334933, 0.529577],\r\n            [-0.4043, 1.212901, 0],\r\n            [-0.334933, -0.669867, -0.529576],\r\n            [-0.334933, -0.669867, 0.529577],\r\n            [0.334933, 0.669867, -0.529576],\r\n            [0.334933, 0.669867, 0.529577],\r\n            [0.4043, -1.212901, 0],\r\n            [0.669867, -0.334933, -0.529576],\r\n            [0.669867, -0.334933, 0.529577],\r\n        ],\r\n        face: [\r\n            [8, 9, 7],\r\n            [6, 5, 2],\r\n            [3, 8, 7],\r\n            [5, 0, 2],\r\n            [4, 3, 7],\r\n            [0, 1, 2],\r\n            [9, 4, 7],\r\n            [1, 6, 2],\r\n            [9, 8, 5, 6],\r\n            [8, 3, 0, 5],\r\n            [3, 4, 1, 0],\r\n            [4, 9, 6, 1],\r\n        ],\r\n    };\r\n    polyhedra[13] = {\r\n        vertex: [\r\n            [-0.931836, 0.219976, -0.264632],\r\n            [-0.636706, 0.318353, 0.692816],\r\n            [-0.613483, -0.735083, -0.264632],\r\n            [-0.326545, 0.979634, 0],\r\n            [-0.318353, -0.636706, 0.692816],\r\n            [-0.159176, 0.477529, -0.856368],\r\n            [0.159176, -0.477529, -0.856368],\r\n            [0.318353, 0.636706, 0.692816],\r\n            [0.326545, -0.979634, 0],\r\n            [0.613482, 0.735082, -0.264632],\r\n            [0.636706, -0.318353, 0.692816],\r\n            [0.931835, -0.219977, -0.264632],\r\n        ],\r\n        face: [\r\n            [11, 10, 8],\r\n            [7, 9, 3],\r\n            [6, 11, 8],\r\n            [9, 5, 3],\r\n            [2, 6, 8],\r\n            [5, 0, 3],\r\n            [4, 2, 8],\r\n            [0, 1, 3],\r\n            [10, 4, 8],\r\n            [1, 7, 3],\r\n            [10, 11, 9, 7],\r\n            [11, 6, 5, 9],\r\n            [6, 2, 0, 5],\r\n            [2, 4, 1, 0],\r\n            [4, 10, 7, 1],\r\n        ],\r\n    };\r\n    polyhedra[14] = {\r\n        vertex: [\r\n            [-0.93465, 0.300459, -0.271185],\r\n            [-0.838689, -0.260219, -0.516017],\r\n            [-0.711319, 0.717591, 0.128359],\r\n            [-0.710334, -0.156922, 0.080946],\r\n            [-0.599799, 0.556003, -0.725148],\r\n            [-0.503838, -0.004675, -0.969981],\r\n            [-0.487004, 0.26021, 0.48049],\r\n            [-0.460089, -0.750282, -0.512622],\r\n            [-0.376468, 0.973135, -0.325605],\r\n            [-0.331735, -0.646985, 0.084342],\r\n            [-0.254001, 0.831847, 0.530001],\r\n            [-0.125239, -0.494738, -0.966586],\r\n            [0.029622, 0.027949, 0.730817],\r\n            [0.056536, -0.982543, -0.262295],\r\n            [0.08085, 1.087391, 0.076037],\r\n            [0.125583, -0.532729, 0.485984],\r\n            [0.262625, 0.599586, 0.780328],\r\n            [0.391387, -0.726999, -0.716259],\r\n            [0.513854, -0.868287, 0.139347],\r\n            [0.597475, 0.85513, 0.326364],\r\n            [0.641224, 0.109523, 0.783723],\r\n            [0.737185, -0.451155, 0.538891],\r\n            [0.848705, -0.612742, -0.314616],\r\n            [0.976075, 0.365067, 0.32976],\r\n            [1.072036, -0.19561, 0.084927],\r\n        ],\r\n        face: [\r\n            [15, 18, 21],\r\n            [12, 20, 16],\r\n            [6, 10, 2],\r\n            [3, 0, 1],\r\n            [9, 7, 13],\r\n            [2, 8, 4, 0],\r\n            [0, 4, 5, 1],\r\n            [1, 5, 11, 7],\r\n            [7, 11, 17, 13],\r\n            [13, 17, 22, 18],\r\n            [18, 22, 24, 21],\r\n            [21, 24, 23, 20],\r\n            [20, 23, 19, 16],\r\n            [16, 19, 14, 10],\r\n            [10, 14, 8, 2],\r\n            [15, 9, 13, 18],\r\n            [12, 15, 21, 20],\r\n            [6, 12, 16, 10],\r\n            [3, 6, 2, 0],\r\n            [9, 3, 1, 7],\r\n            [9, 15, 12, 6, 3],\r\n            [22, 17, 11, 5, 4, 8, 14, 19, 23, 24],\r\n        ],\r\n    };\r\n\r\n    const type: number = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const data: { vertex: number[][]; face: number[][]; name?: string; category?: string } = options.custom || polyhedra[type];\r\n    const nbfaces = data.face.length;\r\n    const faceUV = options.faceUV || new Array(nbfaces);\r\n    const faceColors = options.faceColors;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n    let index = 0;\r\n    let faceIdx = 0; // face cursor in the array \"indexes\"\r\n    const indexes: number[] = [];\r\n    let i = 0;\r\n    let f = 0;\r\n    let u: number, v: number, ang: number, x: number, y: number, tmp: number;\r\n\r\n    // default face colors and UV if undefined\r\n    if (flat) {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            if (faceColors && faceColors[f] === undefined) {\r\n                faceColors[f] = new Color4(1, 1, 1, 1);\r\n            }\r\n            if (faceUV && faceUV[f] === undefined) {\r\n                faceUV[f] = new Vector4(0, 0, 1, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!flat) {\r\n        for (i = 0; i < data.vertex.length; i++) {\r\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\r\n            uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0);\r\n        }\r\n        for (f = 0; f < nbfaces; f++) {\r\n            for (i = 0; i < data.face[f].length - 2; i++) {\r\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\r\n            }\r\n        }\r\n    } else {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            const fl = data.face[f].length; // number of vertices of the current face\r\n            ang = (2 * Math.PI) / fl;\r\n            x = 0.5 * Math.tan(ang / 2);\r\n            y = 0.5;\r\n\r\n            // positions, uvs, colors\r\n            for (i = 0; i < fl; i++) {\r\n                // positions\r\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\r\n                indexes.push(index);\r\n                index++;\r\n                // uvs\r\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\r\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\r\n                uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\r\n                y = x * Math.sin(ang) + y * Math.cos(ang);\r\n                x = tmp;\r\n                // colors\r\n                if (faceColors) {\r\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n                }\r\n            }\r\n\r\n            // indices from indexes\r\n            for (i = 0; i < fl - 2; i++) {\r\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\r\n            }\r\n            faceIdx += fl;\r\n        }\r\n    }\r\n\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors && flat) {\r\n        vertexData.colors = colors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polyhedron mesh\r\n * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n * * The parameter `size` (positive float, default 1) sets the polygon size\r\n * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`\r\n * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.type\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.custom\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the polyhedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra\r\n */\r\nexport function CreatePolyhedron(\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const polyhedron = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    polyhedron._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePolyhedronVertexData(options);\r\n\r\n    vertexData.applyToMesh(polyhedron, options.updatable);\r\n\r\n    return polyhedron;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PolyhedronBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePolyhedron,\r\n};\r\n\r\nVertexData.CreatePolyhedron = CreatePolyhedronVertexData;\r\n\r\nMesh.CreatePolyhedron = (\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n    },\r\n    scene: Scene\r\n): Mesh => {\r\n    return CreatePolyhedron(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the IcoSphere\r\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n * * radius the radius of the IcoSphere, optional default 1\r\n * * radiusX allows stretching in the x direction, optional, default radius\r\n * * radiusY allows stretching in the y direction, optional, default radius\r\n * * radiusZ allows stretching in the z direction, optional, default radius\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the IcoSphere\r\n */\r\nexport function CreateIcoSphereVertexData(options: {\r\n    radius?: number;\r\n    radiusX?: number;\r\n    radiusY?: number;\r\n    radiusZ?: number;\r\n    flat?: boolean;\r\n    subdivisions?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const radius = options.radius || 1;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const subdivisions = (options.subdivisions || 4) | 0;\r\n    const radiusX = options.radiusX || radius;\r\n    const radiusY = options.radiusY || radius;\r\n    const radiusZ = options.radiusZ || radius;\r\n\r\n    const t = (1 + Math.sqrt(5)) / 2;\r\n\r\n    // 12 vertex x,y,z\r\n    const icoVertices = [\r\n        -1,\r\n        t,\r\n        -0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0, // v0-3\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1,\r\n        t,\r\n        0,\r\n        1,\r\n        t, // v4-7\r\n        t,\r\n        0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1, // v8-11\r\n    ];\r\n\r\n    // index of 3 vertex makes a face of icopshere\r\n    const ico_indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\r\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    const vertices_unalias_id = [\r\n        0,\r\n        1,\r\n        2,\r\n        3,\r\n        4,\r\n        5,\r\n        6,\r\n        7,\r\n        8,\r\n        9,\r\n        10,\r\n        11,\r\n        // vertex alias\r\n        0, // 12: 0 + 12\r\n        2, // 13: 2 + 11\r\n        3, // 14: 3 + 11\r\n        3, // 15: 3 + 12\r\n        3, // 16: 3 + 13\r\n        4, // 17: 4 + 13\r\n        7, // 18: 7 + 11\r\n        8, // 19: 8 + 11\r\n        9, // 20: 9 + 11\r\n        9, // 21: 9 + 12\r\n        10, // 22: A + 12\r\n        11, // 23: B + 12\r\n    ];\r\n\r\n    // uv as integer step (not pixels !)\r\n    const ico_vertexuv = [\r\n        5,\r\n        1,\r\n        3,\r\n        1,\r\n        6,\r\n        4,\r\n        0,\r\n        0, // v0-3\r\n        5,\r\n        3,\r\n        4,\r\n        2,\r\n        2,\r\n        2,\r\n        4,\r\n        0, // v4-7\r\n        2,\r\n        0,\r\n        1,\r\n        1,\r\n        6,\r\n        0,\r\n        6,\r\n        2, // v8-11\r\n        // vertex alias (for same vertex on different faces)\r\n        0,\r\n        4, // 12: 0 + 12\r\n        3,\r\n        3, // 13: 2 + 11\r\n        4,\r\n        4, // 14: 3 + 11\r\n        3,\r\n        1, // 15: 3 + 12\r\n        4,\r\n        2, // 16: 3 + 13\r\n        4,\r\n        4, // 17: 4 + 13\r\n        0,\r\n        2, // 18: 7 + 11\r\n        1,\r\n        1, // 19: 8 + 11\r\n        2,\r\n        2, // 20: 9 + 11\r\n        3,\r\n        3, // 21: 9 + 12\r\n        1,\r\n        3, // 22: A + 12\r\n        2,\r\n        4, // 23: B + 12\r\n    ];\r\n\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    const ustep = 138 / 1024;\r\n    const vstep = 239 / 1024;\r\n    const uoffset = 60 / 1024;\r\n    const voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    const island_u_offset = -40 / 1024;\r\n    const island_v_offset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    const island = [\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1, //  0 - 4\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  5 - 9\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  10 - 14\r\n        0,\r\n        1,\r\n        1,\r\n        1,\r\n        0, //  15 - 19\r\n    ];\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    let current_indice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    const face_vertex_pos = new Array(3);\r\n    const face_vertex_uv = new Array(3);\r\n    let v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        face_vertex_pos[v012] = Vector3.Zero();\r\n        face_vertex_uv[v012] = Vector2.Zero();\r\n    }\r\n    // create all with normals\r\n    for (let face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            const v_id = ico_indices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            face_vertex_pos[v012].copyFromFloats(\r\n                icoVertices[3 * vertices_unalias_id[v_id]],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 1],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 2]\r\n            );\r\n            // Normalize to get normal\r\n            face_vertex_pos[v012].normalize();\r\n\r\n            // uv Coordinates from vertex ID\r\n            face_vertex_uv[v012].copyFromFloats(\r\n                ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset,\r\n                ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset\r\n            );\r\n        }\r\n\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n\r\n        const interp_vertex = (i1: number, i2: number, c1: number, c2: number) => {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\r\n            pos_interp.normalize();\r\n\r\n            let vertex_normal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\r\n                const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\r\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\r\n            } else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertex_normal.x /= radiusX;\r\n            vertex_normal.y /= radiusY;\r\n            vertex_normal.z /= radiusZ;\r\n            vertex_normal.normalize();\r\n\r\n            const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\r\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\r\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\r\n            uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(current_indice);\r\n            current_indice++;\r\n        };\r\n\r\n        for (let i2 = 0; i2 < subdivisions; i2++) {\r\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the icosahedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\r\n */\r\nexport function CreateIcoSphere(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateIcoSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const IcoSphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateIcoSphere,\r\n};\r\n\r\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\r\n\r\nMesh.CreateIcoSphere = (name: string, options: { radius?: number; flat?: boolean; subdivisions?: number; sideOrientation?: number; updatable?: boolean }, scene: Scene): Mesh => {\r\n    return CreateIcoSphere(name, options, scene);\r\n};\r\n", "import type { Nullable, IndicesArray, FloatArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\nconst xpAxis = new Vector3(1, 0, 0);\r\nconst xnAxis = new Vector3(-1, 0, 0);\r\nconst ypAxis = new Vector3(0, 1, 0);\r\nconst ynAxis = new Vector3(0, -1, 0);\r\nconst zpAxis = new Vector3(0, 0, 1);\r\nconst znAxis = new Vector3(0, 0, -1);\r\n\r\n/** @internal */\r\nclass DecalVertex {\r\n    constructor(\r\n        public position: Vector3 = Vector3.Zero(),\r\n        public normal: Vector3 = Vector3.Up(),\r\n        public uv: Vector2 = Vector2.Zero(),\r\n        public vertexIdx: number = 0,\r\n        public vertexIdxForBones: number = 0,\r\n        public localPositionOverride: Nullable<number[]> = null,\r\n        public localNormalOverride: Nullable<number[]> = null,\r\n        public matrixIndicesOverride: Nullable<number[]> = null,\r\n        public matrixWeightsOverride: Nullable<number[]> = null\r\n    ) {}\r\n    public clone(): DecalVertex {\r\n        return new DecalVertex(\r\n            this.position.clone(),\r\n            this.normal.clone(),\r\n            this.uv.clone(),\r\n            this.vertexIdx,\r\n            this.vertexIdxForBones,\r\n            this.localPositionOverride?.slice(),\r\n            this.localNormalOverride?.slice(),\r\n            this.matrixIndicesOverride?.slice(),\r\n            this.matrixWeightsOverride?.slice()\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\r\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\r\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\r\n * Note: Meshes with morph targets are not supported!\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @param options.position\r\n * @param options.normal\r\n * @param options.size\r\n * @param options.angle\r\n * @param options.captureUVS\r\n * @param options.cullBackFaces\r\n * @param options.localMode\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\r\n */\r\nexport function CreateDecal(\r\n    name: string,\r\n    sourceMesh: AbstractMesh,\r\n    options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean; cullBackFaces?: boolean; localMode?: boolean }\r\n): Mesh {\r\n    const hasSkeleton = !!sourceMesh.skeleton;\r\n    const useLocalComputation = options.localMode || hasSkeleton;\r\n    const meshHasOverridenMaterial = (sourceMesh as Mesh).overrideMaterialSideOrientation !== null && (sourceMesh as Mesh).overrideMaterialSideOrientation !== undefined;\r\n\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\r\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\r\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\r\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\r\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\r\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\r\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number, transformMatrix: Matrix): DecalVertex => {\r\n        const result = new DecalVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n\r\n        result.vertexIdx = vertexId * 3;\r\n        result.vertexIdxForBones = vertexId * 4;\r\n\r\n        // Send vector to decal local world\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const emptyArray = [0, 0, 0, 0];\r\n\r\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: DecalVertex[], axis: Vector3): Nullable<DecalVertex[]> => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const indexOf = (arr: FloatArray | number[], val: number, start: number, num: number) => {\r\n            for (let i = 0; i < num; ++i) {\r\n                if (arr[start + i] === val) {\r\n                    return start + i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n        const clipVertices = (v0: DecalVertex, v1: DecalVertex): DecalVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            let indices = emptyArray;\r\n            let weights = emptyArray;\r\n\r\n            if (matIndices && matWeights) {\r\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\r\n                const v0Indices = v0.matrixIndicesOverride ?? matIndices;\r\n                const v0Weights = v0.matrixWeightsOverride ?? matWeights;\r\n\r\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\r\n                const v1Indices = v1.matrixIndicesOverride ?? matIndices;\r\n                const v1Weights = v1.matrixWeightsOverride ?? matWeights;\r\n\r\n                indices = [0, 0, 0, 0];\r\n                weights = [0, 0, 0, 0];\r\n\r\n                let index = 0;\r\n                for (let i = 0; i < 4; ++i) {\r\n                    if (v0Weights[mat0Index + i] > 0) {\r\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\r\n                        indices[index] = v0Indices[mat0Index + i];\r\n                        weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\r\n                        index++;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < 4 && index < 4; ++i) {\r\n                    const ind = v1Indices[mat1Index + i];\r\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\r\n\r\n                    indices[index] = ind;\r\n                    weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\r\n                    index++;\r\n                }\r\n\r\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\r\n\r\n                weights[0] /= sumw;\r\n                weights[1] /= sumw;\r\n                weights[2] /= sumw;\r\n                weights[3] /= sumw;\r\n            }\r\n\r\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\r\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\r\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\r\n\r\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\r\n\r\n            return new DecalVertex(\r\n                Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(),\r\n                Vector2.Lerp(v0.uv, v1.uv, clipFactor),\r\n                -1,\r\n                -1,\r\n                localPositions\r\n                    ? [\r\n                          v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\r\n                          v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\r\n                          v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\r\n                      ]\r\n                    : null,\r\n                localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null,\r\n                indices,\r\n                weights\r\n            );\r\n        };\r\n\r\n        let clipResult: Nullable<DecalVertex[]> = null;\r\n\r\n        if (vertices.length > 3) {\r\n            clipResult = [] as DecalVertex[];\r\n        }\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<DecalVertex> = null;\r\n            let nV2: Nullable<DecalVertex> = null;\r\n            let nV3: Nullable<DecalVertex> = null;\r\n            let nV4: Nullable<DecalVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    if (vertices.length > 3) {\r\n                        clipResult!.push(vertices[index]);\r\n                        clipResult!.push(vertices[index + 1]);\r\n                        clipResult!.push(vertices[index + 2]);\r\n                    } else {\r\n                        clipResult = vertices;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        clipResult.push(nV3);\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV1.clone());\r\n\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        clipResult.push(nV1.clone());\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3);\r\n\r\n                        clipResult.push(nV4);\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return clipResult;\r\n    };\r\n\r\n    const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;\r\n    const matrixData = sourceMeshAsMesh?._thinInstanceDataStorage.matrixData;\r\n\r\n    const numMatrices = sourceMeshAsMesh?.thinInstanceCount || 1;\r\n    const thinInstanceMatrix = TmpVectors.Matrix[0];\r\n\r\n    thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\r\n\r\n    for (let m = 0; m < numMatrices; ++m) {\r\n        if (sourceMeshAsMesh?.hasThinInstances && matrixData) {\r\n            const ofst = m * 16;\r\n\r\n            thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\r\n            thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\r\n            thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\r\n            thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\r\n        }\r\n\r\n        // Matrix\r\n        const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n        const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n        const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\r\n\r\n        const oneFaceVertices = new Array<DecalVertex>(3);\r\n\r\n        for (let index = 0; index < indices.length; index += 3) {\r\n            let faceVertices: Nullable<DecalVertex[]> = oneFaceVertices;\r\n\r\n            faceVertices[0] = extractDecalVector3(index, transformMatrix);\r\n            if (meshHasOverridenMaterial && useLocalComputation) {\r\n                faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);\r\n            } else {\r\n                faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\r\n            }\r\n\r\n            if (options.cullBackFaces) {\r\n                // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\r\n                // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\r\n                if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Clip\r\n            faceVertices = clip(faceVertices, xpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, xnAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ypAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ynAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, zpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, znAxis);\r\n            if (!faceVertices) continue;\r\n\r\n            // Add UVs and get back to world\r\n            for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                const vertex = faceVertices[vIndex];\r\n\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n                if (useLocalComputation) {\r\n                    if (vertex.localPositionOverride) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\r\n                    } else if (localPositions) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\r\n                    }\r\n                    if (vertex.localNormalOverride) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\r\n                    } else if (localNormals) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\r\n                    }\r\n                } else {\r\n                    vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                    vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                }\r\n                if (vertexData.matricesIndices && vertexData.matricesWeights) {\r\n                    if (vertex.matrixIndicesOverride) {\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\r\n                    } else {\r\n                        if (matIndices) {\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matIndicesExtra && vertexData.matricesIndicesExtra) {\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                    if (vertex.matrixWeightsOverride) {\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\r\n                    } else {\r\n                        if (matWeights) {\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matWeightsExtra && vertexData.matricesWeightsExtra) {\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!options.captureUVS) {\r\n                    (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                    const v = 0.5 + vertex.position.y / size.y;\r\n                    (<number[]>vertexData.uvs).push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                } else {\r\n                    vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n                }\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\r\n    if (vertexData.indices.length === 0) vertexData.indices = null;\r\n    if (vertexData.positions.length === 0) vertexData.positions = null;\r\n    if (vertexData.normals.length === 0) vertexData.normals = null;\r\n    if (vertexData.uvs.length === 0) vertexData.uvs = null;\r\n    if (vertexData.matricesIndices?.length === 0) vertexData.matricesIndices = null;\r\n    if (vertexData.matricesWeights?.length === 0) vertexData.matricesWeights = null;\r\n    if (vertexData.matricesIndicesExtra?.length === 0) vertexData.matricesIndicesExtra = null;\r\n    if (vertexData.matricesWeightsExtra?.length === 0) vertexData.matricesWeightsExtra = null;\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    if (useLocalComputation) {\r\n        decal.skeleton = sourceMesh.skeleton;\r\n        decal.parent = sourceMesh;\r\n    } else {\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n    }\r\n\r\n    decal.computeWorldMatrix(true);\r\n    decal.refreshBoundingInfo(true, true);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\nMesh.CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n", "import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsuleVertexData(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n    }\r\n): VertexData {\r\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1) | 0;\r\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3) | 0;\r\n    const height = Math.max(options.height ? options.height : 1, 0);\r\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\r\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1) | 0;\r\n\r\n    const radialSegments = tessellation;\r\n    const heightSegments = subdivisions;\r\n\r\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\r\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\r\n\r\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    const thetaStart = 0.0;\r\n    const thetaLength = 2.0 * Math.PI;\r\n\r\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    let indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    let index = 0;\r\n    const indexArray = [],\r\n        halfHeight = heightMinusCaps * 0.5;\r\n    const pi2 = Math.PI * 0.5;\r\n\r\n    let x, y;\r\n    const normal = Vector3.Zero();\r\n    const vertex = Vector3.Zero();\r\n\r\n    const cosAlpha = Math.cos(alpha);\r\n    const sinAlpha = Math.sin(alpha);\r\n\r\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\r\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\r\n        .length();\r\n\r\n    // Total length for v texture coord\r\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\r\n\r\n    let v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n        const indexRow = [];\r\n\r\n        const a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += (radiusTop * alpha) / capsTopSegments;\r\n\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        const indexRow = [];\r\n        v += coneLength / heightSegments;\r\n        // calculate the radius of the current row\r\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        const indexRow = [];\r\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += (radiusBottom * alpha) / capsBottomSegments;\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\r\n            // we use the index array to access the correct indices\r\n            const i1 = indexArray[y][x];\r\n            const i2 = indexArray[y + 1][x];\r\n            const i3 = indexArray[y + 1][x + 1];\r\n            const i4 = indexArray[y][x + 1];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        const m = new Matrix();\r\n        options.orientation\r\n            .clone()\r\n            .scale(Math.PI * 0.5)\r\n            .cross(Vector3.Up())\r\n            .toQuaternion()\r\n            .toRotationMatrix(m);\r\n        const v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    const vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n}\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions {\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions?: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation?: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height?: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius?: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions?: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n\r\n    /** Internal geometry is supposed to change once created. */\r\n    updatable?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh\r\n * @param options The constructors options.\r\n * @param scene The scene the mesh is scoped to.\r\n * @returns Capsule Mesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsule(\r\n    name: string,\r\n    options: ICreateCapsuleOptions = {\r\n        orientation: Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n        updatable: false,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const capsule = new Mesh(name, scene);\r\n    const vertexData = CreateCapsuleVertexData(options);\r\n    vertexData.applyToMesh(capsule, options.updatable);\r\n    return capsule;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateCapsule directly\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const CapsuleBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCapsule,\r\n};\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\nMesh.CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh => {\r\n    return CreateCapsule(name, options, scene);\r\n};\r\n\r\nVertexData.CreateCapsule = CreateCapsuleVertexData;\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { Vector3 } from \"./math.vector\";\r\n\r\n/**\r\n * Class representing an isovector a vector containing 2 INTEGER coordinates\r\n * x axis is horizontal\r\n * y axis is 60 deg counter clockwise from positive y axis\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IsoVector {\r\n    /**\r\n     * Creates a new isovector from the given x and y coordinates\r\n     * @param x defines the first coordinate, must be an integer\r\n     * @param y defines the second coordinate, must be an integer\r\n     */\r\n    constructor(\r\n        /** defines the first coordinate */\r\n        public x: number = 0,\r\n        /** defines the second coordinate */\r\n        public y: number = 0\r\n    ) {\r\n        if (x !== Math.floor(x)) {\r\n            x === Math.floor(x);\r\n            Logger.Warn(\"x is not an integer, floor(x) used\");\r\n        }\r\n        if (y !== Math.floor(y)) {\r\n            y === Math.floor(y);\r\n            Logger.Warn(\"y is not an integer, floor(y) used\");\r\n        }\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Gets a new IsoVector copied from the IsoVector\r\n     * @returns a new IsoVector\r\n     */\r\n    public clone(): _IsoVector {\r\n        return new _IsoVector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees counter clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector a center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate60About(other: _IsoVector) {\r\n        //other IsoVector\r\n        const x: number = this.x;\r\n        this.x = other.x + other.y - this.y;\r\n        this.y = x + this.y - other.x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector as center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg60About(other: _IsoVector) {\r\n        const x = this.x;\r\n        this.x = x + this.y - other.y;\r\n        this.y = other.x + other.y - x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m === Math.floor(m);\r\n            Logger.Warn(\"m not an integer only floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n === Math.floor(n);\r\n            Logger.Warn(\"n not an integer only floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = m - x - this.y;\r\n        this.y = n + x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m === Math.floor(m);\r\n            Logger.Warn(\"m is not an integer, floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n === Math.floor(n);\r\n            Logger.Warn(\"n is not an integer,   floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = this.y - n;\r\n        this.y = m + n - x - this.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms an IsoVector to one in Cartesian 3D space based on an isovector\r\n     * @param origin an IsoVector\r\n     * @param isoGridSize\r\n     * @returns Point as a Vector3\r\n     */\r\n    public toCartesianOrigin(origin: _IsoVector, isoGridSize: number) {\r\n        const point = Vector3.Zero();\r\n        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;\r\n        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;\r\n        return point;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Gets a new IsoVector(0, 0)\r\n     * @returns a new IsoVector\r\n     */\r\n    public static Zero(): _IsoVector {\r\n        return new _IsoVector(0, 0);\r\n    }\r\n}\r\n", "import { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { PHI } from \"../Maths/math.constants\";\r\nimport { _IsoVector } from \"../Maths/math.isovector\";\r\n\r\n/**\r\n * Class representing data for one face OAB of an equilateral icosahedron\r\n * When O is the isovector (0, 0), A is isovector (m, n)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _PrimaryIsoTriangle {\r\n    //properties\r\n    public m: number;\r\n    public n: number;\r\n    public cartesian: Vector3[] = [];\r\n    public vertices: _IsoVector[] = [];\r\n    public max: number[] = [];\r\n    public min: number[] = [];\r\n    public vecToidx: { [key: string]: number };\r\n    public vertByDist: { [key: string]: number[] };\r\n    public closestTo: number[][] = [];\r\n\r\n    public innerFacets: string[][] = [];\r\n    public isoVecsABOB: _IsoVector[][] = [];\r\n    public isoVecsOBOA: _IsoVector[][] = [];\r\n    public isoVecsBAOA: _IsoVector[][] = [];\r\n    public vertexTypes: number[][] = [];\r\n\r\n    public coau: number;\r\n    public cobu: number;\r\n    public coav: number;\r\n    public cobv: number;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public IDATA: PolyhedronData = new PolyhedronData(\r\n        \"icosahedron\",\r\n        \"Regular\",\r\n        [\r\n            [0, PHI, -1],\r\n            [-PHI, 1, 0],\r\n            [-1, 0, -PHI],\r\n            [1, 0, -PHI],\r\n            [PHI, 1, 0],\r\n            [0, PHI, 1],\r\n            [-1, 0, PHI],\r\n            [-PHI, -1, 0],\r\n            [0, -PHI, -1],\r\n            [PHI, -1, 0],\r\n            [1, 0, PHI],\r\n            [0, -PHI, 1],\r\n        ],\r\n        [\r\n            [0, 2, 1],\r\n            [0, 3, 2],\r\n            [0, 4, 3],\r\n            [0, 5, 4],\r\n            [0, 1, 5],\r\n            [7, 6, 1],\r\n            [8, 7, 2],\r\n            [9, 8, 3],\r\n            [10, 9, 4],\r\n            [6, 10, 5],\r\n            [2, 7, 1],\r\n            [3, 8, 2],\r\n            [4, 9, 3],\r\n            [5, 10, 4],\r\n            [1, 6, 5],\r\n            [11, 6, 7],\r\n            [11, 7, 8],\r\n            [11, 8, 9],\r\n            [11, 9, 10],\r\n            [11, 10, 6],\r\n        ]\r\n    );\r\n\r\n    /**\r\n     * Creates the PrimaryIsoTriangle Triangle OAB\r\n     * @param m an integer\r\n     * @param n an integer\r\n     */\r\n\r\n    //operators\r\n    public setIndices() {\r\n        let indexCount = 12; // 12 vertices already assigned\r\n        const vecToidx: { [key: string]: number } = {}; //maps iso-vectors to indexCount;\r\n        const m = this.m;\r\n        const n = this.n;\r\n        let g = m; // hcf of m, n when n != 0\r\n        let m1 = 1;\r\n        let n1 = 0;\r\n        if (n !== 0) {\r\n            g = Scalar.HCF(m, n);\r\n        }\r\n        m1 = m / g;\r\n        n1 = n / g;\r\n\r\n        let fr: number | string; //face to the right of current face\r\n        let rot: number | string; //rotation about which vertex for fr\r\n        let O: number;\r\n        let A: number;\r\n        let B: number;\r\n        const oVec: _IsoVector = _IsoVector.Zero();\r\n        const aVec = new _IsoVector(m, n);\r\n        const bVec = new _IsoVector(-n, m + n);\r\n        const oaVec: _IsoVector = _IsoVector.Zero();\r\n        const abVec: _IsoVector = _IsoVector.Zero();\r\n        const obVec: _IsoVector = _IsoVector.Zero();\r\n        let verts: number[] = [];\r\n        let idx: string;\r\n        let idxR: string;\r\n        let isoId: string;\r\n        let isoIdR: string;\r\n\r\n        const closestTo: number[][] = [];\r\n        const vDist = this.vertByDist;\r\n\r\n        const matchIdx = (f: number, fr: number, isoId: string, isoIdR: string) => {\r\n            idx = f + \"|\" + isoId;\r\n            idxR = fr + \"|\" + isoIdR;\r\n            if (!(idx in vecToidx || idxR in vecToidx)) {\r\n                vecToidx[idx] = indexCount;\r\n                vecToidx[idxR] = indexCount;\r\n                indexCount++;\r\n            } else if (idx in vecToidx && !(idxR in vecToidx)) {\r\n                vecToidx[idxR] = vecToidx[idx];\r\n            } else if (idxR in vecToidx && !(idx in vecToidx)) {\r\n                vecToidx[idx] = vecToidx[idxR];\r\n            }\r\n            if (vDist[isoId][0] > 2) {\r\n                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n            } else {\r\n                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n            }\r\n        };\r\n\r\n        this.IDATA.edgematch = [\r\n            [1, \"B\"],\r\n            [2, \"B\"],\r\n            [3, \"B\"],\r\n            [4, \"B\"],\r\n            [0, \"B\"],\r\n            [10, \"O\", 14, \"A\"],\r\n            [11, \"O\", 10, \"A\"],\r\n            [12, \"O\", 11, \"A\"],\r\n            [13, \"O\", 12, \"A\"],\r\n            [14, \"O\", 13, \"A\"],\r\n            [0, \"O\"],\r\n            [1, \"O\"],\r\n            [2, \"O\"],\r\n            [3, \"O\"],\r\n            [4, \"O\"],\r\n            [19, \"B\", 5, \"A\"],\r\n            [15, \"B\", 6, \"A\"],\r\n            [16, \"B\", 7, \"A\"],\r\n            [17, \"B\", 8, \"A\"],\r\n            [18, \"B\", 9, \"A\"],\r\n        ];\r\n\r\n        /***edges AB to OB***** rotation about B*/\r\n        for (let f = 0; f < 20; f++) {\r\n            //f current face\r\n\r\n            verts = this.IDATA.face[f];\r\n            O = verts[2];\r\n            A = verts[1];\r\n            B = verts[0];\r\n\r\n            isoId = oVec.x + \"|\" + oVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = O;\r\n                closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = aVec.x + \"|\" + aVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = A;\r\n                closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = bVec.x + \"|\" + bVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = B;\r\n                closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            //for edge vertices\r\n            fr = <number>this.IDATA.edgematch[f][0];\r\n            rot = <string>this.IDATA.edgematch[f][1];\r\n            if (rot === \"B\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    abVec.x = m - i * (m1 + n1);\r\n                    abVec.y = n + i * m1;\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    isoId = abVec.x + \"|\" + abVec.y;\r\n                    isoIdR = obVec.x + \"|\" + obVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            if (rot === \"O\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    isoId = obVec.x + \"|\" + obVec.y;\r\n                    isoIdR = oaVec.x + \"|\" + oaVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            fr = <number>this.IDATA.edgematch[f][2];\r\n            rot = <string>this.IDATA.edgematch[f][3];\r\n            if (rot && rot === \"A\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\r\n                    abVec.y = n + (g - i) * m1; //reversed for BA\r\n                    isoId = oaVec.x + \"|\" + oaVec.y;\r\n                    isoIdR = abVec.x + \"|\" + abVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this.vertices.length; i++) {\r\n                isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n                idx = f + \"|\" + isoId;\r\n                if (!(idx in vecToidx)) {\r\n                    vecToidx[idx] = indexCount++;\r\n                    if (vDist[isoId][0] > 2) {\r\n                        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n                    } else {\r\n                        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.closestTo = closestTo;\r\n        this.vecToidx = vecToidx;\r\n    }\r\n\r\n    public calcCoeffs() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        const thirdR3 = Math.sqrt(3) / 3;\r\n\r\n        const LSQD = m * m + n * n + m * n;\r\n\r\n        this.coau = (m + n) / LSQD;\r\n        this.cobu = -n / LSQD;\r\n        this.coav = (-thirdR3 * (m - n)) / LSQD;\r\n        this.cobv = (thirdR3 * (2 * m + n)) / LSQD;\r\n    }\r\n\r\n    public createInnerFacets() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        for (let y = 0; y < n + m + 1; y++) {\r\n            for (let x = this.min[y]; x < this.max[y] + 1; x++) {\r\n                if (x < this.max[y] && x < this.max[y + 1] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\r\n                }\r\n                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public edgeVecsABOB() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n\r\n        const B = new _IsoVector(-n, m + n);\r\n\r\n        for (let y = 1; y < m + n; y++) {\r\n            const point = new _IsoVector(this.min[y], y);\r\n            const prev = new _IsoVector(this.min[y - 1], y - 1);\r\n            const next = new _IsoVector(this.min[y + 1], y + 1);\r\n            const pointR = point.clone();\r\n            const prevR = prev.clone();\r\n            const nextR = next.clone();\r\n\r\n            pointR.rotate60About(B);\r\n            prevR.rotate60About(B);\r\n            nextR.rotate60About(B);\r\n\r\n            const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\r\n            const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\r\n            const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\r\n\r\n            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\r\n                if (pointR.x !== maxPrev.x) {\r\n                    // type2\r\n                    //up\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\r\n                } else if (pointR.y === nextR.y) {\r\n                    // type1\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 1]);\r\n                    this.isoVecsABOB.push([point, maxPrev, next]);\r\n                } else {\r\n                    // type 0\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxPoint]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapABOBtoOBOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 0) {\r\n                    point.rotateNeg120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsOBOA.push(temp);\r\n        }\r\n    }\r\n\r\n    public mapABOBtoBAOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 1) {\r\n                    point.rotate120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsBAOA.push(temp);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public MapToFace(faceNb: number, geodesicData: PolyhedronData) {\r\n        const F = this.IDATA.face[faceNb];\r\n        const oidx = F[2];\r\n        const aidx = F[1];\r\n        const bidx = F[0];\r\n\r\n        const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\r\n        const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\r\n        const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\r\n\r\n        const OA = A.subtract(O);\r\n        const OB = B.subtract(O);\r\n\r\n        const x: Vector3 = OA.scale(this.coau).add(OB.scale(this.cobu));\r\n        const y: Vector3 = OA.scale(this.coav).add(OB.scale(this.cobv));\r\n\r\n        const mapped = [];\r\n\r\n        let idx: string;\r\n        let tempVec: Vector3 = TmpVectors.Vector3[0];\r\n        for (let i = 0; i < this.cartesian.length; i++) {\r\n            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\r\n            mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\r\n            idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n            geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\r\n        }\r\n    }\r\n\r\n    //statics\r\n    /**Creates a primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public build(m: number, n: number) {\r\n        const vertices: _IsoVector[] = [];\r\n\r\n        const O: _IsoVector = _IsoVector.Zero();\r\n        const A: _IsoVector = new _IsoVector(m, n);\r\n        const B: _IsoVector = new _IsoVector(-n, m + n);\r\n        vertices.push(O, A, B);\r\n\r\n        //max internal isoceles triangle vertices\r\n        for (let y = n; y < m + 1; y++) {\r\n            for (let x = 0; x < m + 1 - y; x++) {\r\n                vertices.push(new _IsoVector(x, y));\r\n            }\r\n        }\r\n\r\n        //shared vertices along edges when needed\r\n        if (n > 0) {\r\n            const g = Scalar.HCF(m, n);\r\n            const m1 = m / g;\r\n            const n1 = n / g;\r\n\r\n            for (let i = 1; i < g; i++) {\r\n                vertices.push(new _IsoVector(i * m1, i * n1)); //OA\r\n                vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\r\n                vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\r\n            }\r\n\r\n            //lower rows vertices and their rotations\r\n            const ratio = m / n;\r\n            for (let y = 1; y < n; y++) {\r\n                for (let x = 0; x < y * ratio; x++) {\r\n                    vertices.push(new _IsoVector(x, y));\r\n                    vertices.push(new _IsoVector(x, y).rotate120(m, n));\r\n                    vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\r\n                }\r\n            }\r\n        }\r\n        //order vertices by x and then y\r\n        vertices.sort((a, b) => {\r\n            return a.x - b.x;\r\n        });\r\n\r\n        vertices.sort((a, b) => {\r\n            return a.y - b.y;\r\n        });\r\n\r\n        const min = new Array<number>(m + n + 1);\r\n        const max = new Array<number>(m + n + 1);\r\n        for (let i = 0; i < min.length; i++) {\r\n            min[i] = Infinity;\r\n            max[i] = -Infinity;\r\n        }\r\n\r\n        let y: number = 0;\r\n        let x: number = 0;\r\n\r\n        const len: number = vertices.length;\r\n        for (let i = 0; i < len; i++) {\r\n            x = vertices[i].x;\r\n            y = vertices[i].y;\r\n            min[y] = Math.min(x, min[y]);\r\n            max[y] = Math.max(x, max[y]);\r\n        }\r\n\r\n        //calculates the distance of a vertex from a given primary vertex\r\n        const distFrom = (vert: _IsoVector, primVert: string) => {\r\n            const v = vert.clone();\r\n            if (primVert === \"A\") {\r\n                v.rotateNeg120(m, n);\r\n            }\r\n            if (primVert === \"B\") {\r\n                v.rotate120(m, n);\r\n            }\r\n            if (v.x < 0) {\r\n                return v.y;\r\n            }\r\n            return v.x + v.y;\r\n        };\r\n\r\n        const cartesian: Vector3[] = [];\r\n        const distFromO: number[] = [];\r\n        const distFromA: number[] = [];\r\n        const distFromB: number[] = [];\r\n        const vertByDist: { [key: string]: number[] } = {};\r\n        const vertData: number[][] = [];\r\n        let closest: number = -1;\r\n        let dist: number = -1;\r\n        for (let i = 0; i < len; i++) {\r\n            cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\r\n            distFromO[i] = distFrom(vertices[i], \"O\");\r\n            distFromA[i] = distFrom(vertices[i], \"A\");\r\n            distFromB[i] = distFrom(vertices[i], \"B\");\r\n\r\n            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\r\n                closest = 3;\r\n                dist = distFromO[i];\r\n            } else if (distFromO[i] === distFromA[i]) {\r\n                closest = 4;\r\n                dist = distFromO[i];\r\n            } else if (distFromA[i] === distFromB[i]) {\r\n                closest = 5;\r\n                dist = distFromA[i];\r\n            } else if (distFromB[i] === distFromO[i]) {\r\n                closest = 6;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\r\n                closest = 2;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\r\n                closest = 1;\r\n                dist = distFromA[i];\r\n            }\r\n            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\r\n                closest = 0;\r\n                dist = distFromB[i];\r\n            }\r\n            vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\r\n        }\r\n\r\n        vertData.sort((a, b) => {\r\n            return a[2] - b[2];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[1] - b[1];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        for (let v = 0; v < vertData.length; v++) {\r\n            vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\r\n        }\r\n\r\n        this.m = m;\r\n        this.n = n;\r\n        this.vertices = vertices;\r\n        this.vertByDist = vertByDist;\r\n        this.cartesian = cartesian;\r\n        this.min = min;\r\n        this.max = max;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/** Builds Polyhedron Data\r\n * @internal\r\n */\r\n\r\nexport class PolyhedronData {\r\n    public edgematch: (number | string)[][];\r\n\r\n    constructor(\r\n        public name: string,\r\n        public category: string,\r\n        public vertex: number[][],\r\n        public face: number[][]\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\r\n */\r\nexport class GeodesicData extends PolyhedronData {\r\n    /**\r\n     * @internal\r\n     */\r\n    public edgematch: (number | string)[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public adjacentFaces: number[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public sharedNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public poleNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public innerToData(face: number, primTri: _PrimaryIsoTriangle) {\r\n        for (let i = 0; i < primTri.innerFacets.length; i++) {\r\n            this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapABOBtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 0) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapOBOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapBAOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][2];\r\n        for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public orderData(primTri: _PrimaryIsoTriangle) {\r\n        const nearTo: number[][][] = [];\r\n        for (let i = 0; i < 13; i++) {\r\n            nearTo[i] = [];\r\n        }\r\n        const close: number[][] = primTri.closestTo;\r\n        for (let i = 0; i < close.length; i++) {\r\n            if (close[i][0] > -1) {\r\n                if (close[i][1] > 0) {\r\n                    nearTo[close[i][0]].push([i, close[i][1]]);\r\n                }\r\n            } else {\r\n                nearTo[12].push([i, close[i][0]]);\r\n            }\r\n        }\r\n\r\n        const near: number[] = [];\r\n        for (let i = 0; i < 12; i++) {\r\n            near[i] = i;\r\n        }\r\n        let nearIndex = 12;\r\n        for (let i = 0; i < 12; i++) {\r\n            nearTo[i].sort((a: number[], b: number[]) => {\r\n                return a[1] - b[1];\r\n            });\r\n            for (let j = 0; j < nearTo[i].length; j++) {\r\n                near[nearTo[i][j][0]] = nearIndex++;\r\n            }\r\n        }\r\n\r\n        for (let j = 0; j < nearTo[12].length; j++) {\r\n            near[nearTo[12][j][0]] = nearIndex++;\r\n        }\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].push(near[i]);\r\n        }\r\n\r\n        this.vertex.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].pop();\r\n        }\r\n\r\n        for (let i = 0; i < this.face.length; i++) {\r\n            for (let j = 0; j < this.face[i].length; j++) {\r\n                this.face[i][j] = near[this.face[i][j]];\r\n            }\r\n        }\r\n\r\n        this.sharedNodes = nearTo[12].length;\r\n        this.poleNodes = this.vertex.length - this.sharedNodes;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setOrder(m: number, faces: number[]) {\r\n        const adjVerts: number[] = [];\r\n        const dualFaces: number[] = [];\r\n        let face: number = <number>faces.pop();\r\n        dualFaces.push(face);\r\n        let index = this.face[face].indexOf(m);\r\n        index = (index + 2) % 3;\r\n        let v = this.face[face][index];\r\n        adjVerts.push(v);\r\n        let f = 0;\r\n        while (faces.length > 0) {\r\n            face = faces[f];\r\n            if (this.face[face].indexOf(v) > -1) {\r\n                // v is a vertex of face f\r\n                index = (this.face[face].indexOf(v) + 1) % 3;\r\n                v = this.face[face][index];\r\n                adjVerts.push(v);\r\n                dualFaces.push(face);\r\n                faces.splice(f, 1);\r\n                f = 0;\r\n            } else {\r\n                f++;\r\n            }\r\n        }\r\n        this.adjacentFaces.push(adjVerts);\r\n        return dualFaces;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public toGoldbergPolyhedronData(): PolyhedronData {\r\n        const goldbergPolyhedronData: PolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\r\n        goldbergPolyhedronData.name = \"GD dual\";\r\n        const verticesNb: number = this.vertex.length;\r\n        const map = new Array(verticesNb);\r\n        for (let v = 0; v < verticesNb; v++) {\r\n            map[v] = [];\r\n        }\r\n        for (let f = 0; f < this.face.length; f++) {\r\n            for (let i = 0; i < 3; i++) {\r\n                map[this.face[f][i]].push(f);\r\n            }\r\n        }\r\n        let cx = 0;\r\n        let cy = 0;\r\n        let cz = 0;\r\n        let face = [];\r\n        let vertex = [];\r\n        this.adjacentFaces = [];\r\n        for (let m = 0; m < map.length; m++) {\r\n            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\r\n            map[m].forEach((el: number) => {\r\n                cx = 0;\r\n                cy = 0;\r\n                cz = 0;\r\n                face = this.face[el];\r\n                for (let i = 0; i < 3; i++) {\r\n                    vertex = this.vertex[face[i]];\r\n                    cx += vertex[0];\r\n                    cy += vertex[1];\r\n                    cz += vertex[2];\r\n                }\r\n                goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\r\n            });\r\n        }\r\n        return goldbergPolyhedronData;\r\n    }\r\n\r\n    //statics\r\n    /**Builds the data for a Geodesic Polyhedron from a primary triangle\r\n     * @param primTri the primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public static BuildGeodesicData(primTri: _PrimaryIsoTriangle) {\r\n        const geodesicData = new GeodesicData(\r\n            \"Geodesic-m-n\",\r\n            \"Geodesic\",\r\n            [\r\n                [0, PHI, -1],\r\n                [-PHI, 1, 0],\r\n                [-1, 0, -PHI],\r\n                [1, 0, -PHI],\r\n                [PHI, 1, 0],\r\n                [0, PHI, 1],\r\n                [-1, 0, PHI],\r\n                [-PHI, -1, 0],\r\n                [0, -PHI, -1],\r\n                [PHI, -1, 0],\r\n                [1, 0, PHI],\r\n                [0, -PHI, 1],\r\n            ],\r\n            []\r\n        );\r\n\r\n        primTri.setIndices();\r\n        primTri.calcCoeffs();\r\n        primTri.createInnerFacets();\r\n        primTri.edgeVecsABOB();\r\n        primTri.mapABOBtoOBOA();\r\n        primTri.mapABOBtoBAOA();\r\n\r\n        for (let f = 0; f < primTri.IDATA.face.length; f++) {\r\n            primTri.MapToFace(f, geodesicData);\r\n            geodesicData.innerToData(f, primTri);\r\n            if (primTri.IDATA.edgematch[f][1] === \"B\") {\r\n                geodesicData.mapABOBtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][1] === \"O\") {\r\n                geodesicData.mapOBOAtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][3] === \"A\") {\r\n                geodesicData.mapBAOAtoDATA(f, primTri);\r\n            }\r\n        }\r\n\r\n        geodesicData.orderData(primTri);\r\n        const radius = 1;\r\n        geodesicData.vertex = geodesicData.vertex.map(function (el) {\r\n            const a = el[0];\r\n            const b = el[1];\r\n            const c = el[2];\r\n            const d = Math.sqrt(a * a + b * b + c * c);\r\n            el[0] *= radius / d;\r\n            el[1] *= radius / d;\r\n            el[2] *= radius / d;\r\n            return el;\r\n        });\r\n\r\n        return geodesicData;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { CreatePolyhedron } from \"./polyhedronBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\n\r\n/**\r\n * Creates the Mesh for a Geodesic Polyhedron\r\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/geodesic_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * m number of horizontal steps along an isogrid\r\n * * n number of angled steps along an isogrid\r\n * * size the size of the Geodesic, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.n\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.m\r\n * @param scene defines the hosting scene\r\n * @returns Geodesic mesh\r\n */\r\nexport function CreateGeodesic(\r\n    name: string,\r\n    options: {\r\n        m?: number;\r\n        n?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n\r\n    const geoOptions: object = {\r\n        custom: geodesicData,\r\n        size: options.size,\r\n        sizeX: options.sizeX,\r\n        sizeY: options.sizeY,\r\n        sizeZ: options.sizeZ,\r\n        faceUV: options.faceUV,\r\n        faceColors: options.faceColors,\r\n        flat: options.flat,\r\n        updatable: options.updatable,\r\n        sideOrientation: options.sideOrientation,\r\n        frontUVs: options.frontUVs,\r\n        backUVs: options.backUVs,\r\n    };\r\n    const geodesic = CreatePolyhedron(name, geoOptions, scene);\r\n\r\n    return geodesic;\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { PolyhedronData } from \"../geodesicMesh\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\nimport { GoldbergMesh } from \"../goldbergMesh\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Defines the set of data required to create goldberg vertex data.\r\n */\r\nexport type GoldbergVertexDataOption = {\r\n    /**\r\n     * the size of the Goldberg, optional default 1\r\n     */\r\n    size?: number;\r\n    /**\r\n     * allows stretching in the x direction, optional, default size\r\n     */\r\n    sizeX?: number;\r\n    /**\r\n     * allows stretching in the y direction, optional, default size\r\n     */\r\n    sizeY?: number;\r\n    /**\r\n     * allows stretching in the z direction, optional, default size\r\n     */\r\n    sizeZ?: number;\r\n    /**\r\n     * optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     */\r\n    sideOrientation?: number;\r\n};\r\n\r\n/**\r\n * Defines the set of data required to create a goldberg mesh.\r\n */\r\nexport type GoldbergCreationOption = {\r\n    /**\r\n     * number of horizontal steps along an isogrid\r\n     */\r\n    m?: number;\r\n    /**\r\n     * number of angled steps along an isogrid\r\n     */\r\n    n?: number;\r\n    /**\r\n     * defines if the mesh must be flagged as updatable\r\n     */\r\n    updatable?: boolean;\r\n} & GoldbergVertexDataOption;\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\r\n * @returns GoldbergSphere mesh\r\n */\r\nexport function CreateGoldbergVertexData(options: GoldbergVertexDataOption, goldbergData: PolyhedronData): VertexData {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    let minX = Infinity;\r\n    let maxX = -Infinity;\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    for (let v = 0; v < goldbergData.vertex.length; v++) {\r\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\r\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\r\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\r\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\r\n    }\r\n\r\n    let index: number = 0;\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        for (let v = 0; v < verts.length; v++) {\r\n            normals.push(norm.x, norm.y, norm.z);\r\n            const pdata = goldbergData.vertex[verts[v]];\r\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\r\n            const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\r\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\r\n        }\r\n        for (let v = 0; v < verts.length - 2; v++) {\r\n            indices.push(index, index + v + 2, index + v + 1);\r\n        }\r\n        index += verts.length;\r\n    }\r\n\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param scene defines the hosting scene\r\n * @returns Goldberg mesh\r\n */\r\nexport function CreateGoldberg(name: string, options: GoldbergCreationOption, scene: Nullable<Scene> = null): GoldbergMesh {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n    const goldbergData = geodesicData.toGoldbergPolyhedronData();\r\n\r\n    const goldberg = new GoldbergMesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateGoldbergVertexData(options, goldbergData);\r\n\r\n    vertexData.applyToMesh(goldberg, options.updatable);\r\n\r\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\r\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\r\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\r\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\r\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\r\n    for (let f = 0; f < geodesicData.vertex.length; f++) {\r\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\r\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\r\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\r\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\r\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\r\n    }\r\n\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        const z = Vector3.Cross(ca, norm).normalize();\r\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\r\n        goldberg.goldbergData.faceYaxis.push(norm);\r\n        goldberg.goldbergData.faceZaxis.push(z);\r\n    }\r\n\r\n    return goldberg;\r\n}\r\n", "import type { Color4 } from \"../../Maths/math.color\";\r\nimport { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { TransformNode } from \"../transformNode\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /** Create a bezier curve from the virtual cursor to a given coordinate */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\n/**\r\n * Creates shape paths from a text and font\r\n * @param text the text\r\n * @param size size of the font\r\n * @param resolution resolution of the font\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @returns array of ShapePath objects\r\n */\r\nexport function CreateTextShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        perLetterFaceUV?: (letterIndex: number) => Vector4[];\r\n        perLetterFaceColors?: (letterIndex: number) => Color4[];\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    let letterIndex = 0;\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // There is at least a hole but it was unaffected\r\n            if (!holeVectors.length && holes.length) {\r\n                for (const hole of holes) {\r\n                    const points = hole.getPoints();\r\n                    const holePoints: Vector3[] = [];\r\n                    for (const point of points) {\r\n                        holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                    }\r\n                    holeVectors.push(holePoints);\r\n                }\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\r\n                    faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene,\r\n                earcutInjection\r\n            );\r\n            meshes.push(mesh);\r\n            letterIndex++;\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to desired center / bottom / center position\r\n        const bbox = newMesh.getBoundingInfo().boundingBox;\r\n        newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2; // Mid X\r\n        newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2; // Mid Z as it will rotate\r\n        newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z; // Bottom Y as it will rotate\r\n        newMesh.name = name;\r\n\r\n        // Rotate 90° Up\r\n        const pivot = new TransformNode(\"pivot\", scene);\r\n        pivot.rotation.x = -Math.PI / 2;\r\n        newMesh.parent = pivot;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n\r\n        // Remove the pivot\r\n        newMesh.parent = null;\r\n        pivot.dispose();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { CreateRibbon } from \"./Builders/ribbonBuilder\";\r\nimport { CreateDisc } from \"./Builders/discBuilder\";\r\nimport { CreateBox } from \"./Builders/boxBuilder\";\r\nimport { CreateTiledBox } from \"./Builders/tiledBoxBuilder\";\r\nimport { CreateSphere } from \"./Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"./Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"./Builders/torusBuilder\";\r\nimport { CreateTorusKnot } from \"./Builders/torusKnotBuilder\";\r\nimport { CreateDashedLines, CreateLineSystem, CreateLines } from \"./Builders/linesBuilder\";\r\nimport { CreatePolygon, ExtrudePolygon } from \"./Builders/polygonBuilder\";\r\nimport { ExtrudeShape, ExtrudeShapeCustom } from \"./Builders/shapeBuilder\";\r\nimport { CreateLathe } from \"./Builders/latheBuilder\";\r\nimport { CreatePlane } from \"./Builders/planeBuilder\";\r\nimport { CreateTiledPlane } from \"./Builders/tiledPlaneBuilder\";\r\nimport { CreateGround, CreateGroundFromHeightMap, CreateTiledGround } from \"./Builders/groundBuilder\";\r\nimport { CreateTube } from \"./Builders/tubeBuilder\";\r\nimport { CreatePolyhedron } from \"./Builders/polyhedronBuilder\";\r\nimport { CreateIcoSphere } from \"./Builders/icoSphereBuilder\";\r\nimport { CreateDecal } from \"./Builders/decalBuilder\";\r\nimport { CreateCapsule } from \"./Builders/capsuleBuilder\";\r\nimport { CreateGeodesic } from \"./Builders/geodesicBuilder\";\r\nimport { CreateGoldberg } from \"./Builders/goldbergBuilder\";\r\nimport { CreateText } from \"./Builders/textBuilder\";\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport const MeshBuilder = {\r\n    CreateBox,\r\n    CreateTiledBox,\r\n    CreateSphere,\r\n    CreateDisc,\r\n    CreateIcoSphere,\r\n    CreateRibbon,\r\n    CreateCylinder,\r\n    CreateTorus,\r\n    CreateTorusKnot,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n    CreateDashedLines,\r\n    ExtrudeShape,\r\n    ExtrudeShapeCustom,\r\n    CreateLathe,\r\n    CreateTiledPlane,\r\n    CreatePlane,\r\n    CreateGround,\r\n    CreateTiledGround,\r\n    CreateGroundFromHeightMap,\r\n    CreatePolygon,\r\n    ExtrudePolygon,\r\n    CreateTube,\r\n    CreatePolyhedron,\r\n    CreateGeodesic,\r\n    CreateGoldberg,\r\n    CreateDecal,\r\n    CreateCapsule,\r\n    CreateText,\r\n};\r\n", "import type { IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AsyncLoop } from \"../Misc/tools\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\n/**\r\n * A simplifier interface for future simplification implementations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport interface ISimplifier {\r\n    /**\r\n     * Simplification of a given mesh according to the given settings.\r\n     * Since this requires computation, it is assumed that the function runs async.\r\n     * @param settings The settings of the simplification, including quality and distance\r\n     * @param successCallback A callback that will be called after the mesh was simplified.\r\n     * @param errorCallback in case of an error, this callback will be called. optional.\r\n     */\r\n    simplify(settings: ISimplificationSettings, successCallback: (simplifiedMeshes: Mesh) => void, errorCallback?: () => void): void;\r\n}\r\n\r\n/**\r\n * Expected simplification settings.\r\n * Quality should be between 0 and 1 (1 being 100%, 0 being 0%)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport interface ISimplificationSettings {\r\n    /**\r\n     * Gets or sets the expected quality\r\n     */\r\n    quality: number;\r\n    /**\r\n     * Gets or sets the distance when this optimized version should be used\r\n     */\r\n    distance: number;\r\n    /**\r\n     * Gets an already optimized mesh\r\n     */\r\n    optimizeMesh?: boolean | undefined;\r\n}\r\n\r\n/**\r\n * Class used to specify simplification options\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class SimplificationSettings implements ISimplificationSettings {\r\n    /**\r\n     * Creates a SimplificationSettings\r\n     * @param quality expected quality\r\n     * @param distance distance when this optimized version should be used\r\n     * @param optimizeMesh already optimized mesh\r\n     */\r\n    constructor(\r\n        /** expected quality */\r\n        public quality: number,\r\n        /** distance when this optimized version should be used */\r\n        public distance: number,\r\n        /** already optimized mesh  */\r\n        public optimizeMesh?: boolean\r\n    ) {}\r\n}\r\n\r\n/**\r\n * Interface used to define a simplification task\r\n */\r\nexport interface ISimplificationTask {\r\n    /**\r\n     * Array of settings\r\n     */\r\n    settings: Array<ISimplificationSettings>;\r\n    /**\r\n     * Simplification type\r\n     */\r\n    simplificationType: SimplificationType;\r\n    /**\r\n     * Mesh to simplify\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * Callback called on success\r\n     */\r\n    successCallback?: () => void;\r\n    /**\r\n     * Defines if parallel processing can be used\r\n     */\r\n    parallelProcessing: boolean;\r\n}\r\n\r\n/**\r\n * Queue used to order the simplification tasks\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class SimplificationQueue {\r\n    private _simplificationArray: Array<ISimplificationTask>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the process is still running\r\n     */\r\n    public running: boolean;\r\n\r\n    /**\r\n     * Creates a new queue\r\n     */\r\n    constructor() {\r\n        this.running = false;\r\n        this._simplificationArray = [];\r\n    }\r\n\r\n    /**\r\n     * Adds a new simplification task\r\n     * @param task defines a task to add\r\n     */\r\n    public addTask(task: ISimplificationTask) {\r\n        this._simplificationArray.push(task);\r\n    }\r\n\r\n    /**\r\n     * Execute next task\r\n     */\r\n    public executeNext() {\r\n        const task = this._simplificationArray.pop();\r\n        if (task) {\r\n            this.running = true;\r\n            this.runSimplification(task);\r\n        } else {\r\n            this.running = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a simplification task\r\n     * @param task defines the task to run\r\n     */\r\n    public runSimplification(task: ISimplificationTask) {\r\n        if (task.parallelProcessing) {\r\n            //parallel simplifier\r\n            task.settings.forEach((setting) => {\r\n                const simplifier = this._getSimplifier(task);\r\n                simplifier.simplify(setting, (newMesh) => {\r\n                    if (setting.distance !== undefined) {\r\n                        task.mesh.addLODLevel(setting.distance, newMesh);\r\n                    }\r\n                    newMesh.isVisible = true;\r\n                    //check if it is the last\r\n                    if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\r\n                        //all done, run the success callback.\r\n                        task.successCallback();\r\n                    }\r\n                    this.executeNext();\r\n                });\r\n            });\r\n        } else {\r\n            //single simplifier.\r\n            const simplifier = this._getSimplifier(task);\r\n\r\n            const runDecimation = (setting: ISimplificationSettings, callback: () => void) => {\r\n                simplifier.simplify(setting, (newMesh) => {\r\n                    if (setting.distance !== undefined) {\r\n                        task.mesh.addLODLevel(setting.distance, newMesh);\r\n                    }\r\n                    newMesh.isVisible = true;\r\n                    //run the next quality level\r\n                    callback();\r\n                });\r\n            };\r\n\r\n            AsyncLoop.Run(\r\n                task.settings.length,\r\n                (loop: AsyncLoop) => {\r\n                    runDecimation(task.settings[loop.index], () => {\r\n                        loop.executeNext();\r\n                    });\r\n                },\r\n                () => {\r\n                    //execution ended, run the success callback.\r\n                    if (task.successCallback) {\r\n                        task.successCallback();\r\n                    }\r\n                    this.executeNext();\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getSimplifier(task: ISimplificationTask): ISimplifier {\r\n        switch (task.simplificationType) {\r\n            case SimplificationType.QUADRATIC:\r\n            default:\r\n                return new QuadraticErrorSimplification(task.mesh);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The implemented types of simplification\r\n * At the moment only Quadratic Error Decimation is implemented\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport enum SimplificationType {\r\n    /** Quadratic error decimation */\r\n    QUADRATIC,\r\n}\r\n\r\nclass DecimationTriangle {\r\n    public normal: Vector3;\r\n    public error: Array<number>;\r\n    public deleted: boolean;\r\n    public isDirty: boolean;\r\n    public borderFactor: number;\r\n    public deletePending: boolean;\r\n\r\n    public originalOffset: number;\r\n\r\n    constructor(public _vertices: Array<DecimationVertex>) {\r\n        this.error = new Array<number>(4);\r\n        this.deleted = false;\r\n        this.isDirty = false;\r\n        this.deletePending = false;\r\n        this.borderFactor = 0;\r\n    }\r\n}\r\n\r\nclass DecimationVertex {\r\n    public q: QuadraticMatrix;\r\n    public isBorder: boolean;\r\n\r\n    public triangleStart: number;\r\n    public triangleCount: number;\r\n\r\n    public originalOffsets: Array<number>;\r\n\r\n    constructor(\r\n        public position: Vector3,\r\n        public id: number\r\n    ) {\r\n        this.isBorder = true;\r\n        this.q = new QuadraticMatrix();\r\n        this.triangleCount = 0;\r\n        this.triangleStart = 0;\r\n        this.originalOffsets = [];\r\n    }\r\n\r\n    public updatePosition(newPosition: Vector3) {\r\n        this.position.copyFrom(newPosition);\r\n    }\r\n}\r\n\r\nclass QuadraticMatrix {\r\n    public data: Array<number>;\r\n\r\n    constructor(data?: Array<number>) {\r\n        this.data = new Array(10);\r\n        for (let i = 0; i < 10; ++i) {\r\n            if (data && data[i]) {\r\n                this.data[i] = data[i];\r\n            } else {\r\n                this.data[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public det(a11: number, a12: number, a13: number, a21: number, a22: number, a23: number, a31: number, a32: number, a33: number): number {\r\n        const det =\r\n            this.data[a11] * this.data[a22] * this.data[a33] +\r\n            this.data[a13] * this.data[a21] * this.data[a32] +\r\n            this.data[a12] * this.data[a23] * this.data[a31] -\r\n            this.data[a13] * this.data[a22] * this.data[a31] -\r\n            this.data[a11] * this.data[a23] * this.data[a32] -\r\n            this.data[a12] * this.data[a21] * this.data[a33];\r\n        return det;\r\n    }\r\n\r\n    public addInPlace(matrix: QuadraticMatrix) {\r\n        for (let i = 0; i < 10; ++i) {\r\n            this.data[i] += matrix.data[i];\r\n        }\r\n    }\r\n\r\n    public addArrayInPlace(data: Array<number>) {\r\n        for (let i = 0; i < 10; ++i) {\r\n            this.data[i] += data[i];\r\n        }\r\n    }\r\n\r\n    public add(matrix: QuadraticMatrix): QuadraticMatrix {\r\n        const m = new QuadraticMatrix();\r\n        for (let i = 0; i < 10; ++i) {\r\n            m.data[i] = this.data[i] + matrix.data[i];\r\n        }\r\n        return m;\r\n    }\r\n\r\n    public static FromData(a: number, b: number, c: number, d: number): QuadraticMatrix {\r\n        return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\r\n    }\r\n\r\n    //returning an array to avoid garbage collection\r\n    public static DataFromNumbers(a: number, b: number, c: number, d: number) {\r\n        return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\r\n    }\r\n}\r\n\r\nclass Reference {\r\n    constructor(\r\n        public vertexId: number,\r\n        public triangleId: number\r\n    ) {}\r\n}\r\n\r\n/**\r\n * An implementation of the Quadratic Error simplification algorithm.\r\n * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\r\n * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\r\n * @author RaananW\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class QuadraticErrorSimplification implements ISimplifier {\r\n    private _triangles: Array<DecimationTriangle>;\r\n    private _vertices: Array<DecimationVertex>;\r\n    private _references: Array<Reference>;\r\n\r\n    private _reconstructedMesh: Mesh;\r\n\r\n    /** Gets or sets the number pf sync iterations */\r\n    public syncIterations = 5000;\r\n\r\n    /** Gets or sets the aggressiveness of the simplifier */\r\n    public aggressiveness: number;\r\n\r\n    /** Gets or sets the number of allowed iterations for decimation */\r\n    public decimationIterations: number;\r\n\r\n    /** Gets or sets the espilon to use for bounding box computation */\r\n    public boundingBoxEpsilon: number;\r\n\r\n    /**\r\n     * Creates a new QuadraticErrorSimplification\r\n     * @param _mesh defines the target mesh\r\n     */\r\n    constructor(private _mesh: Mesh) {\r\n        this.aggressiveness = 7;\r\n        this.decimationIterations = 100;\r\n        this.boundingBoxEpsilon = Epsilon;\r\n    }\r\n\r\n    /**\r\n     * Simplification of a given mesh according to the given settings.\r\n     * Since this requires computation, it is assumed that the function runs async.\r\n     * @param settings The settings of the simplification, including quality and distance\r\n     * @param successCallback A callback that will be called after the mesh was simplified.\r\n     */\r\n    public simplify(settings: ISimplificationSettings, successCallback: (simplifiedMesh: Mesh) => void) {\r\n        this._initDecimatedMesh();\r\n        //iterating through the submeshes array, one after the other.\r\n        AsyncLoop.Run(\r\n            this._mesh.subMeshes.length,\r\n            (loop: AsyncLoop) => {\r\n                this._initWithMesh(\r\n                    loop.index,\r\n                    () => {\r\n                        this._runDecimation(settings, loop.index, () => {\r\n                            loop.executeNext();\r\n                        });\r\n                    },\r\n                    settings.optimizeMesh\r\n                );\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    successCallback(this._reconstructedMesh);\r\n                }, 0);\r\n            }\r\n        );\r\n    }\r\n\r\n    private _runDecimation(settings: ISimplificationSettings, submeshIndex: number, successCallback: () => void) {\r\n        const targetCount = ~~(this._triangles.length * settings.quality);\r\n        let deletedTriangles = 0;\r\n\r\n        const triangleCount = this._triangles.length;\r\n\r\n        const iterationFunction = (iteration: number, callback: () => void) => {\r\n            setTimeout(() => {\r\n                if (iteration % 5 === 0) {\r\n                    this._updateMesh(iteration === 0);\r\n                }\r\n\r\n                for (let i = 0; i < this._triangles.length; ++i) {\r\n                    this._triangles[i].isDirty = false;\r\n                }\r\n\r\n                const threshold = 0.000000001 * Math.pow(iteration + 3, this.aggressiveness);\r\n\r\n                const trianglesIterator = (i: number) => {\r\n                    const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);\r\n                    const t = this._triangles[tIdx];\r\n                    if (!t) {\r\n                        return;\r\n                    }\r\n                    if (t.error[3] > threshold || t.deleted || t.isDirty) {\r\n                        return;\r\n                    }\r\n                    for (let j = 0; j < 3; ++j) {\r\n                        if (t.error[j] < threshold) {\r\n                            const deleted0: Array<boolean> = [];\r\n                            const deleted1: Array<boolean> = [];\r\n\r\n                            const v0 = t._vertices[j];\r\n                            const v1 = t._vertices[(j + 1) % 3];\r\n\r\n                            if (v0.isBorder || v1.isBorder) {\r\n                                continue;\r\n                            }\r\n\r\n                            const p = Vector3.Zero();\r\n                            // var n = Vector3.Zero();\r\n                            // var uv = Vector2.Zero();\r\n                            // var color = new Color4(0, 0, 0, 1);\r\n\r\n                            this._calculateError(v0, v1, p);\r\n\r\n                            const delTr: DecimationTriangle[] = [];\r\n\r\n                            if (this._isFlipped(v0, v1, p, deleted0, delTr)) {\r\n                                continue;\r\n                            }\r\n                            if (this._isFlipped(v1, v0, p, deleted1, delTr)) {\r\n                                continue;\r\n                            }\r\n\r\n                            if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {\r\n                                continue;\r\n                            }\r\n\r\n                            const uniqueArray: DecimationTriangle[] = [];\r\n                            delTr.forEach((deletedT) => {\r\n                                if (uniqueArray.indexOf(deletedT) === -1) {\r\n                                    deletedT.deletePending = true;\r\n                                    uniqueArray.push(deletedT);\r\n                                }\r\n                            });\r\n\r\n                            if (uniqueArray.length % 2 !== 0) {\r\n                                continue;\r\n                            }\r\n\r\n                            v0.q = v1.q.add(v0.q);\r\n\r\n                            v0.updatePosition(p);\r\n\r\n                            const tStart = this._references.length;\r\n\r\n                            deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);\r\n                            deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);\r\n\r\n                            const tCount = this._references.length - tStart;\r\n\r\n                            if (tCount <= v0.triangleCount) {\r\n                                if (tCount) {\r\n                                    for (let c = 0; c < tCount; c++) {\r\n                                        this._references[v0.triangleStart + c] = this._references[tStart + c];\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                v0.triangleStart = tStart;\r\n                            }\r\n\r\n                            v0.triangleCount = tCount;\r\n                            break;\r\n                        }\r\n                    }\r\n                };\r\n                AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, () => {\r\n                    return triangleCount - deletedTriangles <= targetCount;\r\n                });\r\n            }, 0);\r\n        };\r\n\r\n        AsyncLoop.Run(\r\n            this.decimationIterations,\r\n            (loop: AsyncLoop) => {\r\n                if (triangleCount - deletedTriangles <= targetCount) {\r\n                    loop.breakLoop();\r\n                } else {\r\n                    iterationFunction(loop.index, () => {\r\n                        loop.executeNext();\r\n                    });\r\n                }\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    //reconstruct this part of the mesh\r\n                    this._reconstructMesh(submeshIndex);\r\n                    successCallback();\r\n                }, 0);\r\n            }\r\n        );\r\n    }\r\n\r\n    private _initWithMesh(submeshIndex: number, callback: Function, optimizeMesh?: boolean) {\r\n        this._vertices = [];\r\n        this._triangles = [];\r\n\r\n        const positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        const indices = this._mesh.getIndices();\r\n        const submesh = this._mesh.subMeshes[submeshIndex];\r\n\r\n        const findInVertices = (positionToSearch: Vector3) => {\r\n            if (optimizeMesh) {\r\n                for (let ii = 0; ii < this._vertices.length; ++ii) {\r\n                    if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {\r\n                        return this._vertices[ii];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        const vertexReferences: Array<number> = [];\r\n\r\n        const vertexInit = (i: number) => {\r\n            if (!positionData) {\r\n                return;\r\n            }\r\n\r\n            const offset = i + submesh.verticesStart;\r\n            const position = Vector3.FromArray(positionData, offset * 3);\r\n\r\n            const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);\r\n            vertex.originalOffsets.push(offset);\r\n            if (vertex.id === this._vertices.length) {\r\n                this._vertices.push(vertex);\r\n            }\r\n            vertexReferences.push(vertex.id);\r\n        };\r\n        //var totalVertices = mesh.getTotalVertices();\r\n        const totalVertices = submesh.verticesCount;\r\n        AsyncLoop.SyncAsyncForLoop(totalVertices, (this.syncIterations / 4) >> 0, vertexInit, () => {\r\n            const indicesInit = (i: number) => {\r\n                if (!indices) {\r\n                    return;\r\n                }\r\n\r\n                const offset = submesh.indexStart / 3 + i;\r\n                const pos = offset * 3;\r\n                const i0 = indices[pos + 0];\r\n                const i1 = indices[pos + 1];\r\n                const i2 = indices[pos + 2];\r\n                const v0: DecimationVertex = this._vertices[vertexReferences[i0 - submesh.verticesStart]];\r\n                const v1: DecimationVertex = this._vertices[vertexReferences[i1 - submesh.verticesStart]];\r\n                const v2: DecimationVertex = this._vertices[vertexReferences[i2 - submesh.verticesStart]];\r\n                const triangle = new DecimationTriangle([v0, v1, v2]);\r\n                triangle.originalOffset = pos;\r\n                this._triangles.push(triangle);\r\n            };\r\n            AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, () => {\r\n                this._init(callback);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _init(callback: Function) {\r\n        const triangleInit1 = (i: number) => {\r\n            const t = this._triangles[i];\r\n            t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();\r\n            for (let j = 0; j < 3; j++) {\r\n                t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));\r\n            }\r\n        };\r\n        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, () => {\r\n            const triangleInit2 = (i: number) => {\r\n                const t = this._triangles[i];\r\n                for (let j = 0; j < 3; ++j) {\r\n                    t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);\r\n                }\r\n                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\r\n            };\r\n            AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, () => {\r\n                callback();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _reconstructMesh(submeshIndex: number) {\r\n        const newTriangles: Array<DecimationTriangle> = [];\r\n        let i: number;\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleCount = 0;\r\n        }\r\n        let t: DecimationTriangle;\r\n        let j: number;\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            if (!this._triangles[i].deleted) {\r\n                t = this._triangles[i];\r\n                for (j = 0; j < 3; ++j) {\r\n                    t._vertices[j].triangleCount = 1;\r\n                }\r\n                newTriangles.push(t);\r\n            }\r\n        }\r\n\r\n        const newPositionData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || []);\r\n        const newNormalData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || []);\r\n        const newUVsData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || []);\r\n        const newColorsData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || []);\r\n\r\n        const normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        let vertexCount = 0;\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            const vertex = this._vertices[i];\r\n            vertex.id = vertexCount;\r\n            if (vertex.triangleCount) {\r\n                vertex.originalOffsets.forEach((originalOffset) => {\r\n                    newPositionData.push(vertex.position.x);\r\n                    newPositionData.push(vertex.position.y);\r\n                    newPositionData.push(vertex.position.z);\r\n\r\n                    if (normalData && normalData.length) {\r\n                        newNormalData.push(normalData[originalOffset * 3]);\r\n                        newNormalData.push(normalData[originalOffset * 3 + 1]);\r\n                        newNormalData.push(normalData[originalOffset * 3 + 2]);\r\n                    }\r\n                    if (uvs && uvs.length) {\r\n                        newUVsData.push(uvs[originalOffset * 2]);\r\n                        newUVsData.push(uvs[originalOffset * 2 + 1]);\r\n                    }\r\n                    if (colorsData && colorsData.length) {\r\n                        newColorsData.push(colorsData[originalOffset * 4]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 1]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 2]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 3]);\r\n                    }\r\n                    ++vertexCount;\r\n                });\r\n            }\r\n        }\r\n\r\n        const startingIndex = this._reconstructedMesh.getTotalIndices();\r\n        const startingVertex = this._reconstructedMesh.getTotalVertices();\r\n\r\n        const submeshesArray = this._reconstructedMesh.subMeshes;\r\n        this._reconstructedMesh.subMeshes = [];\r\n\r\n        const newIndicesArray: number[] = <number[]>this._reconstructedMesh.getIndices(); //[];\r\n        const originalIndices = <IndicesArray>this._mesh.getIndices();\r\n        for (i = 0; i < newTriangles.length; ++i) {\r\n            t = newTriangles[i]; //now get the new referencing point for each vertex\r\n            [0, 1, 2].forEach((idx) => {\r\n                const id = originalIndices[t.originalOffset + idx];\r\n                let offset = t._vertices[idx].originalOffsets.indexOf(id);\r\n                if (offset < 0) {\r\n                    offset = 0;\r\n                }\r\n                newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);\r\n            });\r\n        }\r\n\r\n        //overwriting the old vertex buffers and indices.\r\n\r\n        this._reconstructedMesh.setIndices(newIndicesArray);\r\n        this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);\r\n        if (newNormalData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);\r\n        }\r\n        if (newUVsData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);\r\n        }\r\n        if (newColorsData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);\r\n        }\r\n\r\n        //create submesh\r\n        const originalSubmesh = this._mesh.subMeshes[submeshIndex];\r\n        if (submeshIndex > 0) {\r\n            this._reconstructedMesh.subMeshes = [];\r\n            submeshesArray.forEach((submesh) => {\r\n                SubMesh.AddToMesh(\r\n                    submesh.materialIndex,\r\n                    submesh.verticesStart,\r\n                    submesh.verticesCount,\r\n                    /* 0, newPositionData.length/3, */ submesh.indexStart,\r\n                    submesh.indexCount,\r\n                    submesh.getMesh()\r\n                );\r\n            });\r\n            SubMesh.AddToMesh(\r\n                originalSubmesh.materialIndex,\r\n                startingVertex,\r\n                vertexCount,\r\n                /* 0, newPositionData.length / 3, */ startingIndex,\r\n                newTriangles.length * 3,\r\n                this._reconstructedMesh\r\n            );\r\n        }\r\n    }\r\n\r\n    private _initDecimatedMesh() {\r\n        this._reconstructedMesh = new Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\r\n        this._reconstructedMesh.material = this._mesh.material;\r\n        this._reconstructedMesh.parent = this._mesh.parent;\r\n        this._reconstructedMesh.isVisible = false;\r\n        this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\r\n    }\r\n\r\n    private _isFlipped(vertex1: DecimationVertex, vertex2: DecimationVertex, point: Vector3, deletedArray: Array<boolean>, delTr: Array<DecimationTriangle>): boolean {\r\n        for (let i = 0; i < vertex1.triangleCount; ++i) {\r\n            const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];\r\n            if (t.deleted) {\r\n                continue;\r\n            }\r\n\r\n            const s = this._references[vertex1.triangleStart + i].vertexId;\r\n\r\n            const v1 = t._vertices[(s + 1) % 3];\r\n            const v2 = t._vertices[(s + 2) % 3];\r\n\r\n            if (v1 === vertex2 || v2 === vertex2) {\r\n                deletedArray[i] = true;\r\n                delTr.push(t);\r\n                continue;\r\n            }\r\n\r\n            let d1 = v1.position.subtract(point);\r\n            d1 = d1.normalize();\r\n            let d2 = v2.position.subtract(point);\r\n            d2 = d2.normalize();\r\n            if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {\r\n                return true;\r\n            }\r\n            const normal = Vector3.Cross(d1, d2).normalize();\r\n            deletedArray[i] = false;\r\n            if (Vector3.Dot(normal, t.normal) < 0.2) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _updateTriangles(origVertex: DecimationVertex, vertex: DecimationVertex, deletedArray: Array<boolean>, deletedTriangles: number): number {\r\n        let newDeleted = deletedTriangles;\r\n        for (let i = 0; i < vertex.triangleCount; ++i) {\r\n            const ref = this._references[vertex.triangleStart + i];\r\n            const t = this._triangles[ref.triangleId];\r\n            if (t.deleted) {\r\n                continue;\r\n            }\r\n            if (deletedArray[i] && t.deletePending) {\r\n                t.deleted = true;\r\n                newDeleted++;\r\n                continue;\r\n            }\r\n            t._vertices[ref.vertexId] = origVertex;\r\n            t.isDirty = true;\r\n            t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;\r\n            t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;\r\n            t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;\r\n            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\r\n            this._references.push(ref);\r\n        }\r\n        return newDeleted;\r\n    }\r\n\r\n    private _identifyBorder() {\r\n        for (let i = 0; i < this._vertices.length; ++i) {\r\n            const vCount: Array<number> = [];\r\n            const vId: Array<number> = [];\r\n            const v = this._vertices[i];\r\n            let j: number;\r\n            for (j = 0; j < v.triangleCount; ++j) {\r\n                const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];\r\n                for (let ii = 0; ii < 3; ii++) {\r\n                    let ofs = 0;\r\n                    const vv = triangle._vertices[ii];\r\n                    while (ofs < vCount.length) {\r\n                        if (vId[ofs] === vv.id) {\r\n                            break;\r\n                        }\r\n                        ++ofs;\r\n                    }\r\n                    if (ofs === vCount.length) {\r\n                        vCount.push(1);\r\n                        vId.push(vv.id);\r\n                    } else {\r\n                        vCount[ofs]++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (j = 0; j < vCount.length; ++j) {\r\n                if (vCount[j] === 1) {\r\n                    this._vertices[vId[j]].isBorder = true;\r\n                } else {\r\n                    this._vertices[vId[j]].isBorder = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateMesh(identifyBorders: boolean = false) {\r\n        let i: number;\r\n        if (!identifyBorders) {\r\n            const newTrianglesVector: Array<DecimationTriangle> = [];\r\n            for (i = 0; i < this._triangles.length; ++i) {\r\n                if (!this._triangles[i].deleted) {\r\n                    newTrianglesVector.push(this._triangles[i]);\r\n                }\r\n            }\r\n            this._triangles = newTrianglesVector;\r\n        }\r\n\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleCount = 0;\r\n            this._vertices[i].triangleStart = 0;\r\n        }\r\n        let t: DecimationTriangle;\r\n        let j: number;\r\n        let v: DecimationVertex;\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            t = this._triangles[i];\r\n            for (j = 0; j < 3; ++j) {\r\n                v = t._vertices[j];\r\n                v.triangleCount++;\r\n            }\r\n        }\r\n\r\n        let tStart = 0;\r\n\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleStart = tStart;\r\n            tStart += this._vertices[i].triangleCount;\r\n            this._vertices[i].triangleCount = 0;\r\n        }\r\n\r\n        const newReferences: Array<Reference> = new Array(this._triangles.length * 3);\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            t = this._triangles[i];\r\n            for (j = 0; j < 3; ++j) {\r\n                v = t._vertices[j];\r\n                newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\r\n                v.triangleCount++;\r\n            }\r\n        }\r\n        this._references = newReferences;\r\n\r\n        if (identifyBorders) {\r\n            this._identifyBorder();\r\n        }\r\n    }\r\n\r\n    private _vertexError(q: QuadraticMatrix, point: Vector3): number {\r\n        const x = point.x;\r\n        const y = point.y;\r\n        const z = point.z;\r\n        return (\r\n            q.data[0] * x * x +\r\n            2 * q.data[1] * x * y +\r\n            2 * q.data[2] * x * z +\r\n            2 * q.data[3] * x +\r\n            q.data[4] * y * y +\r\n            2 * q.data[5] * y * z +\r\n            2 * q.data[6] * y +\r\n            q.data[7] * z * z +\r\n            2 * q.data[8] * z +\r\n            q.data[9]\r\n        );\r\n    }\r\n\r\n    private _calculateError(vertex1: DecimationVertex, vertex2: DecimationVertex, pointResult?: Vector3): number {\r\n        const q = vertex1.q.add(vertex2.q);\r\n        const border = vertex1.isBorder && vertex2.isBorder;\r\n        let error: number = 0;\r\n        const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\r\n\r\n        if (qDet !== 0 && !border) {\r\n            if (!pointResult) {\r\n                pointResult = Vector3.Zero();\r\n            }\r\n            pointResult.x = (-1 / qDet) * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);\r\n            pointResult.y = (1 / qDet) * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);\r\n            pointResult.z = (-1 / qDet) * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);\r\n            error = this._vertexError(q, pointResult);\r\n        } else {\r\n            const p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));\r\n            //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\r\n            const error1 = this._vertexError(q, vertex1.position);\r\n            const error2 = this._vertexError(q, vertex2.position);\r\n            const error3 = this._vertexError(q, p3);\r\n            error = Math.min(error1, error2, error3);\r\n            if (error === error1) {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(vertex1.position);\r\n                }\r\n            } else if (error === error2) {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(vertex2.position);\r\n                }\r\n            } else {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(p3);\r\n                }\r\n            }\r\n        }\r\n        return error;\r\n    }\r\n}\r\n", "import { Scene } from \"../scene\";\r\nimport { Mesh } from \"./mesh\";\r\nimport type { ISimplificationSettings } from \"./meshSimplification\";\r\nimport { SimplificationQueue, SimplificationType } from \"./meshSimplification\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _simplificationQueue: SimplificationQueue;\r\n\r\n        /**\r\n         * Gets or sets the simplification queue attached to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n         */\r\n        simplificationQueue: SimplificationQueue;\r\n    }\r\n}\r\nObject.defineProperty(Scene.prototype, \"simplificationQueue\", {\r\n    get: function (this: Scene) {\r\n        if (!this._simplificationQueue) {\r\n            this._simplificationQueue = new SimplificationQueue();\r\n            let component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE) as SimplicationQueueSceneComponent;\r\n            if (!component) {\r\n                component = new SimplicationQueueSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n        return this._simplificationQueue;\r\n    },\r\n    set: function (this: Scene, value: SimplificationQueue) {\r\n        this._simplificationQueue = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Meshes/mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Simplify the mesh according to the given array of settings.\r\n         * Function will return immediately and will simplify async\r\n         * @param settings a collection of simplification settings\r\n         * @param parallelProcessing should all levels calculate parallel or one after the other\r\n         * @param simplificationType the type of simplification to run\r\n         * @param successCallback optional success callback to be called after the simplification finished processing all settings\r\n         * @returns the current mesh\r\n         */\r\n        simplify(\r\n            settings: Array<ISimplificationSettings>,\r\n            parallelProcessing?: boolean,\r\n            simplificationType?: SimplificationType,\r\n            successCallback?: (mesh?: Mesh, submeshIndex?: number) => void\r\n        ): Mesh;\r\n    }\r\n}\r\n\r\nMesh.prototype.simplify = function (\r\n    settings: Array<ISimplificationSettings>,\r\n    parallelProcessing: boolean = true,\r\n    simplificationType: SimplificationType = SimplificationType.QUADRATIC,\r\n    successCallback?: (mesh?: Mesh, submeshIndex?: number) => void\r\n): Mesh {\r\n    this.getScene().simplificationQueue.addTask({\r\n        settings: settings,\r\n        parallelProcessing: parallelProcessing,\r\n        mesh: this,\r\n        simplificationType: simplificationType,\r\n        successCallback: successCallback,\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the simplification queue scene component responsible to help scheduling the various simplification task\r\n * created in a scene\r\n */\r\nexport class SimplicationQueueSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    private _beforeCameraUpdate(): void {\r\n        if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {\r\n            this.scene._simplificationQueue.executeNext();\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    export interface SubMesh {\r\n        /** @internal */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @internal */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n", "import { Mesh } from \"../mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CreateSphere } from \"../Builders/sphereBuilder\";\r\nimport { CreateDisc } from \"./discBuilder\";\r\n\r\n/**\r\n * Creates a hemisphere mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.sideOrientation\r\n * @param scene defines the hosting scene\r\n * @returns the hemisphere mesh\r\n */\r\nexport function CreateHemisphere(name: string, options: { segments?: number; diameter?: number; sideOrientation?: number } = {}, scene?: Scene): Mesh {\r\n    if (!options.diameter) {\r\n        options.diameter = 1;\r\n    }\r\n    if (!options.segments) {\r\n        options.segments = 16;\r\n    }\r\n\r\n    const halfSphere = CreateSphere(\"\", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);\r\n    const disc = CreateDisc(\"\", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);\r\n    disc.rotation.x = -Math.PI / 2;\r\n    disc.parent = halfSphere;\r\n\r\n    const merged = <Mesh>Mesh.MergeMeshes([disc, halfSphere], true);\r\n    merged.name = name;\r\n\r\n    return merged;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const HemisphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateHemisphere,\r\n};\r\n\r\n/**\r\n * Creates a hemispheric light\r\n * @param name\r\n * @param segments\r\n * @param diameter\r\n * @param scene\r\n */\r\nMesh.CreateHemisphere = (name: string, segments: number, diameter: number, scene?: Scene): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameter: diameter,\r\n    };\r\n\r\n    return CreateHemisphere(name, options, scene);\r\n};\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdDecodePixelShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.getEffect().executeWhenCompiled(() => {\r\n        passPostProcess.onApply = function (effect) {\r\n            effect.setTexture(\"textureSampler\", texture);\r\n        };\r\n\r\n        const internalTexture = rtt.renderTarget;\r\n\r\n        if (internalTexture) {\r\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n            engine.unBindFramebuffer(internalTexture);\r\n            rtt.disposeFramebufferObjects();\r\n            passPostProcess.dispose();\r\n\r\n            rtt.getInternalTexture()!.isReady = true;\r\n        }\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width as number, height: height as number },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.getEffect().executeWhenCompiled(() => {\r\n            // PP Render Pass\r\n            postProcess.onApply = (effect) => {\r\n                effect._bindTexture(\"textureSampler\", internalTexture);\r\n                effect.setFloat2(\"scale\", 1, 1);\r\n            };\r\n            scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n            // Cleanup\r\n            engine.restoreDefaultFramebuffer();\r\n            engine._releaseTexture(internalTexture);\r\n            if (postProcess) {\r\n                postProcess.dispose();\r\n            }\r\n\r\n            // Internal Swap\r\n            encodedTexture._swapAndDie(internalTexture);\r\n\r\n            // Ready to get rolling again.\r\n            internalTexture.type = type!;\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.isReady = true;\r\n\r\n            resolve(internalTexture);\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nconst ProcessAsync = async (texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> => {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.getEffect().executeWhenCompiled(() => {\r\n            resolve(0);\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setBool(\"gamma\", texture.gammaSpace);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the width of the result, which does not have to match the source texture width\r\n * @param height the height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width: number, height: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    if (!texture.isReady() && texture._texture) {\r\n        await new Promise((resolve, reject) => {\r\n            if (texture._texture === null) {\r\n                reject(0);\r\n                return;\r\n            }\r\n            texture._texture.onLoadedObservable.addOnce(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    }\r\n    return await ProcessAsync(texture, width, height, face, lod);\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            if (expandTexture) {\r\n                // Simply run through the decode PP.\r\n                const rgbdPostProcess = new PostProcess(\r\n                    \"rgbdDecode\",\r\n                    \"rgbdDecode\",\r\n                    null,\r\n                    null,\r\n                    1,\r\n                    null,\r\n                    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    false,\r\n                    undefined,\r\n                    internalTexture.type,\r\n                    undefined,\r\n                    null,\r\n                    false\r\n                );\r\n                rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n                // Hold the output of the decoding.\r\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                    generateDepthBuffer: false,\r\n                    generateMipMaps: false,\r\n                    generateStencilBuffer: false,\r\n                    samplingMode: internalTexture.samplingMode,\r\n                    type: internalTexture.type,\r\n                    format: Constants.TEXTUREFORMAT_RGBA,\r\n                });\r\n\r\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                    // PP Render Pass\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", internalTexture);\r\n                        effect.setFloat2(\"scale\", 1, 1);\r\n                    };\r\n                    texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    engine._releaseTexture(internalTexture);\r\n                    if (rgbdPostProcess) {\r\n                        rgbdPostProcess.dispose();\r\n                    }\r\n\r\n                    // Internal Swap\r\n                    expandedTexture._swapAndDie(internalTexture);\r\n\r\n                    // Ready to get rolling again.\r\n                    internalTexture.isReady = true;\r\n                });\r\n            }\r\n        };\r\n\r\n        if (isReady) {\r\n            expandRGBDTexture();\r\n        } else {\r\n            texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n", "import type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport { Tools } from \"./tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst _environmentBRDFBase64Texture =\r\n    \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==\";\r\n\r\nlet _instanceNumber = 0;\r\n\r\n/**\r\n * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n * @param scene defines the hosting scene\r\n * @returns the environment BRDF texture\r\n */\r\nexport const GetEnvironmentBRDFTexture = (scene: Scene): BaseTexture => {\r\n    if (!scene.environmentBRDFTexture) {\r\n        // Forces Delayed Texture Loading to prevent undefined error whilst setting RGBD values.\r\n        const useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const previousState = scene._blockEntityCollection;\r\n        scene._blockEntityCollection = false;\r\n        const texture = Texture.CreateFromBase64String(\r\n            _environmentBRDFBase64Texture,\r\n            \"EnvironmentBRDFTexture\" + _instanceNumber++,\r\n            scene,\r\n            true,\r\n            false,\r\n            Texture.BILINEAR_SAMPLINGMODE\r\n        );\r\n        scene._blockEntityCollection = previousState;\r\n        // BRDF Texture should not be cached here due to pre processing and redundant scene caches.\r\n        const texturesCache = scene.getEngine().getLoadedTexturesCache();\r\n        const index = texturesCache.indexOf(texture.getInternalTexture()!);\r\n        if (index !== -1) {\r\n            texturesCache.splice(index, 1);\r\n        }\r\n\r\n        texture.isRGBD = true;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        scene.environmentBRDFTexture = texture;\r\n\r\n        scene.useDelayedTextureLoading = useDelayedTextureLoading;\r\n\r\n        RGBDTextureTools.ExpandRGBDTexture(texture);\r\n\r\n        const observer = scene.getEngine().onContextRestoredObservable.add(() => {\r\n            texture.isRGBD = true;\r\n            const checkReady = () => {\r\n                if (texture.isReady()) {\r\n                    RGBDTextureTools.ExpandRGBDTexture(texture);\r\n                } else {\r\n                    Tools.SetImmediate(checkReady);\r\n                }\r\n            };\r\n            checkReady();\r\n        });\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            scene.getEngine().onContextRestoredObservable.remove(observer);\r\n        });\r\n    }\r\n\r\n    return scene.environmentBRDFTexture;\r\n};\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const BRDFTextureTools = {\r\n    /**\r\n     * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n     * @param scene defines the hosting scene\r\n     * @returns the environment BRDF texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GetEnvironmentBRDFTexture,\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { serialize, expandToProperty } from \"../../Misc/decorators\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialBRDFDefines extends MaterialDefines {\r\n    BRDF_V_HEIGHT_CORRELATED = false;\r\n    MS_BRDF_ENERGY_CONSERVATION = false;\r\n    SPHERICAL_HARMONICS = false;\r\n    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the BRDF component of the PBR material\r\n */\r\nexport class PBRBRDFConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for the energy conservation.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value used for the Smith Visibility Height Correlated mode.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;\r\n\r\n    /**\r\n     * Default value used for the IBL diffuse part.\r\n     * This can help switching back to the polynomials mode globally which is a tiny bit\r\n     * less GPU intensive at the drawback of a lower quality.\r\n     */\r\n    public static DEFAULT_USE_SPHERICAL_HARMONICS = true;\r\n\r\n    /**\r\n     * Default value used for activating energy conservation for the specular workflow.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     */\r\n    public static DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;\r\n\r\n    private _useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n\r\n    private _useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses height smith correlated visibility term.\r\n     * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR\r\n     * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png\r\n     * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision\r\n     * Not relying on height correlated will also disable energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n\r\n    private _useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     * The harmonics despite a tiny bigger cost has been proven to provide closer results\r\n     * to the ground truth.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n\r\n    private _useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation, when the specular workflow is active.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRBRDF\", 90, new MaterialBRDFDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n        this._enable(true);\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialBRDFDefines): void {\r\n        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;\r\n        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;\r\n        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;\r\n        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRBRDFConfiguration\";\r\n    }\r\n}\r\n", "import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Scalar.Clamp(r, 0, max);\r\n                        g = Scalar.Clamp(g, 0, max);\r\n                        b = Scalar.Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\n\r\ndeclare module \"./baseTexture\" {\r\n    export interface BaseTexture {\r\n        /**\r\n         * Get the polynomial representation of the texture data.\r\n         * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n         * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n         */\r\n        sphericalPolynomial: Nullable<SphericalPolynomial>;\r\n\r\n        /**\r\n         * Force recomputation of spherical polynomials.\r\n         * Can be useful if you generate a cubemap multiple times (from a probe for eg) and you need the proper polynomials each time\r\n         */\r\n        forceSphericalPolynomialsRecompute(): void;\r\n    }\r\n}\r\n\r\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function (): void {\r\n    if (this._texture) {\r\n        this._texture._sphericalPolynomial = null;\r\n        this._texture._sphericalPolynomialPromise = null;\r\n        this._texture._sphericalPolynomialComputed = false;\r\n    }\r\n};\r\n\r\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\r\n    get: function (this: BaseTexture) {\r\n        if (this._texture) {\r\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\r\n                return this._texture._sphericalPolynomial;\r\n            }\r\n\r\n            if (this._texture.isReady) {\r\n                if (!this._texture._sphericalPolynomialPromise) {\r\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n                    if (this._texture._sphericalPolynomialPromise === null) {\r\n                        this._texture._sphericalPolynomialComputed = true;\r\n                    } else {\r\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\r\n                            this._texture!._sphericalPolynomial = sphericalPolynomial;\r\n                            this._texture!._sphericalPolynomialComputed = true;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n    set: function (this: BaseTexture, value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragmentDeclaration\";\n\nconst name = \"pbrFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;\n#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\n#endif\nuniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#endif\n#ifdef IRIDESCENCE\nuniform vec4 vIridescenceParams;\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\nuniform vec4 vSheenColor;\n#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\n#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\n#endif\n#ifdef SS_DISPERSION\nuniform float dispersion;\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\nuniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;\n#endif\n#ifdef PREPASS\n#ifdef SS_SCATTERING\nuniform float scatteringDiffusionProfile;\n#endif\n#endif\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\n\nconst name = \"pbrUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./mainUVVaryingDeclaration\";\n\nconst name = \"pbrFragmentExtraDeclaration\";\nconst shader = `varying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentExtraDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerFragmentAlternateDeclaration\";\nconst shader = `#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerFragmentAlternateDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./samplerFragmentDeclaration\";\nimport \"./samplerFragmentAlternateDeclaration\";\n\nconst name = \"pbrFragmentSamplersDeclaration\";\nconst shader = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D clearCoatRoughnessSampler;\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D sheenRoughnessSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;\n#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;\n#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentSamplersDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"subSurfaceScatteringFunctions\";\nconst shader = `bool testLightingForSSS(float diffusionProfile)\n{return diffusionProfile<1.;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"importanceSampling\";\nconst shader = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \nfloat phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const importanceSampling = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrHelperFunctions\";\nconst shader = `#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\n{return square(roughness)+MINIMUMVARIANCE;}\nfloat fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}\nvec2 getAARoughnessFactors(vec3 normalVector) {\n#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2(0.);\n#endif\n}\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_LEGACY\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}\n#else\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}\n#endif\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);return clearCoatAbsorption;}\n#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrHelperFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"harmonicsFunctions\";\nconst shader = `#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00\n+ vSphericalL1_1*(normal.y)\n+ vSphericalL10*(normal.z)\n+ vSphericalL11*(normal.x)\n+ vSphericalL2_2*(normal.y*normal.x)\n+ vSphericalL2_1*(normal.y*normal.z)\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ vSphericalL21*(normal.z*normal.x)\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}\n#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const harmonicsFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingSetupFunctions\";\nconst shader = `struct preLightingInfo\n{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;\n#ifdef IRIDESCENCE\nfloat iridescenceIntensity;\n#endif\n};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingSetupFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingFalloffFunctions\";\nconst shader = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\n{return max(0.,1.0-length(lightOffset)/range);}\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n{return 1.0/maxEps(lightDistanceSquared);}\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\n{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\n{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)\n{falloff=max(0.,pow(cosAngle,exponent));}\nreturn falloff;}\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\n{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\n{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingFalloffFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBRDFFunctions\";\nconst shader = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\n{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}\n#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\n#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}\nvec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}\nfloat getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}\nvec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}\nfloat cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)\n{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}\nreturn max(I,vec3(0.0));}\n#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}\n#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}\n#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}\n#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }\n#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\n{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}\nfloat lambdaSheen(float cosTheta,float alphaG)\n{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\n{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}\n#endif\n*/\n#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}\n#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBRDFFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"hdrFilteringFunctions\";\nconst shader = `#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfloat radicalInverse_VdC(uint bits) \n{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }\nvec2 hammersley(uint i,uint N)\n{return vec2(float(i)/float(N),radicalInverse_VdC(i));}\n#else\nfloat vanDerCorpus(int n,int base)\n{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)\n{if(n>0)\n{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}\nreturn result;}\nvec2 hammersley(int i,int N)\n{return vec2(float(i)/float(N),vanDerCorpus(i,2));}\n#endif\nfloat log4(float x) {return log2(x)/2.;}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;}}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; \nif (alphaG==0.) {\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;}}\nresult=result/weight;return result;}}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingFunctions\";\nconst shader = `#define CLEARCOATREFLECTANCE90 1.0\nstruct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef CLEARCOAT\nvec4 clearCoat;\n#endif\n#ifdef SHEEN\nvec3 sheen;\n#endif\n};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\nfloat lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}\n#ifdef SS_TRANSLUCENCY\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}\n#endif\n#ifdef SPECULARTERM\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef ANISOTROPIC\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef CLEARCOAT\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);}\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}\n#endif\n#ifdef SHEEN\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER\nfloat visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\n#else */\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */\nfloat sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrIBLFunctions\";\nconst shader = `#if defined(REFLECTION) || defined(SS_REFRACTION)\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}\n#endif\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\n#define UNPACK_LOD(x) (1.0-x)*255.0\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrIBLFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragment\";\n\nconst name = \"pbrBlockAlbedoOpacity\";\nconst shader = `struct albedoOpacityOutParams\n{vec3 surfaceAlbedo;float alpha;};\n#define pbr_inline\nvoid albedoOpacityBlock(\nin vec4 vAlbedoColor,\n#ifdef ALBEDO\nin vec4 albedoTexture,\nin vec2 albedoInfos,\n#endif\n#ifdef OPACITY\nin vec4 opacityMap,\nin vec2 vOpacityInfos,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\n#ifdef DECAL\nin vec4 decalColor,\nin vec4 vDecalInfos,\n#endif\nout albedoOpacityOutParams outParams\n)\n{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#ifndef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nsurfaceAlbedo*=vColor.rgb;\n#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \n#endif\n#ifdef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST \n#if DEBUGMODE != 88\nif (alpha<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlbedoOpacity = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectivity\";\nconst shader = `struct reflectivityOutParams\n{float microSurface;float roughness;vec3 surfaceReflectivityColor;\n#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\n#endif\n#if DEBUGMODE>0\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness;\n#ifdef REFLECTIVITY\nvec4 surfaceMetallicColorMap;\n#endif\n#ifndef FROSTBITE_REFLECTANCE\nvec3 metallicF0;\n#endif\n#else\n#ifdef REFLECTIVITY\nvec4 surfaceReflectivityColorMap;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid reflectivityBlock(\nin vec4 vReflectivityColor,\n#ifdef METALLICWORKFLOW\nin vec3 surfaceAlbedo,\nin vec4 metallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nin vec3 reflectivityInfos,\nin vec4 surfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nin vec3 ambientOcclusionColorIn,\n#endif\n#ifdef MICROSURFACEMAP\nin vec4 microSurfaceTexel,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\nout reflectivityOutParams outParams\n)\n{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectivity = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAmbientOcclusion\";\nconst shader = `struct ambientOcclusionOutParams\n{vec3 ambientOcclusionColor;\n#if DEBUGMODE>0 && defined(AMBIENT)\nvec3 ambientOcclusionColorMap;\n#endif\n};\n#define pbr_inline\nvoid ambientOcclusionBlock(\n#ifdef AMBIENT\nin vec3 ambientOcclusionColorMap_,\nin vec4 vAmbientInfos,\n#endif\nout ambientOcclusionOutParams outParams\n)\n{vec3 ambientOcclusionColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAmbientOcclusion = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAlphaFresnel\";\nconst shader = `#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{float alpha;};\n#define pbr_inline\nvoid alphaFresnelBlock(\nin vec3 normalW,\nin vec3 viewDirectionW,\nin float alpha,\nin float microSurface,\nout alphaFresnelOutParams outParams\n)\n{float opacityPerceptual=alpha;\n#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\n#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\n#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\noutParams.alpha=1.0;\n#endif\n#endif\n}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlphaFresnel = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAnisotropic\";\nconst shader = `#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;\n#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)\nvec3 anisotropyMapData;\n#endif\n};\n#define pbr_inline\nvoid anisotropicBlock(\nin vec3 vAnisotropy,\nin float roughness,\n#ifdef ANISOTROPIC_TEXTURE\nin vec3 anisotropyMapData,\n#endif\nin mat3 TBN,\nin vec3 normalW,\nin vec3 viewDirectionW,\nout anisotropicOutParams outParams\n)\n{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\nanisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;\n#ifdef ANISOTROPIC_LEGACY\nanisotropyDirection.rg*=anisotropyMapData.rg;\n#else\nanisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);\n#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAnisotropic = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflection\";\nconst shader = `#ifdef REFLECTION\nstruct reflectionOutParams\n{vec4 environmentRadiance;vec3 environmentIrradiance;\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\n#else\nvec2 reflectionCoords;\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid createReflectionCoords(\nin vec3 vPositionW,\nin vec3 normalW,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\n#else\nout vec2 reflectionCoords\n#endif\n)\n{\n#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n}\n#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nconst vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nconst vec2 reflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout vec4 environmentRadiance\n)\n{\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\n#else\nfloat requestedReflectionLOD=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);} else {environmentRadiance=mix(\nenvironmentMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\n#endif\nenvironmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}\n#define pbr_inline\n#define inline\nvoid reflectionBlock(\nin vec3 vPositionW,\nin vec3 normalW,\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nin vec3 vEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin mat4 reflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout reflectionOutParams outParams\n)\n{vec4 environmentRadiance=vec4(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\n#else\nvec2 reflectionCoords=vec2(0.);\n#endif\ncreateReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\nreflectionCoords\n);sampleReflectionTexture(\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\nreflectionCoords,\n#else\nreflectionSampler,\nreflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentRadiance\n);vec3 environmentIrradiance=vec3(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflection = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockSheen\";\nconst shader = `#ifdef SHEEN\nstruct sheenOutParams\n{float sheenIntensity;vec3 sheenColor;float sheenRoughness;\n#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\n#endif\n#if DEBUGMODE>0\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 sheenEnvironmentReflectance;\n#endif\n#endif\n};\n#define pbr_inline\n#define inline\nvoid sheenBlock(\nin vec4 vSheenColor,\n#ifdef SHEEN_ROUGHNESS\nin float vSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 sheenMapRoughnessData,\n#endif\n#endif\nin float roughness,\n#ifdef SHEEN_TEXTURE\nin vec4 sheenMapData,\nin float sheenMapLevel,\n#endif\nin float reflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nin vec3 baseColor,\nin vec3 surfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nin float NdotV,\nin vec3 environmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nin vec2 AARoughnessFactors,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nin vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nin vec2 reflectionCoords,\n#endif\nin float NdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nin float seo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nin float eho,\n#endif\n#endif\nout sheenOutParams outParams\n)\n{float sheenIntensity=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\n#else\nsheenColor.rgb*=sheenMapData.rgb;\n#endif\nsheenColor.rgb*=sheenMapLevel;\n#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\nsheenRoughness*=sheenMapData.a;\n#else\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#endif\n#else\nfloat sheenRoughness=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\nsheenColor*=sheenIntensity;\n#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\nvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\n#else*/\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvec3 environmentSheenBrdf=environmentBrdf;\n#endif\n/*#endif*/\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(\nsheenAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\n#endif\nreflectionSampler,\nreflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentSheenRadiance\n);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\noutParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSheen = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockClearcoat\";\nconst shader = `struct clearcoatOutParams\n{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;\n#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\n#endif\n#if DEBUGMODE>0\n#ifdef CLEARCOAT_BUMP\nmat3 TBNClearCoat;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData;\n#endif\n#ifdef REFLECTION\nvec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;\n#endif\nfloat clearCoatNdotV;\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nvoid clearcoatBlock(\nin vec3 vPositionW,\nin vec3 geometricNormalW,\nin vec3 viewDirectionW,\nin vec2 vClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 clearCoatMapRoughnessData,\n#endif\nin vec3 specularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nin vec4 vClearCoatTintParams,\nin float clearCoatColorAtDistance,\nin vec4 vClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nin vec4 clearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nin vec2 vClearCoatBumpInfos,\nin vec4 clearCoatBumpMapData,\nin vec2 vClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nin mat3 vTBN,\n#else\nin vec2 vClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nin mat4 normalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nin vec3 faceNormal,\n#endif\n#ifdef REFLECTION\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nin float ambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\nin float frontFacingMultiplier,\n#endif\nout clearcoatOutParams outParams\n)\n{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\nclearCoatRoughness*=clearCoatMapData.y;\n#else\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\n#else\nclearCoatColor*=clearCoatTintMapData.rgb;\n#endif\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;\n#endif\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\n#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\n#else\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\n#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nsampleReflectionTexture(\nclearCoatAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\n#endif\nreflectionSampler,\nclearCoatReflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentClearCoatRadiance\n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockClearcoat = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockIridescence\";\nconst shader = `struct iridescenceOutParams\n{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};\n#ifdef IRIDESCENCE\n#define pbr_inline\n#define inline\nvoid iridescenceBlock(\nin vec4 vIridescenceParams,\nin float viewAngle,\nin vec3 specularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\nin vec2 iridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nin vec2 iridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nin float NdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#endif\nout iridescenceOutParams outParams\n)\n{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;\n#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\n#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE\niridescenceThicknessWeight=iridescenceMapData.g;\n#endif\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\n#endif\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; \n#ifdef CLEARCOAT\nfloat clearCoatIntensity=vClearCoatParams.x;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#endif\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\n#endif\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockIridescence = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockSubSurface\";\nconst shader = `struct subSurfaceOutParams\n{vec3 specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvec3 finalRefraction;vec3 surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\n#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;float translucencyIntensity;\n#ifdef REFLECTION\nvec3 refractionIrradiance;\n#endif\n#endif\n#if DEBUGMODE>0\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction;vec3 refractionTransmittance;\n#endif\n#endif\n};\n#ifdef SUBSURFACE\n#define pbr_inline\n#define inline\n#ifdef SS_REFRACTION\nvec4 sampleEnvironmentRefraction(\nin float ior\n,in float thickness\n,in float refractionLOD\n,in vec3 normalW\n,in vec3 vPositionW\n,in vec3 viewDirectionW\n,in mat4 view\n,in vec4 vRefractionInfos\n,in mat4 refractionMatrix\n,in vec4 vRefractionMicrosurfaceInfos\n,in float alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,in samplerCube refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in samplerCube refractionSamplerLow\n,in samplerCube refractionSamplerHigh\n#endif\n#else\n,in sampler2D refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in sampler2D refractionSamplerLow\n,in sampler2D refractionSamplerHigh\n#endif\n#endif\n#ifdef ANISOTROPIC\n,in anisotropicOutParams anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,in vec3 refractionPosition\n,in vec3 refractionSize\n#endif\n) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);\n#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,ior);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\n#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\n#endif\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef LODBASEDMICROSFURACE\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\n#else\nfloat requestedRefractionLOD=refractionLOD;\n#endif\n#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(\nsampleRefraction(refractionSamplerHigh,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);} else {environmentRefraction=mix(\nenvironmentRefractionMid,\nsampleRefraction(refractionSamplerLow,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\n#endif\nreturn environmentRefraction;}\n#endif\nvoid subSurfaceBlock(\nin vec3 vSubSurfaceIntensity,\nin vec2 vThicknessParam,\nin vec4 vTintColor,\nin vec3 normalW,\nin vec3 specularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nin vec4 thicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nin vec4 refractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nin vec4 translucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nin mat4 reflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin vec3 irradianceVector_,\n#endif\n#if defined(REALTIME_FILTERING)\nin samplerCube reflectionSampler,\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nin vec3 surfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nin vec3 vPositionW,\nin vec3 viewDirectionW,\nin mat4 view,\nin vec4 vRefractionInfos,\nin mat4 refractionMatrix,\nin vec4 vRefractionMicrosurfaceInfos,\nin vec4 vLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nin float alpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nin float NdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nin float roughness,\n#endif\nin float alphaG,\n#ifdef SS_REFRACTIONMAP_3D\nin samplerCube refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin samplerCube refractionSamplerLow,\nin samplerCube refractionSamplerHigh,\n#endif\n#else\nin sampler2D refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin sampler2D refractionSamplerLow,\nin sampler2D refractionSamplerHigh,\n#endif\n#endif\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nin vec3 refractionPosition,\nin vec3 refractionSize,\n#endif\n#ifdef SS_DISPERSION\nin float dispersion,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nin vec3 vDiffusionDistance,\n#endif\nout subSurfaceOutParams outParams\n)\n{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);outParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#if defined(SS_USE_GLTF_TEXTURES)\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#else\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)\n#if defined(SS_USE_GLTF_TEXTURES)\nrefractionIntensity*=thicknessMap.r;\n#else\nrefractionIntensity*=thicknessMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#endif\n#else\nfloat thickness=vThicknessParam.y;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\n#else\nrefractionIntensity*=refractionIntensityMap.g;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensity*=translucencyIntensityMap.b;\n#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef SS_HAS_THICKNESS\nfloat ior=vRefractionInfos.y;\n#else\nfloat ior=vRefractionMicrosurfaceInfos.w;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\n#else\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\n#endif\n#ifdef SS_DISPERSION\nfloat realIOR=1.0/ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {ior=iors[i];\n#endif\nvec4 envSample=sampleEnvironmentRefraction(ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionSamplerLow\n,refractionSamplerHigh\n#endif\n#else\n,refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionSamplerLow\n,refractionSamplerHigh\n#endif\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,refractionPosition\n,refractionSize\n#endif\n);\n#ifdef SS_DISPERSION\nenvironmentRefraction[i]=envSample[i];}\n#else\nenvironmentRefraction=envSample;\n#endif\nenvironmentRefraction.rgb*=vRefractionInfos.x;\n#endif\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;\n#else\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvec3 irradianceVector=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\n#else\nvec2 irradianceCoords=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\n#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\n#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\n#endif\nrefractionIrradiance.rgb*=transmittance;\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.refractionIrradiance=refractionIrradiance.rgb;\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSubSurface = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockNormalGeometric\";\nconst shader = `vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#endif\nvec3 geometricNormalW=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockNormalGeometric = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockNormalFinal\";\nconst shader = `#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockNormalFinal = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockLightmapInit\";\nconst shader = `#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockLightmapInit = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockGeometryInfo\";\nconst shader = `float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\n#else\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockGeometryInfo = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectance0\";\nconst shader = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\n#else \nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\n#endif\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance0 = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectance\";\nconst shader = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockDirectLighting\";\nconst shader = `vec3 diffuseBase=vec3(0.,0.,0.);\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatBase=vec3(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvec3 sheenBase=vec3(0.,0.,0.);\n#endif\npreLightingInfo preInfo;lightingInfo info;float shadow=1.; \nfloat aggShadow=0.;float numLights=0.;\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvec3 absorption=vec3(0.);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockDirectLighting = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalLitComponents\";\nconst shader = `aggShadow=aggShadow/numLights;\n#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n#ifdef REFLECTION\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef REFLECTION\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef SHEEN\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef CLEARCOAT\nvec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef ALPHABLEND\nfloat luminanceOverAlpha=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalLitComponents = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalUnlitComponents\";\nconst shader = `vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\n#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\n#else\nfinalEmissive*=emissiveColorTex.rgb;\n#endif\nfinalEmissive*= vEmissiveInfos.y;\n#endif\nfinalEmissive*=vLightingIntensity.y;\n#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\n#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalUnlitComponents = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalColorComposition\";\nconst shader = `vec4 finalColor=vec4(\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalAmbient +\nfinalDiffuse,\nalpha);\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor.rgb;\n#else\nfinalColor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\nfinalColor.rgb+=finalEmissive;\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,0.0);\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalColorComposition = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockImageProcessing\";\nconst shader = `#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\n#if !defined(SKIPFINALCOLORCLAMP)\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\n#endif\n#else\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\nfinalColor.rgb*=finalColor.a;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockImageProcessing = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDebug\";\nconst shader = `#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\n#if DEBUGMODE==1\ngl_FragColor.rgb=vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ngl_FragColor.rgb=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\n#elif DEBUGMODE==7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\n#ifndef GAMMAALBEDO\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE==22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\n#elif DEBUGMODE==23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\n#ifndef GAMMAEMISSIVE\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\n#ifndef GAMMALIGHTMAP\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\n#elif DEBUGMODE==32 && defined(BUMP)\ngl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ngl_FragColor.rgb=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\n#elif DEBUGMODE==63\ngl_FragColor.rgb=vec3(roughness);\n#elif DEBUGMODE==64\ngl_FragColor.rgb=vec3(alphaG);\n#elif DEBUGMODE==65\ngl_FragColor.rgb=vec3(NdotV);\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\n#elif DEBUGMODE==72\ngl_FragColor.rgb=vec3(microSurface);\n#elif DEBUGMODE==73\ngl_FragColor.rgb=vAlbedoColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vReflectivityColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==75\ngl_FragColor.rgb=vEmissiveColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)\ngl_FragColor.rgb=vec3(eho);\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\n#elif DEBUGMODE==87\ngl_FragColor.rgb=vec3(alpha);\n#elif DEBUGMODE==88 && defined(ALBEDO)\ngl_FragColor.rgb=vec3(albedoTexture.a);\n#else\nfloat stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);\n#endif\ngl_FragColor.rgb*=vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\n#endif\ngl_FragColor.a=1.0;\n#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor); \ngl_FragData[1]=vec4(0.,0.,0.,0.); \n#endif\n#ifdef DEBUGMODE_FORCERETURN\nreturn;\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDebug = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/pbrFragmentDeclaration\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentSamplersDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrHelperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions\";\nimport \"./ShadersInclude/pbrIBLFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/pbrBlockAlbedoOpacity\";\nimport \"./ShadersInclude/pbrBlockReflectivity\";\nimport \"./ShadersInclude/pbrBlockAmbientOcclusion\";\nimport \"./ShadersInclude/pbrBlockAlphaFresnel\";\nimport \"./ShadersInclude/pbrBlockAnisotropic\";\nimport \"./ShadersInclude/pbrBlockReflection\";\nimport \"./ShadersInclude/pbrBlockSheen\";\nimport \"./ShadersInclude/pbrBlockClearcoat\";\nimport \"./ShadersInclude/pbrBlockIridescence\";\nimport \"./ShadersInclude/pbrBlockSubSurface\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/pbrBlockNormalFinal\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/pbrBlockLightmapInit\";\nimport \"./ShadersInclude/pbrBlockGeometryInfo\";\nimport \"./ShadersInclude/pbrBlockReflectance0\";\nimport \"./ShadersInclude/pbrBlockReflectance\";\nimport \"./ShadersInclude/pbrBlockDirectLighting\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/pbrBlockFinalLitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalUnlitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalColorComposition\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/pbrBlockImageProcessing\";\nimport \"./ShadersInclude/oitFragment\";\nimport \"./ShadersInclude/pbrDebug\";\n\nconst name = \"pbrPixelShader\";\nconst shader = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nalbedoOpacityOutParams albedoOpacityOut;\n#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#endif\n#ifdef DECAL\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#endif\nalbedoOpacityBlock(\nvAlbedoColor,\n#ifdef ALBEDO\nalbedoTexture,\nvAlbedoInfos,\n#endif\n#ifdef OPACITY\nopacityMap,\nvOpacityInfos,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\n#ifdef DECAL\ndecalColor,\nvDecalInfos,\n#endif\nalbedoOpacityOut\n);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nambientOcclusionOutParams aoOut;\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\n#endif\nambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nvAmbientInfos,\n#endif\naoOut\n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;\n#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\n#endif\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\n#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityBlock(\nvReflectivityColor,\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo,\nmetallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nvReflectivityInfos,\nsurfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor,\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurfaceTexel,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nreflectivityOut\n);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface,\nalphaFresnelOut\n);alpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\n#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\n#endif\nanisotropicBlock(\nvAnisotropy,\nroughness,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW,\nanisotropicOut\n);\n#endif\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionBlock(\nvPositionW,\nnormalW,\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\nreflectionSampler,\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nvEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nreflectionOut\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nsheenOutParams sheenOut;\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\n#endif\nsheenBlock(\nvSheenColor,\n#ifdef SHEEN_ROUGHNESS\nvSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nsheenMapRoughnessData,\n#endif\n#endif\nroughness,\n#ifdef SHEEN_TEXTURE\nsheenMapData,\nvSheenInfos.y,\n#endif\nreflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nbaseColor,\nsurfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nNdotV,\nenvironmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nAARoughnessFactors,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\nreflectionOut.reflectionCoords,\nNdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nseo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\neho,\n#endif\n#endif\nsheenOut\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\niridescenceOutParams iridescenceOut;\n#ifdef IRIDESCENCE_TEXTURE\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\n#endif\niridescenceBlock(\nvIridescenceParams,\nNdotV,\nspecularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\niridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\niridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nNdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#endif\niridescenceOut\n);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nclearcoatOutParams clearcoatOut;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatBlock(\nvPositionW,\ngeometricNormalW,\nviewDirectionW,\nvClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatMapRoughnessData,\n#endif\nspecularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nvClearCoatTintParams,\nclearCoatColorAtDistance,\nvClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nvClearCoatBumpInfos,\nclearCoatBumpMapData,\nvClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nvTBN,\n#else\nvClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nnormalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nfaceNormal,\n#endif\n#ifdef REFLECTION\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n(gl_FrontFacing ? 1. : -1.),\n#endif\nclearcoatOut\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nsubSurfaceOutParams subSurfaceOut;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\n#endif\nsubSurfaceBlock(\nvSubSurfaceIntensity,\nvThicknessParam,\nvTintColor,\nnormalW,\nspecularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nrefractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nreflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionOut.irradianceVector,\n#endif\n#if defined(REALTIME_FILTERING)\nreflectionSampler,\nvReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nsurfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nvPositionW,\nviewDirectionW,\nview,\nvRefractionInfos,\nrefractionMatrix,\nvRefractionMicrosurfaceInfos,\nvLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nNdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nroughness,\n#endif\nalphaG,\nrefractionSampler,\n#ifndef LODBASEDMICROSFURACE\nrefractionSamplerLow,\nrefractionSamplerHigh,\n#endif\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nvRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nvRefractionPosition,\nvRefractionSize,\n#endif\n#ifdef SS_DISPERSION\ndispersion,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvDiffusionDistance,\n#endif\nsubSurfaceOut\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \n#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \nirradiance/=sqAlbedo;\n#else\ngl_FragData[0]=finalColor; \nfloat scatteringDiffusionProfile=255.;\n#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \n#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#ifndef UNLIT\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalVertexDeclaration\";\n\nconst name = \"pbrVertexDeclaration\";\nconst shader = `uniform mat4 view;uniform mat4 viewProjection;\n#ifdef ALBEDO\nuniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#ifdef REFLECTIVITY \nuniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;\n#endif\n#ifdef METALLIC_REFLECTANCE\nuniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;\n#endif\n#ifdef REFLECTANCE\nuniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#ifdef IRIDESCENCE\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\n#endif\n#ifdef NORMAL\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/pbrVertexDeclaration\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"pbrVertexShader\";\nconst shader = `precision highp float;\n#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#endif\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);\n#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialClearCoatDefines extends MaterialDefines {\r\n    public CLEARCOAT = false;\r\n    public CLEARCOAT_DEFAULTIOR = false;\r\n    public CLEARCOAT_TEXTURE = false;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n    public CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public CLEARCOAT_BUMP = false;\r\n    public CLEARCOAT_BUMPDIRECTUV = 0;\r\n    public CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;\r\n    public CLEARCOAT_REMAP_F0 = false;\r\n\r\n    public CLEARCOAT_TINT = false;\r\n    public CLEARCOAT_TINT_TEXTURE = false;\r\n    public CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the clear coat component of the PBR material\r\n */\r\nexport class PBRClearCoatConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.5;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the clear coat is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer roughness.\r\n     */\r\n    @serialize()\r\n    public roughness: number = 0;\r\n\r\n    private _indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n    /**\r\n     * Defines the index of refraction of the clear coat.\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * Changing the default value is more performance intensive.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat values in a texture (red channel is intensity and green channel is roughness)\r\n     * If useRoughnessFromMainTexture is false, the green channel of texture is not used and the green channel of textureRoughness is used instead\r\n     * if textureRoughness is not empty, else no texture roughness is used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the green channel of the texture property will be used for roughness (default: true)\r\n     * If false, the green channel from textureRoughness is used for roughness\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat roughness in a texture (green channel)\r\n     * Not used if useRoughnessFromMainTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _remapF0OnInterfaceChange = true;\r\n    /**\r\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public remapF0OnInterfaceChange = true;\r\n\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the clear coat specific bump texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _isTintEnabled = false;\r\n    /**\r\n     * Defines if the clear coat tint is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTintEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat tint of the material.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the\r\n     * clear coat media.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer thickness.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintThickness: number = 1;\r\n\r\n    private _tintTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear tint values in a texture.\r\n     * rgb is tint\r\n     * a is a thickness factor\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public tintTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRClearCoat\", 100, new MaterialClearCoatDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialClearCoatDefines, scene: Scene, engine: Engine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                    if (!this._tintTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialClearCoatDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.CLEARCOAT = true;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL =\r\n                this._texture !== null && this._texture._texture === this._textureRoughness?._texture && this._texture.checkTransformsAreIdentical(this._textureRoughness);\r\n            defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"CLEARCOAT_TEXTURE\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"CLEARCOAT_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n\r\n                    if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"CLEARCOAT_BUMP\");\r\n                    } else {\r\n                        defines.CLEARCOAT_BUMP = false;\r\n                    }\r\n\r\n                    defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n                    if (this._isTintEnabled) {\r\n                        defines.CLEARCOAT_TINT = true;\r\n                        if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                            MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, \"CLEARCOAT_TINT_TEXTURE\");\r\n                            defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;\r\n                        } else {\r\n                            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                        }\r\n                    } else {\r\n                        defines.CLEARCOAT_TINT = false;\r\n                        defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.CLEARCOAT = false;\r\n            defines.CLEARCOAT_TEXTURE = false;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n            defines.CLEARCOAT_BUMP = false;\r\n            defines.CLEARCOAT_TINT = false;\r\n            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;\r\n            defines.CLEARCOAT_DEFAULTIOR = false;\r\n            defines.CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n            defines.CLEARCOAT_BUMPDIRECTUV = 0;\r\n            defines.CLEARCOAT_REMAP_F0 = false;\r\n            defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialClearCoatDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        const invertNormalMapX = this._material._invertNormalMapX;\r\n        const invertNormalMapY = this._material._invertNormalMapY;\r\n\r\n        const identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vClearCoatInfos\", this._texture!.coordinatesIndex, this._texture!.level, -1, -1);\r\n                MaterialHelper.BindTextureMatrix(this._texture!, uniformBuffer, \"clearCoat\");\r\n            } else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vClearCoatInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"clearCoat\");\r\n                }\r\n                if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"clearCoatRoughness\");\r\n                }\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, \"clearCoatBump\");\r\n\r\n                if (scene._mirroredCameraPosition) {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? 1.0 : -1.0, invertNormalMapY ? 1.0 : -1.0);\r\n                } else {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? -1.0 : 1.0, invertNormalMapY ? -1.0 : 1.0);\r\n                }\r\n            }\r\n\r\n            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatTintInfos\", this._tintTexture.coordinatesIndex, this._tintTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, \"clearCoatTint\");\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat2(\"vClearCoatParams\", this.intensity, this.roughness);\r\n\r\n            // Clear Coat Refraction params\r\n            const a = 1 - this._indexOfRefraction;\r\n            const b = 1 + this._indexOfRefraction;\r\n            const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\r\n            const eta = 1 / this._indexOfRefraction;\r\n            uniformBuffer.updateFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\r\n\r\n            if (this._isTintEnabled) {\r\n                uniformBuffer.updateFloat4(\"vClearCoatTintParams\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintThickness));\r\n                uniformBuffer.updateFloat(\"clearCoatColorAtDistance\", Math.max(0.00001, this.tintColorAtDistance));\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatRoughnessSampler\", this._textureRoughness);\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.setTexture(\"clearCoatBumpSampler\", this._bumpTexture);\r\n            }\r\n\r\n            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatTintSampler\", this._tintTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._tintTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture) {\r\n            activeTextures.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            animatables.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {\r\n            animatables.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._tintTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRClearCoatConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialClearCoatDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.CLEARCOAT_BUMP) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_BUMP\");\r\n        }\r\n        if (defines.CLEARCOAT_TINT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_TINT\");\r\n        }\r\n        if (defines.CLEARCOAT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"clearCoatSampler\", \"clearCoatRoughnessSampler\", \"clearCoatBumpSampler\", \"clearCoatTintSampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vClearCoatParams\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatRefractionParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vClearCoatInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"clearCoatRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatBumpInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatTangentSpaceParams\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatBumpMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatTintParams\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatColorAtDistance\", size: 1, type: \"float\" },\r\n                { name: \"vClearCoatTintInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatTintMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty } from \"../../Misc/decorators\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialIridescenceDefines extends MaterialDefines {\r\n    public IRIDESCENCE = false;\r\n    public IRIDESCENCE_TEXTURE = false;\r\n    public IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n    public IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n    public IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n    public IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the iridescence (thin film) component of the PBR material\r\n */\r\nexport class PBRIridescenceConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * The default minimum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 100 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMinimumThickness = 100;\r\n\r\n    /**\r\n     * The default maximum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 400 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMaximumThickness = 400;\r\n\r\n    /**\r\n     * The default index of refraction of the thin-film layer.\r\n     * Defaults to 1.3\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.3;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the iridescence is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the iridescence layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the minimum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = PBRIridescenceConfiguration._DefaultMinimumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm). This will be the thickness used if not thickness texture has been set.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = PBRIridescenceConfiguration._DefaultMaximumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction: number = PBRIridescenceConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence intensity in a texture (red channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence thickness in a texture (green channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRIridescence\", 110, new MaterialIridescenceDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialIridescenceDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialIridescenceDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.IRIDESCENCE = true;\r\n            defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE =\r\n                this._texture !== null && this._texture._texture === this._thicknessTexture?._texture && this._texture.checkTransformsAreIdentical(this._thicknessTexture);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"IRIDESCENCE_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_TEXTURE = false;\r\n                    }\r\n\r\n                    if (!defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"IRIDESCENCE_THICKNESS_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.IRIDESCENCE = false;\r\n            defines.IRIDESCENCE_TEXTURE = false;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n            defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;\r\n            defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialIridescenceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        const identicalTextures = defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (identicalTextures && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vIridescenceInfos\", this._texture!.coordinatesIndex, this._texture!.level, -1, -1);\r\n                MaterialHelper.BindTextureMatrix(this._texture!, uniformBuffer, \"iridescence\");\r\n            } else if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vIridescenceInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._thicknessTexture?.coordinatesIndex ?? 0,\r\n                    this._thicknessTexture?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"iridescence\");\r\n                }\r\n                if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE) {\r\n                    MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"iridescenceThickness\");\r\n                }\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat4(\"vIridescenceParams\", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceSampler\", this._texture);\r\n            }\r\n\r\n            if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceThicknessSampler\", this._thicknessTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._thicknessTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRIridescenceConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialIridescenceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.IRIDESCENCE) {\r\n            fallbacks.addFallback(currentRank++, \"IRIDESCENCE\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"iridescenceSampler\", \"iridescenceThicknessSampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vIridescenceParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vIridescenceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"iridescenceMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"iridescenceThicknessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public ANISOTROPIC_LEGACY = false;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    /**\r\n     * Sets the anisotropy direction as an angle.\r\n     */\r\n    public set angle(value: number) {\r\n        this.direction.x = Math.cos(value);\r\n        this.direction.y = Math.sin(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy angle value in radians.\r\n     * @returns the anisotropy angle value in radians.\r\n     */\r\n    public get angle(): number {\r\n        return Math.atan2(this.direction.y, this.direction.x);\r\n    }\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _legacy = false;\r\n    /**\r\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public legacy: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (defines._areMiscDirty) {\r\n                defines.ANISOTROPIC_LEGACY = this._legacy;\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n            defines.ANISOTROPIC_LEGACY = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n\r\n        // Backward compatibility\r\n        if (source.legacy === undefined) {\r\n            this.legacy = true;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSheenDefines extends MaterialDefines {\r\n    public SHEEN = false;\r\n    public SHEEN_TEXTURE = false;\r\n    public SHEEN_GAMMATEXTURE = false;\r\n    public SHEEN_TEXTURE_ROUGHNESS = false;\r\n    public SHEEN_TEXTUREDIRECTUV = 0;\r\n    public SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public SHEEN_LINKWITHALBEDO = false;\r\n    public SHEEN_ROUGHNESS = false;\r\n    public SHEEN_ALBEDOSCALING = false;\r\n    public SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n    public SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sheen component of the PBR material.\r\n */\r\nexport class PBRSheenConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    private _linkSheenWithAlbedo = false;\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkSheenWithAlbedo = false;\r\n\r\n    /**\r\n     * Defines the sheen intensity.\r\n     */\r\n    @serialize()\r\n    public intensity = 1;\r\n\r\n    /**\r\n     * Defines the sheen color.\r\n     */\r\n    @serializeAsColor3()\r\n    public color = Color3.White();\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _roughness: Nullable<number> = null;\r\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number> = null;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _albedoScaling = false;\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoScaling = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"Sheen\", 120, new MaterialSheenDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialSheenDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialSheenDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.SHEEN = true;\r\n            defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\r\n            defines.SHEEN_ROUGHNESS = this._roughness !== null;\r\n            defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL =\r\n                this._texture !== null && this._texture._texture === this._textureRoughness?._texture && this._texture.checkTransformsAreIdentical(this._textureRoughness);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\r\n                        defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.SHEEN = false;\r\n            defines.SHEEN_TEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n            defines.SHEEN_LINKWITHALBEDO = false;\r\n            defines.SHEEN_ROUGHNESS = false;\r\n            defines.SHEEN_ALBEDOSCALING = false;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\r\n            defines.SHEEN_GAMMATEXTURE = false;\r\n            defines.SHEEN_TEXTUREDIRECTUV = 0;\r\n            defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialSheenDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture!.coordinatesIndex, this._texture!.level, -1, -1);\r\n                MaterialHelper.BindTextureMatrix(this._texture!, uniformBuffer, \"sheen\");\r\n            } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vSheenInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\r\n                }\r\n                if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\r\n                }\r\n            }\r\n\r\n            // Sheen\r\n            uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\r\n\r\n            if (this._roughness !== null) {\r\n                uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRSheenConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialSheenDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SHEEN) {\r\n            fallbacks.addFallback(currentRank++, \"SHEEN\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"sheenSampler\", \"sheenRoughnessSampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vSheenColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSheenRoughness\", size: 1, type: \"float\" },\r\n                { name: \"vSheenInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"sheenMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"sheenRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_SCATTERING = false;\r\n    public SS_DISPERSION = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isDispersionEnabled = false;\r\n    /**\r\n     * Defines if dispersion is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isDispersionEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @internal */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the Abbe number for the volume.\r\n     */\r\n    @serialize()\r\n    public dispersion = 0;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _useGltfStyleTextures = false;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @internal */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_DISPERSION = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_DISPERSION = this._isDispersionEnabled;\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n            const refractionIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._refractionIntensityTexture &&\r\n                this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            const translucencyIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._translucencyIntensityTexture &&\r\n                this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\r\n            const useOnlyThicknessTexture =\r\n                (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) &&\r\n                (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE =\r\n                (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n\r\n        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n\r\n        uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n\r\n            uniformBuffer.updateFloat(\"dispersion\", this.dispersion);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n                { name: \"dispersion\", size: 1, type: \"float\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsImageProcessingConfiguration, expandToProperty } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration\";\r\nimport { PrePassConfiguration } from \"../prePassConfiguration\";\r\nimport { Color3, TmpColors } from \"../../Maths/math.color\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\nimport type { IImageProcessingConfigurationDefines } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { IMaterialCompilationOptions, ICustomShaderNameResolveOptions } from \"../../Materials/material\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MaterialPluginEvent } from \"../materialPluginEvent\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\n\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\n\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\n\r\nimport \"../../Materials/Textures/baseTexture.polynomial\";\r\nimport \"../../Shaders/pbr.fragment\";\r\nimport \"../../Shaders/pbr.vertex\";\r\n\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration\";\r\nimport { PBRIridescenceConfiguration } from \"./pbrIridescenceConfiguration\";\r\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration\";\r\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration\";\r\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration\";\r\nimport { DetailMapConfiguration } from \"../material.detailMapConfiguration\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Manages the defines for the PBR Material.\r\n * @internal\r\n */\r\nexport class PBRMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public PBR = true;\r\n\r\n    public NUM_SAMPLES = \"0\";\r\n    public REALTIME_FILTERING = false;\r\n\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public MAINUV3 = false;\r\n    public MAINUV4 = false;\r\n    public MAINUV5 = false;\r\n    public MAINUV6 = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    public ALBEDO = false;\r\n    public GAMMAALBEDO = false;\r\n    public ALBEDODIRECTUV = 0;\r\n    public VERTEXCOLOR = false;\r\n\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public AMBIENTINGRAYSCALE = false;\r\n\r\n    public OPACITY = false;\r\n    public VERTEXALPHA = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHABLEND = false;\r\n    public ALPHAFROMALBEDO = false;\r\n    public ALPHATESTVALUE = \"0.5\";\r\n    public SPECULAROVERALPHA = false;\r\n    public RADIANCEOVERALPHA = false;\r\n    public ALPHAFRESNEL = false;\r\n    public LINEARALPHAFRESNEL = false;\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public GAMMAEMISSIVE = false;\r\n\r\n    public REFLECTIVITY = false;\r\n    public REFLECTIVITY_GAMMA = false;\r\n    public REFLECTIVITYDIRECTUV = 0;\r\n    public SPECULARTERM = false;\r\n\r\n    public MICROSURFACEFROMREFLECTIVITYMAP = false;\r\n    public MICROSURFACEAUTOMATIC = false;\r\n    public LODBASEDMICROSFURACE = false;\r\n    public MICROSURFACEMAP = false;\r\n    public MICROSURFACEMAPDIRECTUV = 0;\r\n\r\n    public METALLICWORKFLOW = false;\r\n    public ROUGHNESSSTOREINMETALMAPALPHA = false;\r\n    public ROUGHNESSSTOREINMETALMAPGREEN = false;\r\n    public METALLNESSSTOREINMETALMAPBLUE = false;\r\n    public AOSTOREINMETALMAPRED = false;\r\n    public METALLIC_REFLECTANCE = false;\r\n    public METALLIC_REFLECTANCE_GAMMA = false;\r\n    public METALLIC_REFLECTANCEDIRECTUV = 0;\r\n    public METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;\r\n    public REFLECTANCE = false;\r\n    public REFLECTANCE_GAMMA = false;\r\n    public REFLECTANCEDIRECTUV = 0;\r\n\r\n    public ENVIRONMENTBRDF = false;\r\n    public ENVIRONMENTBRDF_RGBD = false;\r\n\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public NORMALXYSCALE = true;\r\n\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public GAMMALIGHTMAP = false;\r\n    public RGBDLIGHTMAP = false;\r\n\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public USESPHERICALFROMREFLECTIONMAP = false;\r\n    public USEIRRADIANCEMAP = false;\r\n    public USESPHERICALINVERTEX = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public LINEARSPECULARREFLECTION = false;\r\n    public RADIANCEOCCLUSION = false;\r\n    public HORIZONOCCLUSION = false;\r\n\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n\r\n    public NONUNIFORMSCALING = false;\r\n\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public EXPOSURE = false;\r\n    public MULTIVIEW = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\r\n\r\n    public USEPHYSICALLIGHTFALLOFF = false;\r\n    public USEGLTFLIGHTFALLOFF = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public SHADOWFLOAT = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    public FORCENORMALFORWARD = false;\r\n\r\n    public SPECULARAA = false;\r\n\r\n    public UNLIT = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    public DEBUGMODE = 0;\r\n\r\n    /**\r\n     * Initializes the PBR Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Resets the PBR Material defines.\r\n     */\r\n    public reset(): void {\r\n        super.reset();\r\n        this.ALPHATESTVALUE = \"0.5\";\r\n        this.PBR = true;\r\n        this.NORMALXYSCALE = true;\r\n    }\r\n}\r\n\r\n/**\r\n * The Physically based material base class of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n */\r\nexport abstract class PBRBaseMaterial extends PushMaterial {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly LIGHTFALLOFF_PHYSICAL = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly LIGHTFALLOFF_GLTF = 1;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly LIGHTFALLOFF_STANDARD = 2;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     * @internal\r\n     */\r\n    public _directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     * @internal\r\n     */\r\n    public _emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     * @internal\r\n     */\r\n    public _environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     * @internal\r\n     */\r\n    public _specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\r\n     */\r\n    private _lightingInfos: Vector4 = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     * @internal\r\n     */\r\n    public _disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     * @internal\r\n     */\r\n    public _ambientTextureImpactOnAnalyticalLights: number = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture.\r\n     * @internal\r\n     */\r\n    public _opacityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     * @internal\r\n     */\r\n    public _reflectionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     * @internal\r\n     */\r\n    public _emissiveTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     * @internal\r\n     */\r\n    public _metallicTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _metallic: Nullable<number> = null;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _roughness: Nullable<number> = null;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     * @internal\r\n     */\r\n    public _metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from _metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     * @internal\r\n     */\r\n    public _useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiply against the scalar values defined in the material.\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both _reflectanceTexture and _metallicReflectanceTexture textures are provided and _useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, _metallicReflectanceTexture takes precedence and _reflectanceTexture is not used\r\n     * @internal\r\n     */\r\n    public _reflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     * @internal\r\n     */\r\n    public _microSurfaceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _lightmapTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     * @internal\r\n     */\r\n    public _ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is reflected from a material.\r\n     * @internal\r\n     */\r\n    public _reflectionColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is emitted from a material.\r\n     * @internal\r\n     */\r\n    public _emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _microSurface = 0.9;\r\n\r\n    /**\r\n     * Specifies that the material will use the light map as a show map.\r\n     * @internal\r\n     */\r\n    public _useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     * @internal\r\n     */\r\n    public _useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     * @internal\r\n     */\r\n    public _useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     * @internal\r\n     */\r\n    public _useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     * @internal\r\n     */\r\n    public _useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     * @internal\r\n     */\r\n    public _useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     * @internal\r\n     */\r\n    public _useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     * @internal\r\n     */\r\n    public _useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     * @internal\r\n     */\r\n    public _lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     * @internal\r\n     */\r\n    public _useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     * @internal\r\n     */\r\n    public _useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     * @internal\r\n     */\r\n    public _useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     * @internal\r\n     */\r\n    public _parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     * @internal\r\n     */\r\n    public _disableLighting = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     * @internal\r\n     */\r\n    public _maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     * @internal\r\n     */\r\n    public _twoSidedLighting = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     * @internal\r\n     */\r\n    public _alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     * @internal\r\n     */\r\n    public _forceAlphaTest = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\r\n     * from cos theta and roughness:\r\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n     * @internal\r\n     */\r\n    public _environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     * @internal\r\n     */\r\n    public _forceIrradianceInFragment = false;\r\n\r\n    private _realTimeFiltering: boolean = false;\r\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\r\n    public get realTimeFiltering() {\r\n        return this._realTimeFiltering;\r\n    }\r\n    public set realTimeFiltering(b: boolean) {\r\n        this._realTimeFiltering = b;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private _realTimeFilteringQuality: number = Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\r\n    public get realTimeFilteringQuality(): number {\r\n        return this._realTimeFilteringQuality;\r\n    }\r\n    public set realTimeFilteringQuality(n: number) {\r\n        this._realTimeFilteringQuality = n;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     * @internal\r\n     */\r\n    public _forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     * @internal\r\n     */\r\n    public _enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the PBR Material.\r\n     */\r\n    @serializeAsImageProcessingConfiguration()\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the available render targets.\r\n     */\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /**\r\n     * Sets the global ambient color for the material used in lighting calculations.\r\n     */\r\n    private _globalAmbientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    private _unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    private _applyDecalMapAfterDetailMap = false;\r\n\r\n    private _debugMode = 0;\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public debugMode = 0;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to -1\r\n     */\r\n    public debugLimit = -1;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\r\n    public debugFactor = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer parameters for the material.\r\n     */\r\n    public readonly clearCoat: PBRClearCoatConfiguration;\r\n\r\n    /**\r\n     * Defines the iridescence layer parameters for the material.\r\n     */\r\n    public readonly iridescence: PBRIridescenceConfiguration;\r\n\r\n    /**\r\n     * Defines the anisotropic parameters for the material.\r\n     */\r\n    public readonly anisotropy: PBRAnisotropicConfiguration;\r\n\r\n    /**\r\n     * Defines the BRDF parameters for the material.\r\n     */\r\n    public readonly brdf: PBRBRDFConfiguration;\r\n\r\n    /**\r\n     * Defines the Sheen parameters for the material.\r\n     */\r\n    public readonly sheen: PBRSheenConfiguration;\r\n\r\n    /**\r\n     * Defines the SubSurface parameters for the material.\r\n     */\r\n    public readonly subSurface: PBRSubSurfaceConfiguration;\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap: DetailMapConfiguration;\r\n\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.brdf = new PBRBRDFConfiguration(this);\r\n        this.clearCoat = new PBRClearCoatConfiguration(this);\r\n        this.iridescence = new PBRIridescenceConfiguration(this);\r\n        this.anisotropy = new PBRAnisotropicConfiguration(this);\r\n        this.sheen = new PBRSheenConfiguration(this);\r\n        this.subSurface = new PBRSubSurfaceConfiguration(this);\r\n        this.detailMap = new DetailMapConfiguration(this);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the material class.\r\n     */\r\n    public getClassName(): string {\r\n        return \"PBRBaseMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return (\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE ||\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST ||\r\n            this.subSurface?.disableAlphaBlending\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        if (this.subSurface?.disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromAlbedoTexture(): boolean {\r\n        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this._albedoTexture != null && this._albedoTexture.hasAlpha) || this._opacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._albedoTexture;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param mesh - BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\r\n     * @param useInstances - Specifies that instances should be used.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n        }\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._albedoTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    if (reflectionTexture.irradianceTexture) {\r\n                        if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        // Not ready until spherical are ready too.\r\n                        if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        if (!this._metallicTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else if (this._reflectivityTexture) {\r\n                        if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._reflectanceTexture) {\r\n                        if (!this._reflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    // This is blocking.\r\n                    if (!this._environmentBRDFTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            mesh.createNormals(true);\r\n            Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n        }\r\n\r\n        const previousEffect = subMesh.effect;\r\n        const lightDisposed = defines._areLightsDisposed;\r\n        let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (effect) {\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n\r\n            // Use previous effect while new one is compiling\r\n            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                effect = previousEffect;\r\n                defines.markAsUnprocessed();\r\n\r\n                forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                if (lightDisposed) {\r\n                    // re register in case it takes more than one frame.\r\n                    defines._areLightsDisposed = true;\r\n                    return false;\r\n                }\r\n            } else {\r\n                scene.resetCachedMaterial();\r\n                subMesh.setEffect(effect, defines, this._materialContext);\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses metallic roughness workflow.\r\n     * @returns boolean specifying if the material uses metallic roughness workflow.\r\n     */\r\n    public isMetallicWorkflow(): boolean {\r\n        if (this._metallic != null || this._roughness != null || this._metallicTexture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _prepareEffect(\r\n        mesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null,\r\n        useThinInstances: boolean\r\n    ): Nullable<Effect> {\r\n        this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);\r\n\r\n        if (!defines.isDirty) {\r\n            return null;\r\n        }\r\n\r\n        defines.markAsProcessed();\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Fallbacks\r\n        const fallbacks = new EffectFallbacks();\r\n        let fallbackRank = 0;\r\n        if (defines.USESPHERICALINVERTEX) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\r\n        }\r\n\r\n        if (defines.FOG) {\r\n            fallbacks.addFallback(fallbackRank, \"FOG\");\r\n        }\r\n        if (defines.SPECULARAA) {\r\n            fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\r\n        }\r\n        if (defines.POINTSIZE) {\r\n            fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\r\n        }\r\n        if (defines.LOGARITHMICDEPTH) {\r\n            fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\r\n        }\r\n        if (defines.PARALLAX) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX\");\r\n        }\r\n        if (defines.PARALLAX_RHS) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX_RHS\");\r\n        }\r\n        if (defines.PARALLAXOCCLUSION) {\r\n            fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\r\n        }\r\n\r\n        if (defines.ENVIRONMENTBRDF) {\r\n            fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"TANGENT\");\r\n        }\r\n\r\n        if (defines.BUMP) {\r\n            fallbacks.addFallback(fallbackRank++, \"BUMP\");\r\n        }\r\n\r\n        fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\r\n        }\r\n\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\r\n        }\r\n\r\n        if (defines.USEIRRADIANCEMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\r\n        }\r\n\r\n        if (defines.LIGHTMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\r\n        }\r\n\r\n        if (defines.NORMAL) {\r\n            fallbacks.addFallback(fallbackRank++, \"NORMAL\");\r\n        }\r\n\r\n        if (defines.AMBIENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\r\n        }\r\n\r\n        if (defines.EMISSIVE) {\r\n            fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\r\n        }\r\n\r\n        if (defines.MORPHTARGETS) {\r\n            fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\r\n        }\r\n\r\n        if (defines.MULTIVIEW) {\r\n            fallbacks.addFallback(0, \"MULTIVIEW\");\r\n        }\r\n\r\n        //Attributes\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        if (defines.NORMAL) {\r\n            attribs.push(VertexBuffer.NormalKind);\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            attribs.push(VertexBuffer.TangentKind);\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            if (defines[\"UV\" + i]) {\r\n                attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n            }\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n        MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n        MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n        MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n        let shaderName = \"pbr\";\r\n\r\n        const uniforms = [\r\n            \"world\",\r\n            \"view\",\r\n            \"viewProjection\",\r\n            \"vEyePosition\",\r\n            \"vLightsType\",\r\n            \"vAmbientColor\",\r\n            \"vAlbedoColor\",\r\n            \"vReflectivityColor\",\r\n            \"vMetallicReflectanceFactors\",\r\n            \"vEmissiveColor\",\r\n            \"visibility\",\r\n            \"vReflectionColor\",\r\n            \"vFogInfos\",\r\n            \"vFogColor\",\r\n            \"pointSize\",\r\n            \"vAlbedoInfos\",\r\n            \"vAmbientInfos\",\r\n            \"vOpacityInfos\",\r\n            \"vReflectionInfos\",\r\n            \"vReflectionPosition\",\r\n            \"vReflectionSize\",\r\n            \"vEmissiveInfos\",\r\n            \"vReflectivityInfos\",\r\n            \"vReflectionFilteringInfo\",\r\n            \"vMetallicReflectanceInfos\",\r\n            \"vReflectanceInfos\",\r\n            \"vMicroSurfaceSamplerInfos\",\r\n            \"vBumpInfos\",\r\n            \"vLightmapInfos\",\r\n            \"mBones\",\r\n            \"albedoMatrix\",\r\n            \"ambientMatrix\",\r\n            \"opacityMatrix\",\r\n            \"reflectionMatrix\",\r\n            \"emissiveMatrix\",\r\n            \"reflectivityMatrix\",\r\n            \"normalMatrix\",\r\n            \"microSurfaceSamplerMatrix\",\r\n            \"bumpMatrix\",\r\n            \"lightmapMatrix\",\r\n            \"metallicReflectanceMatrix\",\r\n            \"reflectanceMatrix\",\r\n            \"vLightingIntensity\",\r\n            \"logarithmicDepthConstant\",\r\n            \"vSphericalX\",\r\n            \"vSphericalY\",\r\n            \"vSphericalZ\",\r\n            \"vSphericalXX_ZZ\",\r\n            \"vSphericalYY_ZZ\",\r\n            \"vSphericalZZ\",\r\n            \"vSphericalXY\",\r\n            \"vSphericalYZ\",\r\n            \"vSphericalZX\",\r\n            \"vSphericalL00\",\r\n            \"vSphericalL1_1\",\r\n            \"vSphericalL10\",\r\n            \"vSphericalL11\",\r\n            \"vSphericalL2_2\",\r\n            \"vSphericalL2_1\",\r\n            \"vSphericalL20\",\r\n            \"vSphericalL21\",\r\n            \"vSphericalL22\",\r\n            \"vReflectionMicrosurfaceInfos\",\r\n            \"vTangentSpaceParams\",\r\n            \"boneTextureWidth\",\r\n            \"vDebugMode\",\r\n            \"morphTargetTextureInfo\",\r\n            \"morphTargetTextureIndices\",\r\n        ];\r\n\r\n        const samplers = [\r\n            \"albedoSampler\",\r\n            \"reflectivitySampler\",\r\n            \"ambientSampler\",\r\n            \"emissiveSampler\",\r\n            \"bumpSampler\",\r\n            \"lightmapSampler\",\r\n            \"opacitySampler\",\r\n            \"reflectionSampler\",\r\n            \"reflectionSamplerLow\",\r\n            \"reflectionSamplerHigh\",\r\n            \"irradianceSampler\",\r\n            \"microSurfaceSampler\",\r\n            \"environmentBrdfSampler\",\r\n            \"boneSampler\",\r\n            \"metallicReflectanceSampler\",\r\n            \"reflectanceSampler\",\r\n            \"morphTargets\",\r\n            \"oitDepthSampler\",\r\n            \"oitFrontColorSampler\",\r\n        ];\r\n\r\n        const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n        this._eventInfo.fallbacks = fallbacks;\r\n        this._eventInfo.fallbackRank = fallbackRank;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.uniforms = uniforms;\r\n        this._eventInfo.attributes = attribs;\r\n        this._eventInfo.samplers = samplers;\r\n        this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n        this._eventInfo.customCode = undefined;\r\n        this._eventInfo.mesh = mesh;\r\n        this._eventInfo.indexParameters = indexParameters;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n        PrePassConfiguration.AddUniforms(uniforms);\r\n        PrePassConfiguration.AddSamplers(samplers);\r\n        addClipPlaneUniforms(uniforms);\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n        }\r\n\r\n        MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n            uniformsNames: uniforms,\r\n            uniformBuffersNames: uniformBuffers,\r\n            samplers: samplers,\r\n            defines: defines,\r\n            maxSimultaneousLights: this._maxSimultaneousLights,\r\n        });\r\n\r\n        const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n        if (this.customShaderNameResolve) {\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n        }\r\n\r\n        const join = defines.toString();\r\n        const effect = engine.createEffect(\r\n            shaderName,\r\n            <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: onCompiled,\r\n                onError: onError,\r\n                indexParameters,\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                processCodeAfterIncludes: this._eventInfo.customCode,\r\n                multiTarget: defines.PREPASS,\r\n            },\r\n            engine\r\n        );\r\n\r\n        this._eventInfo.customCode = undefined;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _prepareDefines(\r\n        mesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null,\r\n        useThinInstances: boolean = false\r\n    ): void {\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        // Textures\r\n        defines.METALLICWORKFLOW = this.isMetallicWorkflow();\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                defines.ALBEDODIRECTUV = 0;\r\n                defines.AMBIENTDIRECTUV = 0;\r\n                defines.OPACITYDIRECTUV = 0;\r\n                defines.EMISSIVEDIRECTUV = 0;\r\n                defines.REFLECTIVITYDIRECTUV = 0;\r\n                defines.MICROSURFACEMAPDIRECTUV = 0;\r\n                defines.METALLIC_REFLECTANCEDIRECTUV = 0;\r\n                defines.REFLECTANCEDIRECTUV = 0;\r\n                defines.BUMPDIRECTUV = 0;\r\n                defines.LIGHTMAPDIRECTUV = 0;\r\n\r\n                if (engine.getCaps().textureLOD) {\r\n                    defines.LODBASEDMICROSFURACE = true;\r\n                }\r\n\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\r\n                    defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\r\n                } else {\r\n                    defines.ALBEDO = false;\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                    defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.REFLECTION = true;\r\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\r\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\r\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\r\n                    defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\r\n\r\n                    if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {\r\n                        defines.NUM_SAMPLES = \"\" + this.realTimeFilteringQuality;\r\n                        if (engine._features.needTypeSuffixInShaderConstants) {\r\n                            defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\r\n                        }\r\n\r\n                        defines.REALTIME_FILTERING = true;\r\n                    } else {\r\n                        defines.REALTIME_FILTERING = false;\r\n                    }\r\n\r\n                    defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\r\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\r\n\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n\r\n                    switch (reflectionTexture.coordinatesMode) {\r\n                        case Texture.EXPLICIT_MODE:\r\n                            defines.REFLECTIONMAP_EXPLICIT = true;\r\n                            break;\r\n                        case Texture.PLANAR_MODE:\r\n                            defines.REFLECTIONMAP_PLANAR = true;\r\n                            break;\r\n                        case Texture.PROJECTION_MODE:\r\n                            defines.REFLECTIONMAP_PROJECTION = true;\r\n                            break;\r\n                        case Texture.SKYBOX_MODE:\r\n                            defines.REFLECTIONMAP_SKYBOX = true;\r\n                            break;\r\n                        case Texture.SPHERICAL_MODE:\r\n                            defines.REFLECTIONMAP_SPHERICAL = true;\r\n                            break;\r\n                        case Texture.EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.CUBIC_MODE:\r\n                        case Texture.INVCUBIC_MODE:\r\n                        default:\r\n                            defines.REFLECTIONMAP_CUBIC = true;\r\n                            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>reflectionTexture).boundingBoxSize ? true : false;\r\n                            break;\r\n                    }\r\n\r\n                    if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n                        if (reflectionTexture.irradianceTexture) {\r\n                            defines.USEIRRADIANCEMAP = true;\r\n                            defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n                        }\r\n                        // Assume using spherical polynomial if the reflection texture is a cube map\r\n                        else if (reflectionTexture.isCube) {\r\n                            defines.USESPHERICALFROMREFLECTIONMAP = true;\r\n                            defines.USEIRRADIANCEMAP = false;\r\n                            if (this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8) {\r\n                                defines.USESPHERICALINVERTEX = false;\r\n                            } else {\r\n                                defines.USESPHERICALINVERTEX = true;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONMAP_3D = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n                    defines.INVERTCUBICMAP = false;\r\n                    defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n                    defines.USEIRRADIANCEMAP = false;\r\n                    defines.USESPHERICALINVERTEX = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                    defines.LODINREFLECTIONALPHA = false;\r\n                    defines.GAMMAREFLECTION = false;\r\n                    defines.RGBDREFLECTION = false;\r\n                    defines.LINEARSPECULARREFLECTION = false;\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                    defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                    defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\r\n                    defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\r\n                        defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\r\n                        defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\r\n                        defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\r\n                        defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\r\n                        defines.REFLECTIVITY_GAMMA = false;\r\n                    } else if (this._reflectivityTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\r\n                        defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\r\n                        defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\r\n                        defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;\r\n                    } else {\r\n                        defines.REFLECTIVITY = false;\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture || this._reflectanceTexture) {\r\n                        const identicalTextures =\r\n                            this._metallicReflectanceTexture !== null &&\r\n                            this._metallicReflectanceTexture._texture === this._reflectanceTexture?._texture &&\r\n                            this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);\r\n\r\n                        defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;\r\n                        if (this._metallicReflectanceTexture) {\r\n                            MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\r\n                            defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.METALLIC_REFLECTANCE = false;\r\n                        }\r\n                        if (\r\n                            this._reflectanceTexture &&\r\n                            !identicalTextures &&\r\n                            (!this._metallicReflectanceTexture || (this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture))\r\n                        ) {\r\n                            MaterialHelper.PrepareDefinesForMergedUV(this._reflectanceTexture, defines, \"REFLECTANCE\");\r\n                            defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.REFLECTANCE = false;\r\n                        }\r\n                    } else {\r\n                        defines.METALLIC_REFLECTANCE = false;\r\n                        defines.REFLECTANCE = false;\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\r\n                    } else {\r\n                        defines.MICROSURFACEMAP = false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTIVITY = false;\r\n                    defines.MICROSURFACEMAP = false;\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                    if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        defines.PARALLAX = true;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\r\n                    } else {\r\n                        defines.PARALLAX = false;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                    defines.OBJECTSPACE_NORMALMAP = false;\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.ENVIRONMENTBRDF = true;\r\n                    defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\r\n                } else {\r\n                    defines.ENVIRONMENTBRDF = false;\r\n                    defines.ENVIRONMENTBRDF_RGBD = false;\r\n                }\r\n\r\n                if (this._shouldUseAlphaFromAlbedoTexture()) {\r\n                    defines.ALPHAFROMALBEDO = true;\r\n                } else {\r\n                    defines.ALPHAFROMALBEDO = false;\r\n                }\r\n            }\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = true;\r\n            } else {\r\n                defines.USEPHYSICALLIGHTFALLOFF = true;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            }\r\n\r\n            defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\r\n\r\n            if (!this.backFaceCulling && this._twoSidedLighting) {\r\n                defines.TWOSIDEDLIGHTING = true;\r\n            } else {\r\n                defines.TWOSIDEDLIGHTING = false;\r\n            }\r\n\r\n            defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\r\n        }\r\n\r\n        if (defines._areTexturesDirty || defines._areMiscDirty) {\r\n            defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\r\n            defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\r\n            defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        defines.FORCENORMALFORWARD = this._forceNormalForward;\r\n\r\n        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\r\n\r\n        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            MaterialHelper.PrepareDefinesForMisc(\r\n                mesh,\r\n                scene,\r\n                this._useLogarithmicDepth,\r\n                this.pointsCloud,\r\n                this.fogEnabled,\r\n                this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest,\r\n                defines,\r\n                this._applyDecalMapAfterDetailMap\r\n            );\r\n            defines.UNLIT = this._unlit || ((this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n            defines.DEBUGMODE = this._debugMode;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh\r\n     * @param onCompiled\r\n     * @param options\r\n     */\r\n    public forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n        const defines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n        const effect = this._prepareEffect(mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances)!;\r\n        if (this._onEffectCreatedObservable) {\r\n            onCreatedEffectParameters.effect = effect;\r\n            onCreatedEffectParameters.subMesh = null;\r\n            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n        }\r\n        if (effect.isReady()) {\r\n            if (onCompiled) {\r\n                onCompiled(this);\r\n            }\r\n        } else {\r\n            effect.onCompileObservable.add(() => {\r\n                if (onCompiled) {\r\n                    onCompiled(this);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"vAlbedoInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 4);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vReflectivityInfos\", 3);\r\n        ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionFilteringInfo\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n        ubo.addUniform(\"albedoMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"reflectivityMatrix\", 16);\r\n        ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n\r\n        ubo.addUniform(\"vReflectionColor\", 3);\r\n        ubo.addUniform(\"vAlbedoColor\", 4);\r\n        ubo.addUniform(\"vLightingIntensity\", 4);\r\n\r\n        ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"vReflectivityColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"vAmbientColor\", 3);\r\n\r\n        ubo.addUniform(\"vDebugMode\", 2);\r\n\r\n        ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\r\n        ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\r\n        ubo.addUniform(\"metallicReflectanceMatrix\", 16);\r\n        ubo.addUniform(\"vReflectanceInfos\", 2);\r\n        ubo.addUniform(\"reflectanceMatrix\", 16);\r\n\r\n        ubo.addUniform(\"vSphericalL00\", 3);\r\n        ubo.addUniform(\"vSphericalL1_1\", 3);\r\n        ubo.addUniform(\"vSphericalL10\", 3);\r\n        ubo.addUniform(\"vSphericalL11\", 3);\r\n        ubo.addUniform(\"vSphericalL2_2\", 3);\r\n        ubo.addUniform(\"vSphericalL2_1\", 3);\r\n        ubo.addUniform(\"vSphericalL20\", 3);\r\n        ubo.addUniform(\"vSphericalL21\", 3);\r\n        ubo.addUniform(\"vSphericalL22\", 3);\r\n\r\n        ubo.addUniform(\"vSphericalX\", 3);\r\n        ubo.addUniform(\"vSphericalY\", 3);\r\n        ubo.addUniform(\"vSphericalZ\", 3);\r\n        ubo.addUniform(\"vSphericalXX_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalYY_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalZZ\", 3);\r\n        ubo.addUniform(\"vSphericalXY\", 3);\r\n        ubo.addUniform(\"vSphericalYZ\", 3);\r\n        ubo.addUniform(\"vSphericalZX\", 3);\r\n\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh data.\r\n     * @param world - The world matrix.\r\n     * @param mesh - The BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\r\n\r\n        let reflectionTexture: Nullable<BaseTexture> = null;\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            reflectionTexture = this._getReflectionTexture();\r\n\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\r\n                    }\r\n\r\n                    if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                        ubo.updateFloat4(\r\n                            \"vAmbientInfos\",\r\n                            this._ambientTexture.coordinatesIndex,\r\n                            this._ambientTexture.level,\r\n                            this._ambientTextureStrength,\r\n                            this._ambientTextureImpactOnAnalyticalLights\r\n                        );\r\n                        MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                        ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\r\n                        ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, 0);\r\n\r\n                        if ((<any>reflectionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>reflectionTexture;\r\n\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n\r\n                        if (this.realTimeFiltering) {\r\n                            const width = reflectionTexture.getSize().width;\r\n                            ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Scalar.Log2(width));\r\n                        }\r\n\r\n                        if (!defines.USEIRRADIANCEMAP) {\r\n                            const polynomials = reflectionTexture.sphericalPolynomial;\r\n                            if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n                                if (defines.SPHERICAL_HARMONICS) {\r\n                                    const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                                    ubo.updateVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                                    ubo.updateVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                                    ubo.updateVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                                    ubo.updateVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                                    ubo.updateVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                                    ubo.updateVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                                    ubo.updateVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                                    ubo.updateVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                                    ubo.updateVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n                                } else {\r\n                                    ubo.updateFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                                    ubo.updateFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                                    ubo.updateFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                                    ubo.updateFloat3(\r\n                                        \"vSphericalXX_ZZ\",\r\n                                        polynomials.xx.x - polynomials.zz.x,\r\n                                        polynomials.xx.y - polynomials.zz.y,\r\n                                        polynomials.xx.z - polynomials.zz.z\r\n                                    );\r\n                                    ubo.updateFloat3(\r\n                                        \"vSphericalYY_ZZ\",\r\n                                        polynomials.yy.x - polynomials.zz.x,\r\n                                        polynomials.yy.y - polynomials.zz.y,\r\n                                        polynomials.yy.z - polynomials.zz.z\r\n                                    );\r\n                                    ubo.updateFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                                    ubo.updateFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                                    ubo.updateFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                                    ubo.updateFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        ubo.updateFloat3(\r\n                            \"vReflectionMicrosurfaceInfos\",\r\n                            reflectionTexture.getSize().width,\r\n                            reflectionTexture.lodGenerationScale,\r\n                            reflectionTexture.lodGenerationOffset\r\n                        );\r\n                    }\r\n\r\n                    if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (MaterialFlags.SpecularTextureEnabled) {\r\n                        if (this._metallicTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\r\n                            MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\r\n                        } else if (this._reflectivityTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\r\n                            MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\r\n                        }\r\n\r\n                        if (this._metallicReflectanceTexture) {\r\n                            ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\r\n                            MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\r\n                        }\r\n\r\n                        if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                            ubo.updateFloat2(\"vReflectanceInfos\", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);\r\n                            MaterialHelper.BindTextureMatrix(this._reflectanceTexture, ubo, \"reflectance\");\r\n                        }\r\n\r\n                        if (this._microSurfaceTexture) {\r\n                            ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\r\n                            MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\r\n                        }\r\n                    }\r\n\r\n                    if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\r\n                        MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                // Colors\r\n                if (defines.METALLICWORKFLOW) {\r\n                    TmpColors.Color3[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\r\n                    TmpColors.Color3[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\r\n                    ubo.updateColor4(\"vReflectivityColor\", TmpColors.Color3[0], 1);\r\n\r\n                    const ior = this.subSurface?._indexOfRefraction ?? 1.5;\r\n                    const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\r\n\r\n                    // We are here deriving our default reflectance from a common value for none metallic surface.\r\n                    // Based of the schlick fresnel approximation model\r\n                    // for dielectrics.\r\n                    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\r\n\r\n                    // Tweak the default F0 and F90 based on our given setup\r\n                    this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);\r\n                    const metallicF90 = this._metallicF0Factor;\r\n\r\n                    ubo.updateColor4(\"vMetallicReflectanceFactors\", TmpColors.Color3[0], metallicF90);\r\n                } else {\r\n                    ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\r\n                }\r\n\r\n                ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\r\n                ubo.updateColor3(\"vReflectionColor\", this._reflectionColor);\r\n                if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\r\n                } else {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\r\n                }\r\n\r\n                // Misc\r\n                this._lightingInfos.x = this._directIntensity;\r\n                this._lightingInfos.y = this._emissiveIntensity;\r\n                this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\r\n                this._lightingInfos.w = this._specularIntensity;\r\n\r\n                ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\r\n\r\n                // Colors\r\n                scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\r\n\r\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n\r\n                ubo.updateFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    ubo.setTexture(\"albedoSampler\", this._albedoTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    ubo.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    ubo.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (defines.LODBASEDMICROSFURACE) {\r\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else {\r\n                        ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\r\n                        ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\r\n                        ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\r\n                    }\r\n\r\n                    if (defines.USEIRRADIANCEMAP) {\r\n                        ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\r\n                    }\r\n                }\r\n\r\n                if (defines.ENVIRONMENTBRDF) {\r\n                    ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\r\n                    } else if (this._reflectivityTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\r\n                    }\r\n\r\n                    if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                        ubo.setTexture(\"reflectanceSampler\", this._reflectanceTexture);\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    ubo.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if (\r\n                (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\r\n                reflectionTexture ||\r\n                this.subSurface.refractionTexture ||\r\n                mesh.receiveShadows ||\r\n                defines.PREPASS\r\n            ) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // image processing\r\n            this._imageProcessingConfiguration!.bind(this._activeEffect);\r\n\r\n            // Log. depth\r\n            MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\r\n            results.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\r\n            results.push(this._metallicTexture);\r\n        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\r\n            results.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {\r\n            results.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {\r\n            results.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {\r\n            results.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for reflections.\r\n     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\r\n     */\r\n    private _getReflectionTexture(): Nullable<BaseTexture> {\r\n        if (this._reflectionTexture) {\r\n            return this._reflectionTexture;\r\n        }\r\n\r\n        return this.getScene().environmentTexture;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @returns - Array of BaseTextures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._albedoTexture) {\r\n            activeTextures.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._reflectivityTexture) {\r\n            activeTextures.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._metallicTexture) {\r\n            activeTextures.push(this._metallicTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture) {\r\n            activeTextures.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture) {\r\n            activeTextures.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture) {\r\n            activeTextures.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._albedoTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectivityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._microSurfaceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * It can't be sets when subsurface scattering of this material is disabled.\r\n     * When scene have ability to enable subsurface prepass effect, it will enable.\r\n     */\r\n    public setPrePassRenderer(): boolean {\r\n        if (!this.subSurface?.isScatteringEnabled) {\r\n            return false;\r\n        }\r\n\r\n        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\r\n        if (subSurfaceConfiguration) {\r\n            subSurfaceConfiguration.enabled = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeEffect - Forces the disposal of effects.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\r\n                this._environmentBRDFTexture.dispose();\r\n            }\r\n\r\n            this._albedoTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._metallicTexture?.dispose();\r\n            this._reflectivityTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._metallicReflectanceTexture?.dispose();\r\n            this._reflectanceTexture?.dispose();\r\n            this._microSurfaceTexture?.dispose();\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n}\r\n", "import { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { ColorCurves } from \"../../Materials/colorCurves\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Material } from \"../material\";\r\n\r\n/**\r\n * The Physically based material of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n */\r\nexport class PBRMaterial extends PBRBaseMaterial {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureImpactOnAnalyticalLights: number = PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallic: Nullable<number>;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number>;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     */\r\n    @serializeAsColor3()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If useOnlyMetallicFromMetallicReflectanceTexture is true, don't use the RGB channels, only A\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both reflectanceTexture and metallicReflectanceTexture textures are provided and useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, metallicReflectanceTexture takes priority and reflectanceTexture is not used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurfaceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the refracted light information in a texture.\r\n     */\r\n    public get refractionTexture(): Nullable<BaseTexture> {\r\n        return this.subSurface.refractionTexture;\r\n    }\r\n    public set refractionTexture(value: Nullable<BaseTexture>) {\r\n        this.subSurface.refractionTexture = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        } else if (!this.subSurface.linkRefractionWithTransparency) {\r\n            this.subSurface.isRefractionEnabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"albedo\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"reflectivity\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color reflected from the material.\r\n     */\r\n    @serializeAsColor3(\"reflection\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionColor = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The color emitted from the material.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurface = 1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    public get indexOfRefraction(): number {\r\n        return this.subSurface.indexOfRefraction;\r\n    }\r\n    public set indexOfRefraction(value: number) {\r\n        this.subSurface.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    public get invertRefractionY(): boolean {\r\n        return this.subSurface.invertRefractionY;\r\n    }\r\n    public set invertRefractionY(value: boolean) {\r\n        this.subSurface.invertRefractionY = value;\r\n    }\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    public get linkRefractionWithTransparency(): boolean {\r\n        return this.subSurface.linkRefractionWithTransparency;\r\n    }\r\n    public set linkRefractionWithTransparency(value: boolean) {\r\n        this.subSurface.linkRefractionWithTransparency = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public forceAlphaTest = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    @serialize()\r\n    public get usePhysicalLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n    }\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    public set usePhysicalLightFalloff(value: boolean) {\r\n        if (value !== this.usePhysicalLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    @serialize()\r\n    public get useGLTFLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    public set useGLTFLightFalloff(value: boolean) {\r\n        if (value !== this.useGLTFLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceIrradianceInFragment = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Let user defines the brdf lookup texture used for IBL.\r\n     * A default 8bit version is embedded but you could point at :\r\n     * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png\r\n     * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png\r\n     * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap = false;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n    }\r\n\r\n    /**\r\n     * Returns the name of this material class.\r\n     */\r\n    public getClassName(): string {\r\n        return \"PBRMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name - name to use for the new material.\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     */\r\n    public clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): PBRMaterial {\r\n        const clone = SerializationHelper.Clone(() => new PBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        this.stencil.copyTo(clone.stencil);\r\n\r\n        this._clonePlugins(clone, rootUrl);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this PBR Material.\r\n     * @returns - An object with the serialized material.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.PBRMaterial\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Parses a PBR Material from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene - BJS scene instance.\r\n     * @param rootUrl - url for the scene object\r\n     * @returns - PBRMaterial\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): PBRMaterial {\r\n        const material = SerializationHelper.Parse(() => new PBRMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._parsePlugins(source, material, scene, rootUrl);\r\n\r\n        // The code block below ensures backward compatibility with serialized materials before plugins are automatically serialized.\r\n        if (source.clearCoat) {\r\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\r\n        }\r\n        if (source.anisotropy) {\r\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\r\n        }\r\n        if (source.brdf) {\r\n            material.brdf.parse(source.brdf, scene, rootUrl);\r\n        }\r\n        if (source.sheen) {\r\n            material.sheen.parse(source.sheen, scene, rootUrl);\r\n        }\r\n        if (source.subSurface) {\r\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\r\n        }\r\n        if (source.iridescence) {\r\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRMaterial\", PBRMaterial);\r\n", "import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number,\r\n            useSRGBBuffer?: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n", "import type { RawTexture } from \"../Textures/rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\n/**\r\n * Default settings for GreasedLine materials\r\n */\r\nexport class GreasedLineMaterialDefaults {\r\n    /**\r\n     * Default line color for newly created lines\r\n     */\r\n    public static DEFAULT_COLOR = Color3.White();\r\n    /**\r\n     * Default line width when sizeAttenuation is true\r\n     */\r\n    public static DEFAULT_WIDTH_ATTENUATED = 1;\r\n    /**\r\n     * Defaule line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n    /**\r\n     * Empty colors texture for WebGPU\r\n     */\r\n    public static EmptyColorsTexture: Nullable<RawTexture>;\r\n}\r\n", "import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\nimport type { GreasedLinePoints } from \"../Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Converts GreasedLinePoints to number[][]\r\n     * @param points GreasedLinePoints\r\n     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\r\n     */\r\n    public static ConvertPoints(points: GreasedLinePoints): number[][] {\r\n        if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\r\n            return [<number[]>points];\r\n        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\r\n            return <number[][]>points;\r\n        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\r\n            const positions: number[] = [];\r\n            for (let j = 0; j < points.length; j++) {\r\n                const p = points[j] as Vector3;\r\n                positions.push(p.x, p.y, p.z);\r\n            }\r\n            return [positions];\r\n        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\r\n            const positions: number[][] = [];\r\n            const vectorPoints = points as Vector3[][];\r\n            vectorPoints.forEach((p) => {\r\n                positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));\r\n            });\r\n            return positions;\r\n        } else if (points instanceof Float32Array) {\r\n            return [Array.from(points)];\r\n        } else if (points.length && points[0] instanceof Float32Array) {\r\n            const positions: number[][] = [];\r\n            points.forEach((p) => {\r\n                positions.push(Array.from(p as Float32Array));\r\n            });\r\n            return positions;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (p2.subtract(p1).lengthSquared() > 0) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (p3.subtract(p2).lengthSquared() > 0) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (p1.subtract(p3).lengthSquared() > 0) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    /**\r\n     * Omit duplicate lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitDuplicatesPredicate(p1: Vector3, p2: Vector3, p3: Vector3, points: Vector3[][]) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    private static _SearchInPoints(p1: Vector3, p2: Vector3, points: Vector3[][]) {\r\n        for (const ps of points) {\r\n            for (let i = 0; i < ps.length; i++) {\r\n                if (ps[i]?.equals(p1)) {\r\n                    // find the first point\r\n                    // if it has a sibling of p2 the line already exists\r\n                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            points: Vector3[][],\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[][]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        meshes.forEach((m, meshIndex) => {\r\n            const vertices = m.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = m.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);\r\n                        if (pointsFromPredicate) {\r\n                            for (const p of pointsFromPredicate) {\r\n                                points.push(p);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        points.push([p1, p2], [p2, p3], [p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[] | number[][]) {\r\n        if (Array.isArray(points[0])) {\r\n            const array: Vector3[][] = [];\r\n            const inputArray = points as number[][];\r\n            for (const subInputArray of inputArray) {\r\n                const subArray: Vector3[] = [];\r\n                for (let i = 0; i < subInputArray.length; i += 3) {\r\n                    subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\r\n                }\r\n                array.push(subArray);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        const inputArray = points as number[];\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < inputArray.length; i += 3) {\r\n            array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data) as Vector3[];\r\n        } else {\r\n            points = data as Vector3[];\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines =\r\n            what[0] instanceof Vector3\r\n                ? GreasedLineTools.GetLineSegments(what as Vector3[])\r\n                : typeof what[0] === \"number\"\r\n                  ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what as number[]) as Vector3[])\r\n                  : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        subLines.forEach((s) => {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                segments.forEach((seg) => {\r\n                    points.push(seg);\r\n                });\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        });\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[] | number[], segmentCount: number): Vector3[] {\r\n        const points = <Vector3[]>(typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(<number[]>what) : what);\r\n        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    public static Color3toRGBAUint8(colors: Color3[]) {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     */\r\n    public static CreateColorsTexture(name: string, colors: Color3[], colorsSampling: number, scene: Scene) {\r\n        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n        const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\r\n        colorsTexture.name = name;\r\n        return colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     * @returns empty colors texture\r\n     */\r\n    public static PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n\r\n        return GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Diposes the shared empty colors texture\r\n     */\r\n    public static DisposeEmptyColorsTexture() {\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    public static BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n}\r\n", "import type { RawTexture } from \"../Textures/rawTexture\";\r\nimport type { Vector2 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\n/**\r\n * Interface which defines the available methods for a GreasedLineMaterial\r\n */\r\nexport interface IGreasedLineMaterial {\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    visibility: number;\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    useDash: boolean;\r\n\r\n    /**\r\n     * @see GreasedLinePluginMaterial.setDashCount\r\n     * Number of dashes in the line.\r\n     * Defaults to 1.\r\n     */\r\n    dashCount: number;\r\n\r\n    /**\r\n     * Dash offset\r\n     */\r\n    dashOffset: number;\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    dashRatio: number;\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    useColors: boolean;\r\n\r\n    /**\r\n     * The mixing mode of the color paramater. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * MATERIAL_TYPE_STANDARD and MATERIAL_TYPE_PBR mixes the color from the base material with the color and/or colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    colorMode: GreasedLineMeshColorMode;\r\n\r\n    /**\r\n     * Colors of the line segments.\r\n     * Defaults to empty.\r\n     */\r\n    colors: Nullable<Color3[]>;\r\n\r\n    /**\r\n     * If false then width units = scene units. If true then line will width be reduced.\r\n     * Defaults to false.\r\n     */\r\n    sizeAttenuation: boolean;\r\n\r\n    /**\r\n     * Color of the line. Applies to all line segments.\r\n     * Defaults to White.\r\n     */\r\n    color: Nullable<Color3>;\r\n\r\n    /**\r\n     * The method used to distribute the colors along the line.\r\n     * You can use segment distribution when each segment will use on color from the color table.\r\n     * Or you can use line distribution when the colors are distributed evenly along the line ignoring the segments.\r\n     */\r\n    colorsDistributionType: GreasedLineMeshColorDistributionType;\r\n\r\n    /**\r\n     * Defaults to engine.getRenderWidth() and engine.getRenderHeight()\r\n     * Rendering resolution\r\n     */\r\n    resolution: Vector2;\r\n\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    colorsTexture: Nullable<RawTexture>;\r\n\r\n    /**\r\n     * Allows to change the color without marking the material dirty.\r\n     * MATERIAL_TYPE_STANDARD and MATERIAL_TYPE_PBR material's shaders will get recompiled if there was no color set and you set a color or when there was a color set and you set it to null.\r\n     * @param value the color\r\n     * @param doNotMarkDirty the flag\r\n     */\r\n    setColor(value: Nullable<Color3>, doNotMarkDirty?: boolean): void;\r\n\r\n    /**\r\n     *\r\n     * @param colors colors array\r\n     * @param lazy if true the colors texture will not be updated\r\n     * @param forceNewTexture forces to create a new colors texture\r\n     */\r\n    setColors(colors: Nullable<Color3[]>, lazy: boolean, forceNewTexture?: boolean): void;\r\n\r\n    /**\r\n     * Creates and sets the colors texture from the colors array which was created in lazy mode\r\n     */\r\n    updateLazy(): void;\r\n}\r\n\r\n/**\r\n * Material types for GreasedLine\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#materialtype}\r\n */\r\nexport enum GreasedLineMeshMaterialType {\r\n    /**\r\n     * StandardMaterial\r\n     */\r\n    MATERIAL_TYPE_STANDARD = 0,\r\n    /**\r\n     * PBR Material\r\n     */\r\n    MATERIAL_TYPE_PBR = 1,\r\n    /**\r\n     * Simple and fast shader material not supporting lightning nor textures\r\n     */\r\n    MATERIAL_TYPE_SIMPLE = 2,\r\n}\r\n\r\n/**\r\n * Color blending mode of the @see GreasedLineMaterial and the base material\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colormode}\r\n */\r\nexport enum GreasedLineMeshColorMode {\r\n    /**\r\n     * Color blending mode SET\r\n     */\r\n    COLOR_MODE_SET = 0,\r\n    /**\r\n     * Color blending mode ADD\r\n     */\r\n    COLOR_MODE_ADD = 1,\r\n    /**\r\n     * Color blending mode ADD\r\n     */\r\n    COLOR_MODE_MULTIPLY = 2,\r\n}\r\n\r\n/**\r\n * Color distribution type of the @see colors.\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colordistributiontype}\r\n *\r\n */\r\nexport enum GreasedLineMeshColorDistributionType {\r\n    /**\r\n     * Colors distributed between segments of the line\r\n     */\r\n    COLOR_DISTRIBUTION_TYPE_SEGMENT = 0,\r\n    /**\r\n     * Colors distributed along the line ingoring the segments\r\n     */\r\n    COLOR_DISTRIBUTION_TYPE_LINE = 1,\r\n}\r\n\r\n/**\r\n * Options for GreasedLineMaterial\r\n */\r\nexport interface GreasedLineMaterialOptions {\r\n    /**\r\n     * Line width. If sizeAttenuation os false scene units will be used for width.\r\n     * Defaults to 0.1 if @see sizeAttenuation is false, or to 1 if it's true.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * If false then width units = scene units. If true then line will width be reduced.\r\n     * Defaults to false.\r\n     */\r\n    sizeAttenuation?: boolean;\r\n    /**\r\n     * Type of the material to use to render the line.\r\n     * Defaults to StandardMaterial.\r\n     */\r\n    materialType?: GreasedLineMeshMaterialType;\r\n    /**\r\n     * Color of the line. Applies to all line segments.\r\n     * Defaults to White.\r\n     */\r\n    color?: Color3;\r\n    /**\r\n     * Color mode of the line. Applies to all line segments.\r\n     * The pixel color from the material shader will be modified with the value of @see color using the colorMode.\r\n     * Defaults to @see GreasedLineMeshColorMode.SET\r\n     */\r\n    colorMode?: GreasedLineMeshColorMode;\r\n    /**\r\n     * Colors of the line segments.\r\n     * Defaults to empty.\r\n     */\r\n    colors?: Color3[];\r\n    /**\r\n     * If true, @see colors are used, otherwise they're ignored.\r\n     * Defaults to false.\r\n     */\r\n    useColors?: boolean;\r\n    /**\r\n     * Sampling type of the colors texture\r\n     * Defaults to NEAREST_NEAREST.\r\n     */\r\n    colorsSampling?: number;\r\n    /**\r\n     * The method used to distribute the colors along the line.\r\n     * You can use segment distribution when each segment will use on color from the color table.\r\n     * Or you can use line distribution when the colors are distributed evenly along the line ignoring the segments.\r\n     */\r\n    colorDistributionType?: GreasedLineMeshColorDistributionType;\r\n    /**\r\n     * If true, dashing is used.\r\n     * Defaults to false.\r\n     */\r\n    useDash?: boolean;\r\n    /**\r\n     * @see GreasedLinePluginMaterial.setDashCount\r\n     * Number of dashes in the line.\r\n     * Defaults to 1.\r\n     */\r\n    dashCount?: number;\r\n    /**\r\n     * Offset of the dashes along the line. 0 to 1.\r\n     * Defaults to 0.\r\n     * @see GreasedLinePluginMaterial.setDashOffset\r\n     */\r\n    dashOffset?: number;\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     * Defaults to 0.5.\r\n     * @see GreasedLinePluginMaterial.setDashRatio\r\n     */\r\n    dashRatio?: number;\r\n    /**\r\n     * Sets the line length visibility.\r\n     * 0 - 0% of the line will be visible.\r\n     * 1 - 100% of the line will be visible.\r\n     * @see GreasedLinePluginMaterial.setVisibility\r\n     */\r\n    visibility?: number;\r\n    /**\r\n     * Defaults to engine.getRenderWidth() and engine.getRenderHeight()\r\n     * Rendering resolution\r\n     */\r\n    resolution?: Vector2;\r\n    /**\r\n     * Whether to use camera facing for the line.\r\n     * Defaults to true.\r\n     */\r\n    cameraFacing?: boolean;\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    colorsTexture?: RawTexture;\r\n}\r\n", "import type { Engine } from \"../../Engines/engine\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BaseTexture } from \"../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialGreasedLineDefines extends MaterialDefines {\r\n    /**\r\n     * The material has a color option specified\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_HAS_COLOR = false;\r\n    /**\r\n     * The material's size attenuation optiom\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_SIZE_ATTENUATION = false;\r\n    /**\r\n     * The type of color distribution is set to line this value equals to true.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\r\n    /**\r\n     * True if scene is in right handed coordinate system.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\r\n\r\n    /**\r\n     * True if the line is in camera facing mode\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_CAMERA_FACING = true;\r\n}\r\n\r\n/**\r\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\r\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\r\n */\r\nexport class GreasedLinePluginMaterial extends MaterialPluginBase implements IGreasedLineMaterial {\r\n    /**\r\n     * Plugin name\r\n     */\r\n    public static readonly GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    public useColors: boolean;\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    public visibility: number;\r\n\r\n    /**\r\n     * Dash offset\r\n     */\r\n    public dashOffset: number;\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    public dashRatio: number;\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    public width: number;\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    public colorsSampling: number;\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    public useDash: boolean;\r\n\r\n    /**\r\n     * The mixing mode of the color paramater. Default value is GreasedLineMeshColorMode.SET\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    public colorMode: GreasedLineMeshColorMode;\r\n\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    public colorsTexture: Nullable<RawTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _color: Nullable<Color3>;\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType;\r\n    private _resolution: Vector2;\r\n    private _aspect: number;\r\n    private _sizeAttenuation: boolean;\r\n\r\n    private _cameraFacing: boolean;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the GreasedLinePluginMaterial\r\n     * @param material base material for the plugin\r\n     * @param scene the scene\r\n     * @param options plugin options\r\n     */\r\n    constructor(material: Material, scene?: Scene, options?: GreasedLineMaterialOptions) {\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        const defines = new MaterialGreasedLineDefines();\r\n        defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;\r\n        super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines);\r\n\r\n        this._scene = scene ?? material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this._sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._color = options.color ?? null;\r\n        this.useColors = options.useColors ?? false;\r\n        this._colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this._colors = options.colors ?? null;\r\n\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\r\n            }\r\n        }\r\n\r\n        this._engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n\r\n        this._enable(true); // always enabled\r\n    }\r\n\r\n    /**\r\n     * Get the shader attributes\r\n     * @param attributes array which will be filled with the attributes\r\n     */\r\n    getAttributes(attributes: string[]) {\r\n        attributes.push(\"grl_offsets\");\r\n        attributes.push(\"grl_widths\");\r\n        attributes.push(\"grl_colorPointers\");\r\n        attributes.push(\"grl_counters\");\r\n        if (this._cameraFacing) {\r\n            attributes.push(\"grl_previousAndSide\");\r\n            attributes.push(\"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader samplers\r\n     * @param samplers\r\n     */\r\n    getSamplers(samplers: string[]) {\r\n        samplers.push(\"grl_colors\");\r\n    }\r\n\r\n    /**\r\n     * Get the shader textures\r\n     * @param activeTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this.colorsTexture) {\r\n            activeTextures.push(this.colorsTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader uniforms\r\n     * @returns uniforms\r\n     */\r\n    getUniforms() {\r\n        const ubo = [\r\n            { name: \"grl_singleColor\", size: 3, type: \"vec3\" },\r\n            { name: \"grl_dashOptions\", size: 4, type: \"vec4\" },\r\n            { name: \"grl_colorMode_visibility_colorsWidth_useColors\", size: 4, type: \"vec4\" },\r\n        ];\r\n        if (this._cameraFacing) {\r\n            ubo.push({ name: \"grl_projection\", size: 16, type: \"mat4\" }, { name: \"grl_aspect_resolution_lineWidth\", size: 4, type: \"vec4\" });\r\n        }\r\n\r\n        return {\r\n            ubo,\r\n            vertex: this._cameraFacing\r\n                ? `\r\n                uniform vec4 grl_aspect_resolution_lineWidth;\r\n                uniform mat4 grl_projection;\r\n                `\r\n                : \"\",\r\n            fragment: `\r\n                uniform vec4 grl_dashOptions;\r\n                uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\r\n                uniform vec3 grl_singleColor;\r\n                `,\r\n        };\r\n    }\r\n\r\n    // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\r\n    // and it doesn't make sense to disable it on the mesh\r\n    get isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind the uniform buffer\r\n     * @param uniformBuffer\r\n     */\r\n    bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        if (this._cameraFacing) {\r\n            const activeCamera = this._scene.activeCamera;\r\n\r\n            if (activeCamera) {\r\n                const projection = activeCamera.getProjectionMatrix();\r\n                uniformBuffer.updateMatrix(\"grl_projection\", projection);\r\n            } else {\r\n                throw Error(\"GreasedLinePluginMaterial requires an active camera.\");\r\n            }\r\n\r\n            const resolutionLineWidth = TmpVectors.Vector4[0];\r\n            resolutionLineWidth.x = this._aspect;\r\n            resolutionLineWidth.y = this._resolution.x;\r\n            resolutionLineWidth.z = this._resolution.y;\r\n            resolutionLineWidth.w = this.width;\r\n            uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\r\n        }\r\n\r\n        const dashOptions = TmpVectors.Vector4[0];\r\n        dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\r\n        dashOptions.y = this._dashArray;\r\n        dashOptions.z = this.dashOffset;\r\n        dashOptions.w = this.dashRatio;\r\n        uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\r\n\r\n        const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\r\n        colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\r\n        colorModeVisibilityColorsWidthUseColors.y = this.visibility;\r\n        colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\r\n        colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\r\n        uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\r\n\r\n        if (this._color) {\r\n            uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\r\n        }\r\n\r\n        uniformBuffer.setTexture(\"grl_colors\", this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture);\r\n    }\r\n\r\n    /**\r\n     * Prepare the defines\r\n     * @param defines\r\n     * @param _scene\r\n     * @param _mesh\r\n     */\r\n    prepareDefines(defines: MaterialGreasedLineDefines, _scene: Scene, _mesh: AbstractMesh) {\r\n        defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns class name\r\n     */\r\n    getClassName() {\r\n        return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\r\n    }\r\n\r\n    /**\r\n     * Get shader code\r\n     * @param shaderType vertex/fragment\r\n     * @returns shader code\r\n     */\r\n    getCustomCode(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            const obj: any = {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_DEFINITIONS: `\r\n                attribute float grl_widths;\r\n                attribute vec3 grl_offsets;\r\n                attribute float grl_colorPointers;\r\n\r\n                varying float grlCounters;\r\n                varying float grlColorPointer;\r\n\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n                    attribute vec4 grl_previousAndSide;\r\n                    attribute vec4 grl_nextAndCounters;\r\n\r\n                    vec2 grlFix( vec4 i, float aspect ) {\r\n                        vec2 res = i.xy / i.w;\r\n                        res.x *= aspect;\r\n                        return res;\r\n                    }\r\n                #else\r\n                    attribute vec3 grl_slopes;\r\n                    attribute float grl_counters;\r\n                #endif\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_UPDATE_POSITION: `\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n                    vec3 grlPositionOffset = grl_offsets;\r\n                    positionUpdated += grlPositionOffset;\r\n                #else\r\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\r\n                #endif\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_VERTEX_MAIN_END: `\r\n                grlColorPointer = grl_colorPointers;\r\n\r\n                #ifdef GREASED_LINE_CAMERA_FACING\r\n\r\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\r\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\r\n\r\n\r\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\r\n                    float grlSide = grl_previousAndSide.w;\r\n\r\n                    vec3 grlNext = grl_nextAndCounters.xyz;\r\n                    grlCounters = grl_nextAndCounters.w;\r\n\r\n                    mat4 grlMatrix = viewProjection * finalWorld;\r\n                    vec4 grlFinalPosition = grlMatrix * vec4( positionUpdated , 1.0 );\r\n                    vec4 grlPrevPos = grlMatrix * vec4( grlPrevious + grlPositionOffset, 1.0 );\r\n                    vec4 grlNextPos = grlMatrix * vec4( grlNext + grlPositionOffset, 1.0 );\r\n\r\n                    vec2 grlCurrentP = grlFix( grlFinalPosition, grlAspect );\r\n                    vec2 grlPrevP = grlFix( grlPrevPos, grlAspect );\r\n                    vec2 grlNextP = grlFix( grlNextPos, grlAspect );\r\n\r\n                    float grlWidth = grlBaseWidth * grl_widths;\r\n\r\n                    vec2 grlDir;\r\n                    if( grlNextP == grlCurrentP ) grlDir = normalize( grlCurrentP - grlPrevP );\r\n                    else if( grlPrevP == grlCurrentP ) grlDir = normalize( grlNextP - grlCurrentP );\r\n                    else {\r\n                        vec2 grlDir1 = normalize( grlCurrentP - grlPrevP );\r\n                        vec2 grlDir2 = normalize( grlNextP - grlCurrentP );\r\n                        grlDir = normalize( grlDir1 + grlDir2 );\r\n                    }\r\n                    vec4 grlNormal = vec4( -grlDir.y, grlDir.x, 0., 1. );\r\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\r\n                        grlNormal.xy *= -.5 * grlWidth;\r\n                    #else\r\n                        grlNormal.xy *= .5 * grlWidth;\r\n                    #endif\r\n\r\n                    grlNormal *= grl_projection;\r\n\r\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\r\n                        grlNormal.xy *= grlFinalPosition.w;\r\n                        grlNormal.xy /= ( vec4( grl_aspect_resolution_lineWidth.yz, 0., 1. ) * grl_projection ).xy;\r\n                    #endif\r\n\r\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\r\n                    gl_Position = grlFinalPosition;\r\n\r\n                    vPositionW = vec3(grlFinalPosition);\r\n                #else\r\n                    grlCounters = grl_counters;\r\n                #endif\r\n                `,\r\n            };\r\n            this._cameraFacing && (obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"); // not needed for camera facing GRL\r\n            return obj;\r\n        }\r\n\r\n        if (shaderType === \"fragment\") {\r\n            return {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                    varying float grlCounters;\r\n                    varying float grlColorPointer;\r\n                    uniform sampler2D grl_colors;\r\n                `,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_MAIN_END: `\r\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\r\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\r\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\r\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\r\n\r\n                    float grlUseDash = grl_dashOptions.x;\r\n                    float grlDashArray = grl_dashOptions.y;\r\n                    float grlDashOffset = grl_dashOptions.z;\r\n                    float grlDashRatio = grl_dashOptions.w;\r\n\r\n                    gl_FragColor.a *= step(grlCounters, grlVisibility);\r\n                    if( gl_FragColor.a == 0. ) discard;\r\n\r\n                    if(grlUseDash == 1.){\r\n                        gl_FragColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\r\n                        if (gl_FragColor.a == 0.) discard;\r\n                    }\r\n\r\n                    #ifdef GREASED_LINE_HAS_COLOR\r\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\r\n                            gl_FragColor.rgb = grl_singleColor;\r\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\r\n                            gl_FragColor.rgb += grl_singleColor;\r\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\r\n                            gl_FragColor.rgb *= grl_singleColor;\r\n                        }\r\n                    #else\r\n                        if (grlUseColors == 1.) {\r\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\r\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\r\n                            #else\r\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlColorPointer/grlColorsWidth, 0.), 0.);\r\n                            #endif\r\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\r\n                                gl_FragColor = grlColor;\r\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\r\n                                gl_FragColor += grlColor;\r\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\r\n                                gl_FragColor *= grlColor;\r\n                            }\r\n                        }\r\n                    #endif\r\n\r\n                `,\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public dispose(): void {\r\n        this.colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     * @returns\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this.colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this.colorsTexture.update(colorArray);\r\n        } else {\r\n            this.colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n    }\r\n\r\n    /**\r\n     * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     * Not supported for non camera facing lines.\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off size attenuation of the width option and widths array.\r\n     * Not supported for non camera facing lines.\r\n     * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\r\n     */\r\n    set color(value: Nullable<Color3>) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>, doNotMarkDirty = false) {\r\n        if ((this._color === null && value !== null) || (this._color !== null && value === null)) {\r\n            this._color = value;\r\n            !doNotMarkDirty && this.markAllDefinesAsDirty();\r\n        } else {\r\n            this._color = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._aspect = value.x / value.y;\r\n        this._resolution = value;\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this.colorsSampling,\r\n            colorMode: this.colorMode,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this.dashOffset,\r\n            dashRatio: this.dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this.useColors,\r\n            useDash: this.useDash,\r\n            visibility: this.visibility,\r\n            width: this.width,\r\n        };\r\n\r\n        this._colors && (greasedLineMaterialOptions.colors = this._colors);\r\n        this._color && (greasedLineMaterialOptions.color = this._color);\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this.colorsTexture?.dispose();\r\n\r\n        greasedLineMaterialOptions.color && this.setColor(greasedLineMaterialOptions.color, true);\r\n        greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\r\n        greasedLineMaterialOptions.colors && (this.colors = greasedLineMaterialOptions.colors);\r\n        greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\r\n        greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\r\n        greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\r\n        greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\r\n        greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\r\n        greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\r\n        greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\r\n        greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\r\n        greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\r\n        greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\r\n        greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\r\n\r\n        if (this.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\r\n        } else {\r\n            GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        const dest = plugin as GreasedLinePluginMaterial;\r\n\r\n        dest.colorsTexture?.dispose();\r\n\r\n        if (this._colors) {\r\n            dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\r\n        }\r\n\r\n        dest.setColor(this.color, true);\r\n        dest.colorsDistributionType = this.colorsDistributionType;\r\n        dest.colorsSampling = this.colorsSampling;\r\n        dest.colorMode = this.colorMode;\r\n        dest.useColors = this.useColors;\r\n        dest.visibility = this.visibility;\r\n        dest.useDash = this.useDash;\r\n        dest.dashCount = this.dashCount;\r\n        dest.dashRatio = this.dashRatio;\r\n        dest.dashOffset = this.dashOffset;\r\n        dest.width = this.width;\r\n        dest.sizeAttenuation = this.sizeAttenuation;\r\n        dest.resolution = this.resolution;\r\n\r\n        dest.markAllDefinesAsDirty();\r\n    }\r\n}\r\n\r\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"greasedLinePixelShader\";\nconst shader = `precision highp float;uniform sampler2D grlColors;uniform float grlUseColors;uniform float grlUseDash;uniform float grlDashArray;uniform float grlDashOffset;uniform float grlDashRatio;uniform float grlVisibility;uniform float grlColorsWidth;uniform vec2 grl_colorModeAndColorDistributionType;uniform vec3 grlColor;varying float grlCounters;varying float grlColorPointer;void main() {float grlColorMode=grl_colorModeAndColorDistributionType.x;float grlColorDistributionType=grl_colorModeAndColorDistributionType.y;gl_FragColor=vec4(grlColor,1.);gl_FragColor.a=step(grlCounters,grlVisibility);if (gl_FragColor.a==0.) discard;if( grlUseDash==1. ){gl_FragColor.a=ceil(mod(grlCounters+grlDashOffset,grlDashArray)-(grlDashArray*grlDashRatio));if (gl_FragColor.a==0.) discard;}\nif (grlUseColors==1.) {vec4 textureColor;if (grlColorDistributionType==COLOR_DISTRIBUTION_TYPE_LINE) { \ntextureColor=texture2D(grlColors,vec2(grlCounters,0.),0.);} else {textureColor=texture2D(grlColors,vec2(grlColorPointer/grlColorsWidth,0.),0.);}\nif (grlColorMode==COLOR_MODE_SET) {gl_FragColor=textureColor;} else if (grlColorMode==COLOR_MODE_ADD) {gl_FragColor+=textureColor;} else if (grlColorMode==COLOR_MODE_MULTIPLY) {gl_FragColor*=textureColor;}}}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const greasedLinePixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\n\nconst name = \"greasedLineVertexShader\";\nconst shader = `precision highp float;\n#include<instancesDeclaration>\nattribute float grl_widths;attribute vec3 grl_offsets;attribute float grl_colorPointers;attribute vec3 position;uniform mat4 viewProjection;uniform mat4 projection;varying float grlCounters;varying float grlColorPointer;\n#ifdef GREASED_LINE_CAMERA_FACING\nattribute vec4 grl_nextAndCounters;attribute vec4 grl_previousAndSide;uniform vec2 grlResolution;uniform float grlAspect;uniform float grlWidth;uniform float grlSizeAttenuation;vec2 grlFix( vec4 i,float aspect ) {vec2 res=i.xy/i.w;res.x*=aspect;return res;}\n#else\nattribute vec3 grl_slopes;attribute float grl_counters;\n#endif\nvoid main() {\n#include<instancesVertex>\ngrlColorPointer=grl_colorPointers;\n#ifdef GREASED_LINE_CAMERA_FACING\nfloat grlBaseWidth=grlWidth;vec3 grlPrevious=grl_previousAndSide.xyz;float grlSide=grl_previousAndSide.w;vec3 grlNext=grl_nextAndCounters.xyz;grlCounters=grl_nextAndCounters.w;mat4 grlMatrix=viewProjection*finalWorld ;vec3 grlPositionOffset=grl_offsets;vec4 grlFinalPosition=grlMatrix*vec4( position+grlPositionOffset ,1.0 );vec4 grlPrevPos=grlMatrix*vec4( grlPrevious+grlPositionOffset,1.0 );vec4 grlNextPos=grlMatrix*vec4( grlNext+grlPositionOffset,1.0 );vec2 grlCurrentP=grlFix( grlFinalPosition,grlAspect );vec2 grlPrevP=grlFix( grlPrevPos,grlAspect );vec2 grlNextP=grlFix( grlNextPos,grlAspect );float grlWidth=grlBaseWidth*grl_widths;vec2 grlDir;if( grlNextP==grlCurrentP ) grlDir=normalize( grlCurrentP-grlPrevP );else if( grlPrevP==grlCurrentP ) grlDir=normalize( grlNextP-grlCurrentP );else {vec2 grlDir1=normalize( grlCurrentP-grlPrevP );vec2 grlDir2=normalize( grlNextP-grlCurrentP );grlDir=normalize( grlDir1+grlDir2 );}\nvec4 grlNormal=vec4( -grlDir.y,grlDir.x,0.,1. );\n#ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\ngrlNormal.xy*=-.5*grlWidth;\n#else\ngrlNormal.xy*=.5*grlWidth;\n#endif\ngrlNormal*=projection;if (grlSizeAttenuation==1.) {grlNormal.xy*=grlFinalPosition.w;grlNormal.xy/=( vec4( grlResolution,0.,1. )*projection ).xy;}\ngrlFinalPosition.xy+=grlNormal.xy*grlSide;gl_Position=grlFinalPosition;\n#else\ngrlCounters=grl_counters;vec4 grlFinalPosition=worldViewProjection*vec4( (position+grl_offsets)+grl_slopes*grl_widths ,1.0 ) ;gl_Position=grlFinalPosition;\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const greasedLineVertexShader = { name, shader };\n", "import type { Scene } from \"../../scene\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\n\r\nimport { ShaderMaterial } from \"../shaderMaterial\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\n\r\nimport \"../../Shaders/greasedLine.fragment\";\r\nimport \"../../Shaders/greasedLine.vertex\";\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * GreasedLineSimpleMaterial\r\n */\r\nexport class GreasedLineSimpleMaterial extends ShaderMaterial implements IGreasedLineMaterial {\r\n    private _visibility: number;\r\n    private _width: number;\r\n    private _useDash: boolean;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _dashRatio: number;\r\n    private _dashOffset: number;\r\n    private _useColors: boolean;\r\n    private _color: Color3 = Color3.White();\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType = GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n    private _colorMode: GreasedLineMeshColorMode;\r\n    private _colorsSampling: number;\r\n    private _resolution: Vector2;\r\n    private _sizeAttenuation: boolean;\r\n    private _colorsTexture: Nullable<RawTexture> = null;\r\n    private _cameraFacing: boolean;\r\n\r\n    /**\r\n     * GreasedLineSimple material constructor\r\n     * @param name material name\r\n     * @param scene the scene\r\n     * @param options material options\r\n     */\r\n    constructor(name: string, scene: Scene, options: GreasedLineMaterialOptions) {\r\n        const defines = [\r\n            `COLOR_DISTRIBUTION_TYPE_LINE ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE}.`,\r\n            `COLOR_DISTRIBUTION_TYPE_SEGMENT ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT}.`,\r\n            `COLOR_MODE_SET ${GreasedLineMeshColorMode.COLOR_MODE_SET}.`,\r\n            `COLOR_MODE_ADD ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.`,\r\n            `COLOR_MODE_MULTIPLY ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.`,\r\n        ];\r\n        const attributes = [\"position\", \"grl_widths\", \"grl_offsets\", \"grl_colorPointers\"];\r\n\r\n        scene.useRightHandedSystem && defines.push(\"GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\");\r\n\r\n        if (options.cameraFacing) {\r\n            defines.push(\"GREASED_LINE_CAMERA_FACING\");\r\n            attributes.push(\"grl_previousAndSide\", \"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n            attributes.push(\"grl_counters\");\r\n        }\r\n\r\n        super(\r\n            name,\r\n            scene,\r\n            {\r\n                vertex: \"greasedLine\",\r\n                fragment: \"greasedLine\",\r\n            },\r\n            {\r\n                attributes,\r\n                uniforms: [\r\n                    \"world\",\r\n                    \"viewProjection\",\r\n                    \"view\",\r\n                    \"projection\",\r\n                    \"grlColorsWidth\",\r\n                    \"grlUseColors\",\r\n                    \"grlWidth\",\r\n                    \"grlColor\",\r\n                    \"grl_colorModeAndColorDistributionType\",\r\n                    \"grlResolution\",\r\n                    \"grlAspect\",\r\n                    \"grlAizeAttenuation\",\r\n                    \"grlDashArray\",\r\n                    \"grlDashOffset\",\r\n                    \"grlDashRatio\",\r\n                    \"grlUseDash\",\r\n                    \"grlVisibility\",\r\n                ],\r\n                samplers: [\"grlColors\"],\r\n                defines,\r\n            }\r\n        );\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.width = options.width\r\n            ? options.width\r\n            : options.sizeAttenuation && options.cameraFacing\r\n              ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED\r\n              : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this.sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.color = options.color ?? Color3.White();\r\n        this.useColors = options.useColors ?? false;\r\n        this.colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._colors = options.colors ?? null;\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n        this.resolution = options.resolution ?? new Vector2(engine.getRenderWidth(), engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture;\r\n        } else {\r\n            this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        if (this._colors) {\r\n            this.setColors(this._colors);\r\n        }\r\n\r\n        engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public dispose(): void {\r\n        this._colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    private _setColorModeAndColorDistributionType() {\r\n        this.setVector2(\"grl_colorModeAndColorDistributionType\", new Vector2(this._colorMode, this._colorsDistributionType));\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     * @returns\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this._colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this._colorsTexture.update(colorArray);\r\n        } else {\r\n            this._colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    get colorsTexture() {\r\n        return (this._colorsTexture as RawTexture) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Sets the colorsTexture\r\n     */\r\n    set colorsTexture(value: RawTexture) {\r\n        this._colorsTexture = value;\r\n        this.setFloat(\"grlColorsWidth\", this._colorsTexture.getSize().width);\r\n        this.setTexture(\"grlColors\", this._colorsTexture);\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this.setFloat(\"grlWidth\", value);\r\n    }\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    get useColors() {\r\n        return this._useColors;\r\n    }\r\n\r\n    set useColors(value: boolean) {\r\n        this._useColors = value;\r\n        this.setFloat(\"grlUseColors\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    get colorsSampling() {\r\n        return this._colorsSampling;\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    set colorsSampling(value: number) {\r\n        this._colorsSampling = value;\r\n    }\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    get visibility() {\r\n        return this._visibility;\r\n    }\r\n\r\n    set visibility(value: number) {\r\n        this._visibility = value;\r\n        this.setFloat(\"grlVisibility\", value);\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    get useDash() {\r\n        return this._useDash;\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    set useDash(value: boolean) {\r\n        this._useDash = value;\r\n        this.setFloat(\"grlUseDash\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the dash offset\r\n     */\r\n    get dashOffset() {\r\n        return this._dashOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the dash offset\r\n     */\r\n    set dashOffset(value: number) {\r\n        this._dashOffset = value;\r\n        this.setFloat(\"grlDashOffset\", value);\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    get dashRatio() {\r\n        return this._dashRatio;\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    set dashRatio(value: number) {\r\n        this._dashRatio = value;\r\n        this.setFloat(\"grlDashRatio\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n        this.setFloat(\"grlDashArray\", this._dashArray);\r\n    }\r\n\r\n    /**\r\n     * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off attenuation of the width option and widths array.\r\n     * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.setFloat(\"grlSizeAttenuation\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this.color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3\r\n     */\r\n    set color(value: Color3) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>) {\r\n        value = value ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n        this._color = value;\r\n        this.setColor3(\"grlColor\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    get colorMode() {\r\n        return this._colorMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    set colorMode(value: GreasedLineMeshColorMode) {\r\n        this._colorMode = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._resolution = value;\r\n        this.setVector2(\"grlResolution\", value);\r\n        this.setFloat(\"grlAspect\", value.x / value.y);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this._colorsSampling,\r\n            colorMode: this._colorMode,\r\n            color: this._color,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this._dashOffset,\r\n            dashRatio: this._dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this._useColors,\r\n            useDash: this._useDash,\r\n            visibility: this._visibility,\r\n            width: this._width,\r\n            cameraFacing: this._cameraFacing,\r\n        };\r\n\r\n        this._colors && (greasedLineMaterialOptions.colors = this._colors);\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param _rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, _rootUrl: string): void {\r\n        // TODO: super.parse?\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this._colorsTexture?.dispose();\r\n\r\n        greasedLineMaterialOptions.color && (this.color = greasedLineMaterialOptions.color);\r\n        greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\r\n        greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\r\n        greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\r\n        greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\r\n        greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\r\n        greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\r\n        greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\r\n        greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\r\n        greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\r\n        greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\r\n        greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\r\n        greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\r\n\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());\r\n        } else {\r\n            this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this._cameraFacing = greasedLineMaterialOptions.cameraFacing ?? true;\r\n        this.setDefine(\"GREASED_LINE_CAMERA_FACING\", this._cameraFacing);\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { IGreasedLineMaterial } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n\r\n/**\r\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\r\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\r\n */\r\nexport enum GreasedLineRibbonPointsMode {\r\n    POINTS_MODE_POINTS = 0,\r\n    POINTS_MODE_PATHS = 1,\r\n}\r\n\r\n/**\r\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\r\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\r\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\r\n */\r\nexport enum GreasedLineRibbonFacesMode {\r\n    FACES_MODE_SINGLE_SIDED = 0,\r\n    FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = 1,\r\n    FACES_MODE_DOUBLE_SIDED = 2,\r\n}\r\n\r\n/**\r\n * Only with POINTS_MODE_PATHS.\r\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\r\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\r\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\r\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\r\n */\r\nexport enum GreasedLineRibbonAutoDirectionMode {\r\n    AUTO_DIRECTIONS_FROM_FIRST_SEGMENT = 0,\r\n    AUTO_DIRECTIONS_FROM_ALL_SEGMENTS = 1,\r\n    AUTO_DIRECTIONS_ENHANCED = 2,\r\n    AUTO_DIRECTIONS_NONE = 99,\r\n}\r\n\r\nexport type GreasedLineRibbonOptions = {\r\n    /**\r\n     * Defines how the points are processed.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_POINTS every array of points will become the center of the ribbon. The ribbon will be expanded by width/2 to +direction and -direction as well.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_PATHS every array of points is one path. These will be used to buuid one ribbon.\r\n     */\r\n    pointsMode?: GreasedLineRibbonPointsMode;\r\n    /**\r\n     * Normalized directions of the slopes of the non camera facing lines.\r\n     */\r\n    directions?: Vector3[] | Vector3;\r\n    /**\r\n     * Defines the calculation mode of the directions which the line will be thickened to.\r\n     */\r\n    directionsAutoMode?: GreasedLineRibbonAutoDirectionMode;\r\n    /**\r\n     * Width of the ribbon.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Controls how the faces are created.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED = single sided with back face culling. Default value.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = single sided without back face culling\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED = extra back faces are created. This doubles the amount of faces of the mesh.\r\n     */\r\n    facesMode?: GreasedLineRibbonFacesMode;\r\n    /**\r\n     * If true, the path will be closed.\r\n     */\r\n    closePath?: boolean;\r\n    /**\r\n     * If true, normals will be computed when creating the vertex buffers.\r\n     * This results to smooth shading of the mesh.\r\n     */\r\n    smoothShading?: boolean;\r\n};\r\n\r\nexport type GreasedLinePoints = Vector3[] | Vector3[][] | Float32Array | Float32Array[] | number[][] | number[];\r\n\r\n/**\r\n * Options for creating a GreasedLineMesh\r\n */\r\nexport interface GreasedLineMeshOptions {\r\n    /**\r\n     * Points of the line.\r\n     */\r\n    points: GreasedLinePoints;\r\n    /**\r\n     * Each line segmment (from point to point) can have it's width multiplier. Final width = widths[segmentIdx] * width.\r\n     * Defaults to empty array.\r\n     */\r\n    widths?: number[];\r\n    /**\r\n     * If instance is specified, lines are added to the specified instance.\r\n     * Defaults to undefined.\r\n     */\r\n    instance?: GreasedLineBaseMesh;\r\n    /**\r\n     * You can manually set the color pointers so you can control which segment/part\r\n     * will use which color from the colors material option\r\n     */\r\n    colorPointers?: number[];\r\n    /**\r\n     * UVs for the mesh\r\n     */\r\n    uvs?: number[];\r\n    /**\r\n     * If true, offsets and widths are updatable.\r\n     * Defaults to false.\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * Use when @see instance is specified.\r\n     * If true, the line will be rendered only after calling instance.updateLazy(). If false, line will be rerendered after every call to @see CreateGreasedLine\r\n     * Defaults to false.\r\n     */\r\n    lazy?: boolean;\r\n    /**\r\n     * The options for the ribbon which will be used as a line.\r\n     * If this option is set the line switches automatically to a non camera facing mode.\r\n     */\r\n    ribbonOptions?: GreasedLineRibbonOptions;\r\n}\r\n\r\n/**\r\n * GreasedLineBaseMesh\r\n */\r\nexport abstract class GreasedLineBaseMesh extends Mesh {\r\n    protected _vertexPositions: number[];\r\n    protected _indices: number[];\r\n    protected _uvs: number[];\r\n    protected _points: number[][];\r\n    protected _offsets: number[];\r\n    protected _colorPointers: number[];\r\n    protected _widths: number[];\r\n\r\n    protected _offsetsBuffer?: Buffer;\r\n    protected _widthsBuffer?: Buffer;\r\n    protected _colorPointersBuffer?: Buffer;\r\n\r\n    protected _lazy = false;\r\n    protected _updatable = false;\r\n\r\n    protected _engine: Engine;\r\n\r\n    constructor(\r\n        public readonly name: string,\r\n        scene: Scene,\r\n        protected _options: GreasedLineMeshOptions\r\n    ) {\r\n        super(name, scene, null, null, false, false);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        this._lazy = _options.lazy ?? false;\r\n        this._updatable = _options.updatable ?? false;\r\n\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n        this._points = [];\r\n        this._colorPointers = _options.colorPointers ?? [];\r\n        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected abstract _setPoints(points: number[][], options?: GreasedLineMeshOptions): void;\r\n    protected abstract _updateColorPointers(): void;\r\n    protected abstract _updateWidths(): void;\r\n\r\n    protected _updateWidthsWithValue(defaulValue: number) {\r\n        let pointCount = 0;\r\n        for (const points of this._points) {\r\n            pointCount += points.length;\r\n        }\r\n        const countDiff = (pointCount / 3) * 2 - this._widths.length;\r\n        for (let i = 0; i < countDiff; i++) {\r\n            this._widths.push(defaulValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updated a lazy line. Rerenders the line and updates boundinfo as well.\r\n     */\r\n    public updateLazy() {\r\n        this._setPoints(this._points);\r\n        if (!this._options.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n        this.refreshBoundingInfo();\r\n\r\n        this.greasedLineMaterial?.updateLazy();\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     */\r\n    public addPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        for (const p of points) {\r\n            this._points.push(p);\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this.setPoints(this._points, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the line and it's resources\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns true if the mesh was created in lazy mode\r\n     */\r\n    public isLazy(): boolean {\r\n        return this._lazy;\r\n    }\r\n\r\n    /**\r\n     * Return the points offsets\r\n     */\r\n    get offsets() {\r\n        return this._offsets;\r\n    }\r\n\r\n    /**\r\n     * Sets point offests\r\n     * @param offsets offset table [x,y,z, x,y,z, ....]\r\n     */\r\n    set offsets(offsets: number[]) {\r\n        this._offsets = offsets;\r\n        if (!this._offsetsBuffer) {\r\n            this._createOffsetsBuffer(offsets);\r\n        } else {\r\n            this._offsetsBuffer.update(offsets);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\r\n     */\r\n    get widths() {\r\n        return this._widths;\r\n    }\r\n\r\n    /**\r\n     * Sets widths at each line point\r\n     * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\r\n     */\r\n    set widths(widths: number[]) {\r\n        this._widths = widths;\r\n        if (!this._lazy) {\r\n            this._widthsBuffer && this._widthsBuffer.update(widths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\r\n     */\r\n    get colorPointers() {\r\n        return this._colorPointers;\r\n    }\r\n\r\n    /**\r\n     * Sets the color pointer\r\n     * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\r\n     */\r\n    set colorPointers(colorPointers: number[]) {\r\n        this._colorPointers = colorPointers;\r\n        if (!this._lazy) {\r\n            this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the pluginMaterial associated with line\r\n     */\r\n    get greasedLineMaterial(): IGreasedLineMaterial | undefined {\r\n        if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\r\n            return this.material;\r\n        }\r\n        const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\r\n        if (materialPlugin) {\r\n            return <GreasedLinePluginMaterial>materialPlugin;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Return copy the points.\r\n     */\r\n    get points() {\r\n        const pointsCopy: number[][] = [];\r\n        DeepCopier.DeepCopy(this._points, pointsCopy);\r\n        return pointsCopy;\r\n    }\r\n\r\n    /**\r\n     * Sets line points and rerenders the line.\r\n     * @param points points table\r\n     */\r\n    public setPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        this._points = points;\r\n        this._updateWidths();\r\n        if (!options?.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._setPoints(points, options);\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n    }\r\n\r\n    protected _createLineOptions() {\r\n        const lineOptions: GreasedLineMeshOptions = {\r\n            points: this._points,\r\n            colorPointers: this._colorPointers,\r\n            lazy: this._lazy,\r\n            updatable: this._updatable,\r\n            uvs: this._uvs,\r\n            widths: this._widths,\r\n            ribbonOptions: this._options.ribbonOptions,\r\n        };\r\n        return lineOptions;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    protected _createVertexBuffers(computeNormals = false) {\r\n        const vertexData = new VertexData();\r\n        vertexData.positions = this._vertexPositions;\r\n        vertexData.indices = this._indices;\r\n        vertexData.uvs = this._uvs;\r\n        if (computeNormals) {\r\n            vertexData.normals = [];\r\n            VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\r\n        }\r\n        vertexData.applyToMesh(this, this._options.updatable);\r\n        return vertexData;\r\n    }\r\n\r\n    protected _createOffsetsBuffer(offsets: number[]) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\r\n        this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\r\n        this._offsetsBuffer = offsetBuffer;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Ray, TrianglePickingPredicate } from \"../../Culling/ray\";\r\nimport { Buffer, VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions } from \"./greasedLineBaseMesh\";\r\nimport { GreasedLineBaseMesh } from \"./greasedLineBaseMesh\";\r\n\r\nMesh._GreasedLineMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GreasedLineMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * GreasedLineMesh\r\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\r\n */\r\nexport class GreasedLineMesh extends GreasedLineBaseMesh {\r\n    private _previousAndSide: number[];\r\n    private _nextAndCounters: number[];\r\n\r\n    private static _V_START = new Vector3();\r\n    private static _V_END = new Vector3();\r\n    private static _V_OFFSET_START = new Vector3();\r\n    private static _V_OFFSET_END = new Vector3();\r\n\r\n    /**\r\n     * Treshold used to pick the mesh\r\n     */\r\n    public intersectionThreshold = 0.1;\r\n\r\n    /**\r\n     * GreasedLineMesh\r\n     * @param name name of the mesh\r\n     * @param scene the scene\r\n     * @param _options mesh options\r\n     */\r\n    constructor(\r\n        public readonly name: string,\r\n        scene: Scene,\r\n        _options: GreasedLineMeshOptions\r\n    ) {\r\n        super(name, scene, _options);\r\n\r\n        this._previousAndSide = [];\r\n        this._nextAndCounters = [];\r\n\r\n        if (_options.points) {\r\n            this.addPoints(GreasedLineTools.ConvertPoints(_options.points));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected _updateColorPointers() {\r\n        if (this._options.colorPointers) {\r\n            return;\r\n        }\r\n\r\n        let colorPointer = 0;\r\n        this._colorPointers = [];\r\n        this._points.forEach((p) => {\r\n            for (let jj = 0; jj < p.length; jj += 3) {\r\n                this._colorPointers.push(colorPointer);\r\n                this._colorPointers.push(colorPointer++);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _updateWidths(): void {\r\n        super._updateWidthsWithValue(0);\r\n    }\r\n\r\n    protected _setPoints(points: number[][]) {\r\n        this._points = points;\r\n        this._options.points = points;\r\n\r\n        this._initGreasedLine();\r\n\r\n        let indiceOffset = 0;\r\n\r\n        points.forEach((p) => {\r\n            const counters: number[] = [];\r\n            const positions: number[] = [];\r\n            const indices: number[] = [];\r\n\r\n            const totalLength = GreasedLineTools.GetLineLength(p);\r\n            for (let j = 0, jj = 0; jj < p.length; j++, jj += 3) {\r\n                const partialLine = p.slice(0, jj + 3);\r\n                const partialLineLength = GreasedLineTools.GetLineLength(partialLine);\r\n                const c = partialLineLength / totalLength;\r\n\r\n                positions.push(p[jj], p[jj + 1], p[jj + 2]);\r\n                positions.push(p[jj], p[jj + 1], p[jj + 2]);\r\n                counters.push(c);\r\n                counters.push(c);\r\n\r\n                if (jj < p.length - 3) {\r\n                    const n = j * 2 + indiceOffset;\r\n                    indices.push(n, n + 1, n + 2);\r\n                    indices.push(n + 2, n + 1, n + 3);\r\n                }\r\n            }\r\n\r\n            indiceOffset += (p.length / 3) * 2;\r\n\r\n            const previous: number[] = [];\r\n            const next: number[] = [];\r\n            const side: number[] = [];\r\n            let uvs: number[] = [];\r\n\r\n            this._preprocess(positions, previous, next, side, uvs);\r\n\r\n            for (const vp of positions) {\r\n                this._vertexPositions.push(vp);\r\n            }\r\n\r\n            for (const i of indices) {\r\n                this._indices.push(i);\r\n            }\r\n\r\n            for (let i = 0; i < side.length; i++) {\r\n                this._previousAndSide.push(previous[i * 3], previous[i * 3 + 1], previous[i * 3 + 2], side[i]);\r\n                this._nextAndCounters.push(next[i * 3], next[i * 3 + 1], next[i * 3 + 2], counters[i]);\r\n            }\r\n\r\n            uvs = this._options.uvs ?? uvs;\r\n            for (const uv of uvs) {\r\n                this._uvs.push(uv);\r\n            }\r\n        });\r\n\r\n        if (!this._lazy) {\r\n            if (!this._options.colorPointers) {\r\n                this._updateColorPointers();\r\n            }\r\n            this._createVertexBuffers();\r\n            this.refreshBoundingInfo();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the GreasedLineMesh.\r\n     * @param name new line name\r\n     * @param newParent new parent node\r\n     * @returns cloned line\r\n     */\r\n    public clone(name: string = `${this.name}-cloned`, newParent?: Nullable<Node>) {\r\n        const lineOptions = this._createLineOptions();\r\n        const deepCopiedLineOptions = {};\r\n        DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"], undefined, true);\r\n\r\n        const cloned = new GreasedLineMesh(name, this._scene, <GreasedLineMeshOptions>deepCopiedLineOptions);\r\n        if (newParent) {\r\n            cloned.parent = newParent;\r\n        }\r\n\r\n        cloned.material = this.material;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized GreasedLineMesh\r\n     * @param parsedMesh the serialized GreasedLineMesh\r\n     * @param scene the scene to create the GreasedLineMesh in\r\n     * @returns the created GreasedLineMesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): Mesh {\r\n        const lineOptions = <GreasedLineMeshOptions>parsedMesh.lineOptions;\r\n        const name = <string>parsedMesh.name;\r\n        const result = new GreasedLineMesh(name, scene, lineOptions);\r\n        return result;\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        super._initGreasedLine();\r\n\r\n        this._previousAndSide = [];\r\n        this._nextAndCounters = [];\r\n    }\r\n    /**\r\n     * Checks whether a ray is intersecting this GreasedLineMesh\r\n     * @param ray ray to check the intersection of this mesh with\r\n     * @param fastCheck not supported\r\n     * @param trianglePredicate not supported\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse not supported\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     */\r\n    public intersects(\r\n        ray: Ray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const pickingInfo = new PickingInfo();\r\n        const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);\r\n        if (intersections?.length === 1) {\r\n            const intersection = intersections[0];\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = intersection.distance;\r\n            pickingInfo.ray = ray;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.pickedPoint = intersection.point;\r\n        }\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Gets all intersections of a ray and the line\r\n     * @param ray Ray to check the intersection of this mesh with\r\n     * @param _fastCheck not supported\r\n     * @param _trianglePredicate not supported\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param _worldToUse not supported\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @param firstOnly If true, the first and only intersection is immediatelly returned if found\r\n     * @returns intersection(s)\r\n     */\r\n    public findAllIntersections(\r\n        ray: Ray,\r\n        _fastCheck?: boolean,\r\n        _trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        _worldToUse?: Matrix,\r\n        skipBoundingInfo = false,\r\n        firstOnly = false\r\n    ): { distance: number; point: Vector3 }[] | undefined {\r\n        if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {\r\n            return;\r\n        }\r\n\r\n        const indices = this.getIndices();\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const widths = this._widths;\r\n\r\n        const lineWidth = this.greasedLineMaterial?.width ?? 1;\r\n\r\n        const intersects = [];\r\n        if (indices && positions && widths) {\r\n            let i = 0,\r\n                l = 0;\r\n            for (i = 0, l = indices.length - 1; i < l; i += 3) {\r\n                const a = indices[i];\r\n                const b = indices[i + 1];\r\n\r\n                GreasedLineMesh._V_START.fromArray(positions, a * 3);\r\n                GreasedLineMesh._V_END.fromArray(positions, b * 3);\r\n\r\n                if (this._offsets) {\r\n                    GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);\r\n                    GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);\r\n                    GreasedLineMesh._V_START.addInPlace(GreasedLineMesh._V_OFFSET_START);\r\n                    GreasedLineMesh._V_END.addInPlace(GreasedLineMesh._V_OFFSET_END);\r\n                }\r\n\r\n                const iFloored = Math.floor(i / 3);\r\n                const width = widths[iFloored] !== undefined ? widths[iFloored] : 1;\r\n                const precision = (this.intersectionThreshold * (lineWidth * width)) / 2;\r\n\r\n                const distance = ray.intersectionSegment(GreasedLineMesh._V_START, GreasedLineMesh._V_END, precision);\r\n                if (distance !== -1) {\r\n                    intersects.push({\r\n                        distance: distance,\r\n                        point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin),\r\n                    });\r\n                    if (firstOnly) {\r\n                        return intersects;\r\n                    }\r\n                }\r\n            }\r\n            i = l;\r\n        }\r\n\r\n        return intersects;\r\n    }\r\n\r\n    private get _boundingSphere() {\r\n        return this.getBoundingInfo().boundingSphere;\r\n    }\r\n\r\n    private static _CompareV3(positionIdx1: number, positionIdx2: number, positions: number[]) {\r\n        const arrayIdx1 = positionIdx1 * 6;\r\n        const arrayIdx2 = positionIdx2 * 6;\r\n        return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];\r\n    }\r\n\r\n    private static _CopyV3(positionIdx: number, positions: number[]) {\r\n        const arrayIdx = positionIdx * 6;\r\n        return [positions[arrayIdx], positions[arrayIdx + 1], positions[arrayIdx + 2]];\r\n    }\r\n\r\n    private _preprocess(positions: number[], previous: number[], next: number[], side: number[], uvs: number[]) {\r\n        const l = positions.length / 6;\r\n\r\n        let v: number[] = [];\r\n\r\n        if (GreasedLineMesh._CompareV3(0, l - 1, positions)) {\r\n            v = GreasedLineMesh._CopyV3(l - 2, positions);\r\n        } else {\r\n            v = GreasedLineMesh._CopyV3(0, positions);\r\n        }\r\n        previous.push(v[0], v[1], v[2]);\r\n        previous.push(v[0], v[1], v[2]);\r\n\r\n        for (let j = 0; j < l; j++) {\r\n            side.push(1);\r\n            side.push(-1);\r\n\r\n            // uvs\r\n            if (!this._options.uvs) {\r\n                uvs.push(j / (l - 1), 0);\r\n                uvs.push(j / (l - 1), 1);\r\n            }\r\n\r\n            if (j < l - 1) {\r\n                v = GreasedLineMesh._CopyV3(j, positions);\r\n                previous.push(v[0], v[1], v[2]);\r\n                previous.push(v[0], v[1], v[2]);\r\n            }\r\n            if (j > 0) {\r\n                v = GreasedLineMesh._CopyV3(j, positions);\r\n                next.push(v[0], v[1], v[2]);\r\n                next.push(v[0], v[1], v[2]);\r\n            }\r\n        }\r\n\r\n        if (GreasedLineMesh._CompareV3(l - 1, 0, positions)) {\r\n            v = GreasedLineMesh._CopyV3(1, positions);\r\n        } else {\r\n            v = GreasedLineMesh._CopyV3(l - 1, positions);\r\n        }\r\n        next.push(v[0], v[1], v[2]);\r\n        next.push(v[0], v[1], v[2]);\r\n\r\n        return {\r\n            previous,\r\n            next,\r\n            uvs,\r\n            side,\r\n        };\r\n    }\r\n\r\n    protected _createVertexBuffers() {\r\n        const vertexData = super._createVertexBuffers();\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        const previousAndSideBuffer = new Buffer(engine, this._previousAndSide, false, 4);\r\n        this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer(\"grl_previousAndSide\", 0, 4));\r\n\r\n        const nextAndCountersBuffer = new Buffer(engine, this._nextAndCounters, false, 4);\r\n        this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer(\"grl_nextAndCounters\", 0, 4));\r\n\r\n        const widthBuffer = new Buffer(engine, this._widths, this._updatable, 1);\r\n        this.setVerticesBuffer(widthBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\r\n        this._widthsBuffer = widthBuffer;\r\n\r\n        const colorPointersBuffer = new Buffer(engine, this._colorPointers, this._updatable, 1);\r\n        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\r\n        this._colorPointersBuffer = colorPointersBuffer;\r\n\r\n        return vertexData;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Node } from \"../../node\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions, GreasedLineRibbonOptions } from \"./greasedLineBaseMesh\";\r\nimport { GreasedLineBaseMesh, GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"./greasedLineBaseMesh\";\r\n\r\nMesh._GreasedLineRibbonMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GreasedLineRibbonMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * GreasedLineRibbonMesh\r\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\r\n */\r\nexport class GreasedLineRibbonMesh extends GreasedLineBaseMesh {\r\n    /**\r\n     * Default line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n\r\n    private static _RightHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.RightHandedForwardReadOnly, Math.PI / 2);\r\n    private static _LeftHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftHandedForwardReadOnly, Math.PI / 2);\r\n    private static _LeftReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftReadOnly, Math.PI / 2);\r\n\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the XY plane\r\n     */\r\n    public static DIRECTION_XY = Vector3.LeftHandedForwardReadOnly; // doesn't matter in which handed system the scene operates\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the XZ plane\r\n     */\r\n    public static DIRECTION_XZ = Vector3.UpReadOnly;\r\n    /**\r\n     * Direction which the line segment will be thickened if drawn on the YZ plane\r\n     */\r\n    public static DIRECTION_YZ = Vector3.LeftReadOnly;\r\n\r\n    private _paths: Vector3[][];\r\n    private _pathsOptions: { options: GreasedLineMeshOptions; pathCount: number }[];\r\n    private _vSegmentLengths: number[][];\r\n    private _uSegmentLengths: number[][];\r\n    private _vTotalLengths: number[];\r\n    private _uTotalLengths: number[];\r\n\r\n    private _counters: number[];\r\n    private _slopes: number[];\r\n    private _ribbonWidths: number[];\r\n\r\n    /**\r\n     * GreasedLineRibbonMesh\r\n     * @param name name of the mesh\r\n     * @param scene the scene\r\n     * @param _options mesh options\r\n     * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh\r\n     */\r\n    constructor(\r\n        public readonly name: string,\r\n        scene: Scene,\r\n        _options: GreasedLineMeshOptions,\r\n        _pathOptions?: { options: GreasedLineMeshOptions; pathCount: number }[]\r\n    ) {\r\n        super(name, scene, _options);\r\n\r\n        if (!_options.ribbonOptions) {\r\n            throw \"'GreasedLineMeshOptions.ribbonOptions' is not set.\";\r\n        }\r\n\r\n        this._paths = [];\r\n        this._counters = [];\r\n        this._slopes = [];\r\n        this._widths = _options.widths ?? [];\r\n        this._ribbonWidths = [];\r\n        this._pathsOptions = _pathOptions ?? [];\r\n\r\n        if (_options.points) {\r\n            this.addPoints(GreasedLineTools.ConvertPoints(_options.points), _options, !!_pathOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     */\r\n    public override addPoints(points: number[][], options: GreasedLineMeshOptions, hasPathOptions = false) {\r\n        if (!options.ribbonOptions) {\r\n            throw \"addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.\";\r\n        }\r\n\r\n        if (!hasPathOptions) {\r\n            this._pathsOptions.push({ options, pathCount: points.length });\r\n        }\r\n\r\n        super.addPoints(points, options);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineRibbonMesh\"\r\n     * @returns \"GreasedLineRibbonMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GreasedLineRibbonMesh\";\r\n    }\r\n\r\n    /**\r\n     * Return true if the line was created from two edge paths or one points path.\r\n     * In this case the line is always flat.\r\n     */\r\n    public get isFlatLine() {\r\n        return this._paths.length < 3;\r\n    }\r\n\r\n    /**\r\n     * Returns the slopes of the line at each point relative to the center of the line\r\n     */\r\n    get slopes() {\r\n        return this._slopes;\r\n    }\r\n\r\n    /**\r\n     * Set the slopes of the line at each point relative to the center of the line\r\n     */\r\n    set slopes(slopes: number[]) {\r\n        this._slopes = slopes;\r\n    }\r\n\r\n    protected _updateColorPointers() {\r\n        if (this._options.colorPointers) {\r\n            return;\r\n        }\r\n\r\n        let colorPointer = 0;\r\n        this._colorPointers = [];\r\n        for (let i = 0; i < this._pathsOptions.length; i++) {\r\n            const { options: pathOptions, pathCount } = this._pathsOptions[i];\r\n            const points = this._points[i];\r\n\r\n            if (pathOptions.ribbonOptions!.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n                for (let k = 0; k < pathCount; k++) {\r\n                    for (let j = 0; j < points.length; j += 3) {\r\n                        this._colorPointers.push(colorPointer);\r\n                        this._colorPointers.push(colorPointer++);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let j = 0; j < points.length; j += 3) {\r\n                    for (let k = 0; k < pathCount; k++) {\r\n                        this._colorPointers.push(colorPointer);\r\n                    }\r\n                    colorPointer++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _updateWidths(): void {\r\n        super._updateWidthsWithValue(1);\r\n    }\r\n\r\n    protected _setPoints(points: number[][], _options: GreasedLineMeshOptions) {\r\n        if (!this._options.ribbonOptions) {\r\n            throw \"No 'GreasedLineMeshOptions.ribbonOptions' provided.\";\r\n        }\r\n        this._points = points;\r\n        this._options.points = points;\r\n\r\n        this._initGreasedLine();\r\n\r\n        let indiceOffset = 0;\r\n        let directionPlanes: Vector3[];\r\n        for (let i = 0, c = 0; i < this._pathsOptions.length; i++) {\r\n            const { options: pathOptions, pathCount } = this._pathsOptions[i];\r\n            const subPoints = points.slice(c, c + pathCount);\r\n            c += pathCount;\r\n            if (pathOptions.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS) {\r\n                indiceOffset = this._preprocess(GreasedLineTools.ToVector3Array(subPoints) as Vector3[][], indiceOffset, pathOptions);\r\n            } else {\r\n                if (pathOptions.ribbonOptions?.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE) {\r\n                    if (!pathOptions.ribbonOptions!.directions) {\r\n                        throw \"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.\";\r\n                    }\r\n                    directionPlanes = GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions!.directions);\r\n                }\r\n                subPoints.forEach((p, idx) => {\r\n                    const pathArray = GreasedLineRibbonMesh._ConvertToRibbonPath(\r\n                        p,\r\n                        pathOptions.ribbonOptions!,\r\n                        this._scene.useRightHandedSystem,\r\n                        directionPlanes ? directionPlanes[idx] : directionPlanes\r\n                    );\r\n                    indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);\r\n                });\r\n            }\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this._createVertexBuffers();\r\n            this.refreshBoundingInfo();\r\n        }\r\n    }\r\n\r\n    private static _GetDirectionPlanesFromDirectionsOption(count: number, directions: Vector3 | Vector3[]) {\r\n        if (Array.isArray(directions)) {\r\n            return directions;\r\n        }\r\n\r\n        return new Array(count).fill(directions) as Vector3[];\r\n    }\r\n\r\n    private static _CreateRibbonVertexData(pathArray: Vector3[][], options: GreasedLineMeshOptions) {\r\n        const numOfPaths = pathArray.length;\r\n        if (numOfPaths < 2) {\r\n            throw \"Minimum of two paths are required to create a GreasedLineRibbonMesh.\";\r\n        }\r\n\r\n        const positions = [];\r\n        const indices = [];\r\n\r\n        const path = pathArray[0];\r\n        for (let i = 0; i < path.length; i++) {\r\n            for (let pi = 0; pi < pathArray.length; pi++) {\r\n                const v = pathArray[pi][i];\r\n                positions.push(v.x, v.y, v.z);\r\n            }\r\n        }\r\n\r\n        const v: number[] = [1, 0, numOfPaths];\r\n        const doubleSided = options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED ?? false;\r\n\r\n        const closePath = options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath;\r\n        if (numOfPaths > 2) {\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                v[0] = 1 + numOfPaths * i;\r\n                v[1] = numOfPaths * i;\r\n                v[2] = (i + 1) * numOfPaths;\r\n                for (let pi = 0; pi < (numOfPaths - 1) * 2; pi++) {\r\n                    if (pi % 2 !== 0) {\r\n                        v[2] += 1;\r\n                    }\r\n                    if (pi % 2 === 0 && pi > 0) {\r\n                        v[0] += 1;\r\n                        v[1] += 1;\r\n                    }\r\n                    indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);\r\n                    if (doubleSided) {\r\n                        indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < positions.length / 3 - 3; i += 2) {\r\n                indices.push(i, i + 1, i + 2);\r\n                indices.push(i + 2, i + 1, i + 3);\r\n                if (doubleSided) {\r\n                    indices.push(i + 1, i, i + 2);\r\n                    indices.push(i + 1, i + 2, i + 3);\r\n                }\r\n            }\r\n        }\r\n        if (closePath) {\r\n            let lastIndice = numOfPaths * (path.length - 1);\r\n            for (let pi = 0; pi < numOfPaths - 1; pi++) {\r\n                indices.push(lastIndice, pi + 1, pi);\r\n                indices.push(lastIndice + 1, pi + 1, lastIndice);\r\n                if (doubleSided) {\r\n                    indices.push(pi, pi + 1, lastIndice);\r\n                    indices.push(lastIndice, pi + 1, lastIndice + 1);\r\n                }\r\n                lastIndice++;\r\n            }\r\n        }\r\n\r\n        return {\r\n            positions,\r\n            indices,\r\n        };\r\n    }\r\n\r\n    private _preprocess(pathArray: Vector3[][], indiceOffset: number, options: GreasedLineMeshOptions) {\r\n        this._paths = pathArray;\r\n\r\n        const ribbonVertexData = GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);\r\n\r\n        const positions = ribbonVertexData.positions;\r\n\r\n        if (!this._options.widths) {\r\n            throw \"No 'GreasedLineMeshOptions.widths' table is specified.\";\r\n        }\r\n\r\n        for (const p of positions) {\r\n            this._vertexPositions.push(p);\r\n        }\r\n\r\n        let pathArrayCopy = pathArray;\r\n        if (options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath) {\r\n            pathArrayCopy = [];\r\n            for (let i = 0; i < pathArray.length; i++) {\r\n                const pathCopy = pathArray[i].slice();\r\n                pathCopy.push(pathArray[i][0].clone());\r\n                pathArrayCopy.push(pathCopy);\r\n            }\r\n        }\r\n\r\n        this._calculateSegmentLengths(pathArrayCopy);\r\n\r\n        const pathArrayLength = pathArrayCopy.length;\r\n        const previousCounters = new Array(pathArrayLength).fill(0);\r\n        for (let i = 0; i < pathArrayCopy[0].length; i++) {\r\n            let v = 0;\r\n            for (let pi = 0; pi < pathArrayLength; pi++) {\r\n                const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];\r\n                this._counters.push(counter);\r\n                this._uvs.push(counter, v);\r\n\r\n                previousCounters[pi] = counter;\r\n                v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];\r\n            }\r\n        }\r\n\r\n        for (let i = 0, c = 0; i < pathArrayCopy[0].length; i++) {\r\n            const widthLower = this._uSegmentLengths[i][0] / 2;\r\n            const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;\r\n            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthLower);\r\n            for (let pi = 0; pi < pathArrayLength - 2; pi++) {\r\n                this._ribbonWidths.push(0);\r\n            }\r\n            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthUpper);\r\n        }\r\n\r\n        const slopes =\r\n            options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS\r\n                ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0)\r\n                : GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);\r\n        for (const s of slopes) {\r\n            this._slopes.push(s);\r\n        }\r\n\r\n        if (ribbonVertexData.indices) {\r\n            for (let i = 0; i < ribbonVertexData.indices.length; i++) {\r\n                this._indices.push(ribbonVertexData.indices[i] + indiceOffset);\r\n            }\r\n        }\r\n        indiceOffset += positions.length / 3;\r\n\r\n        return indiceOffset;\r\n    }\r\n\r\n    private static _ConvertToRibbonPath(points: number[], ribbonInfo: GreasedLineRibbonOptions, rightHandedSystem: boolean, directionPlane?: Vector3) {\r\n        if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS && !ribbonInfo.width) {\r\n            throw \"'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.\";\r\n        }\r\n        const path1 = [];\r\n        const path2 = [];\r\n        if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n            const width = ribbonInfo.width! / 2;\r\n            const pointVectors = GreasedLineTools.ToVector3Array(points) as Vector3[];\r\n            let direction: Nullable<Vector3> = null;\r\n            let fatDirection: Nullable<Vector3> = null;\r\n\r\n            if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT) {\r\n                // set the direction plane from the first line segment for the whole line\r\n                directionPlane = GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);\r\n            }\r\n\r\n            for (let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++) {\r\n                const p1 = pointVectors[i];\r\n                const p2 = pointVectors[i + 1];\r\n\r\n                if (directionPlane) {\r\n                    direction = <Vector3>directionPlane;\r\n                } else if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS) {\r\n                    direction = GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);\r\n                } else {\r\n                    // GreasedLineRibbonAutoDirectionMode.DIRECTION_ENHANCED\r\n                    const directionTemp = p2.subtract(p1);\r\n                    directionTemp.applyRotationQuaternionInPlace(\r\n                        directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z\r\n                            ? rightHandedSystem\r\n                                ? GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion\r\n                                : GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion\r\n                            : GreasedLineRibbonMesh._LeftReadOnlyQuaternion\r\n                    );\r\n                    direction = directionTemp.normalize();\r\n                }\r\n\r\n                fatDirection = direction.multiplyByFloats(width, width, width);\r\n                path1.push(p1.add(fatDirection));\r\n                path2.push(p1.subtract(fatDirection));\r\n            }\r\n            if (!directionPlane) {\r\n                path1.push(pointVectors[pointVectors.length - 1].add(fatDirection!));\r\n                path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection!));\r\n            }\r\n        }\r\n        return [path1, path2];\r\n    }\r\n\r\n    private static _GetDirectionFromPoints(p1: Vector3, p2: Vector3, previousDirection: Nullable<Vector3>) {\r\n        // handle straight lines\r\n        if (p1.x === p2.x && (!previousDirection || previousDirection?.x === 1)) {\r\n            return GreasedLineRibbonMesh.DIRECTION_YZ;\r\n        }\r\n\r\n        if (p1.y === p2.y) {\r\n            return GreasedLineRibbonMesh.DIRECTION_XZ;\r\n        }\r\n\r\n        if (p1.z === p2.z) {\r\n            return GreasedLineRibbonMesh.DIRECTION_XY;\r\n        }\r\n\r\n        return GreasedLineRibbonMesh.DIRECTION_XZ;\r\n    }\r\n\r\n    /**\r\n     * Clones the GreasedLineRibbonMesh.\r\n     * @param name new line name\r\n     * @param newParent new parent node\r\n     * @returns cloned line\r\n     */\r\n    public clone(name: string = `${this.name}-cloned`, newParent?: Nullable<Node>) {\r\n        const lineOptions = this._createLineOptions();\r\n        const deepCopiedLineOptions: any = {};\r\n        const pathOptionsCloned: any = [];\r\n        DeepCopier.DeepCopy(this._pathsOptions, pathOptionsCloned, undefined, undefined, true);\r\n        DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"], undefined, true);\r\n\r\n        const cloned = new GreasedLineRibbonMesh(name, this._scene, <GreasedLineMeshOptions>deepCopiedLineOptions, pathOptionsCloned);\r\n        if (newParent) {\r\n            cloned.parent = newParent;\r\n        }\r\n\r\n        cloned.material = this.material;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineRibbonMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n        serializationObject.pathsOptions = this._pathsOptions;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized GreasedLineRibbonMesh\r\n     * @param parsedMesh the serialized GreasedLineRibbonMesh\r\n     * @param scene the scene to create the GreasedLineRibbonMesh in\r\n     * @returns the created GreasedLineRibbonMesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): Mesh {\r\n        const lineOptions = <GreasedLineMeshOptions>parsedMesh.lineOptions;\r\n        const name = <string>parsedMesh.name;\r\n        const pathOptions = parsedMesh.pathOptions;\r\n        const result = new GreasedLineRibbonMesh(name, scene, lineOptions, pathOptions);\r\n        return result;\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        super._initGreasedLine();\r\n\r\n        this._paths = [];\r\n        this._counters = [];\r\n        this._slopes = [];\r\n        this._ribbonWidths = [];\r\n    }\r\n\r\n    private _calculateSegmentLengths(pathArray: Vector3[][]) {\r\n        const pathArrayLength = pathArray.length;\r\n        this._vSegmentLengths = new Array(pathArrayLength);\r\n        this._vTotalLengths = new Array(pathArrayLength);\r\n        let length = 0;\r\n        for (let pi = 0; pi < pathArrayLength; pi++) {\r\n            const points = pathArray[pi];\r\n            this._vSegmentLengths[pi] = [0]; // first point has 0 distance\r\n            length = 0;\r\n            for (let i = 0; i < points.length - 1; i++) {\r\n                const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared()); // it's ok to have lengthSquared() here\r\n                length += l;\r\n                this._vSegmentLengths[pi].push(l);\r\n            }\r\n            this._vTotalLengths[pi] = length;\r\n        }\r\n\r\n        const positionsLength = pathArray[0].length;\r\n        this._uSegmentLengths = new Array(positionsLength).fill([]);\r\n        this._uTotalLengths = new Array(positionsLength).fill([]);\r\n        const uLength = new Vector3();\r\n        for (let i = 0; i < positionsLength; i++) {\r\n            length = 0;\r\n            for (let pi = 1; pi < pathArrayLength; pi++) {\r\n                pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);\r\n                const l = uLength.length(); // must be length()\r\n                length += l;\r\n                this._uSegmentLengths[i].push(l);\r\n            }\r\n            this._uTotalLengths[i] = length;\r\n        }\r\n    }\r\n\r\n    private static _CalculateSlopes(paths: Vector3[][]) {\r\n        const points1 = paths[0];\r\n        const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];\r\n        const slopes: number[] = [];\r\n\r\n        const slope = new Vector3();\r\n        for (let i = 0; i < points1.length; i++) {\r\n            for (let pi = 0; pi < paths.length; pi++) {\r\n                if (pi === 0 || pi === paths.length - 1) {\r\n                    points1[i].subtract(points2[i]).normalizeToRef(slope);\r\n                    slopes.push(slope.x, slope.y, slope.z);\r\n                    slopes.push(-slope.x, -slope.y, -slope.z);\r\n                } else {\r\n                    slopes.push(0, 0, 0, 0, 0, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        return slopes;\r\n    }\r\n\r\n    protected _createVertexBuffers() {\r\n        this._uvs = this._options.uvs ?? this._uvs;\r\n        const vertexData = super._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n\r\n        const countersBuffer = new Buffer(this._engine, this._counters, this._updatable, 1);\r\n        this.setVerticesBuffer(countersBuffer.createVertexBuffer(\"grl_counters\", 0, 1));\r\n\r\n        const colorPointersBuffer = new Buffer(this._engine, this._colorPointers, this._updatable, 1);\r\n        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\r\n\r\n        const slopesBuffer = new Buffer(this._engine, this._slopes, this._updatable, 3);\r\n        this.setVerticesBuffer(slopesBuffer.createVertexBuffer(\"grl_slopes\", 0, 3));\r\n\r\n        const widthsBuffer = new Buffer(this._engine, this._ribbonWidths, this._updatable, 1);\r\n        this.setVerticesBuffer(widthsBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\r\n        this._widthsBuffer = widthsBuffer;\r\n\r\n        return vertexData;\r\n    }\r\n}\r\n", "import { StandardMaterial } from \"./../../Materials/standardMaterial\";\r\nimport { PBRMaterial } from \"../../Materials/PBR/pbrMaterial\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { GreasedLineMesh } from \"../GreasedLine/greasedLineMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport type { GreasedLineMeshOptions } from \"../GreasedLine/greasedLineBaseMesh\";\r\nimport { GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"../GreasedLine/greasedLineBaseMesh\";\r\nimport { GreasedLineRibbonMesh } from \"../GreasedLine/greasedLineRibbonMesh\";\r\nimport type { GreasedLineMaterialOptions } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshMaterialType } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { GreasedLineMaterialDefaults } from \"../../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * How are the colors distributed along the color table\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colors-and-colordistribution}\r\n */\r\nexport enum GreasedLineMeshColorDistribution {\r\n    /**\r\n     * Do no modify the color table\r\n     */\r\n    COLOR_DISTRIBUTION_NONE = 0,\r\n    /**\r\n     * Repeat the colors until the color table is full\r\n     */\r\n    COLOR_DISTRIBUTION_REPEAT = 1,\r\n    /**\r\n     * Distribute the colors evenly through the color table\r\n     */\r\n    COLOR_DISTRIBUTION_EVEN = 2,\r\n    /**\r\n     * Put the colors to start of the color table a fill the rest with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_START = 3,\r\n    /**\r\n     * Put the colors to the end of the color table and fill the rest with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_END = 4,\r\n    /**\r\n     * Put the colors to start and to the end of the color table and fill the gap between with the default color\r\n     */\r\n    COLOR_DISTRIBUTION_START_END = 5,\r\n}\r\n\r\n/**\r\n * How are the widths distributed along the width table\r\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#widths-and-widthdistribution}\r\n */\r\nexport enum GreasedLineMeshWidthDistribution {\r\n    /**\r\n     * Do no modify the width table\r\n     */\r\n    WIDTH_DISTRIBUTION_NONE = 0,\r\n    /**\r\n     * Repeat the widths until the width table is full\r\n     */\r\n    WIDTH_DISTRIBUTION_REPEAT = 1,\r\n    /**\r\n     * Distribute the widths evenly through the width table\r\n     */\r\n    WIDTH_DISTRIBUTION_EVEN = 2,\r\n    /**\r\n     * Put the widths to start of the width table a fill the rest with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_START = 3,\r\n    /**\r\n     * Put the widths to the end of the width table and fill the rest with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_END = 4,\r\n    /**\r\n     * Put the widths to start and to the end of the width table and fill the gap between with the default width\r\n     */\r\n    WIDTH_DISTRIBUTION_START_END = 5,\r\n}\r\n\r\n/**\r\n * Material options for GreasedLineBuilder\r\n */\r\nexport interface GreasedLineMaterialBuilderOptions extends GreasedLineMaterialOptions {\r\n    /**\r\n     * If set to true a new material will be created and a new material plugin will be attached\r\n     * to the material. The material will be set on the mesh. If the instance option is specified in the mesh options,\r\n     * no material will be created/assigned. Defaults to true.\r\n     */\r\n    createAndAssignMaterial?: boolean;\r\n    /**\r\n     * Distribution of the colors if the color table contains fewer entries than needed. Defaults to GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START\r\n     * @see CompleteGreasedLineColorTable\r\n     */\r\n    colorDistribution?: GreasedLineMeshColorDistribution;\r\n}\r\n\r\n/**\r\n * Line mesh options for GreasedLineBuilder\r\n */\r\nexport interface GreasedLineMeshBuilderOptions extends GreasedLineMeshOptions {\r\n    /**\r\n     * Distribution of the widths if the width table contains fewer entries than needed. Defaults to GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START\r\n     * @see CompleteGreasedLineWidthTable\r\n     */\r\n    widthDistribution?: GreasedLineMeshWidthDistribution;\r\n}\r\n\r\n/**\r\n * Builder functions for creating GreasedLineMeshes\r\n */\r\n\r\n/**\r\n * Creates a new @see GreasedLinePluginMaterial\r\n * @param name name of the material\r\n * @param options material options @see GreasedLineMaterialOptions\r\n * @param scene scene or null to use the last scene\r\n * @returns StandardMaterial or PBRMaterial with the @see GreasedLinePluginMaterial attached to it\r\n */\r\nexport function CreateGreasedLineMaterial(name: string, options: GreasedLineMaterialOptions, scene: Nullable<Scene>) {\r\n    scene = <Scene>(scene ?? EngineStore.LastCreatedScene);\r\n\r\n    let material;\r\n    switch (options.materialType) {\r\n        case GreasedLineMeshMaterialType.MATERIAL_TYPE_PBR:\r\n            material = new PBRMaterial(name, scene);\r\n            new GreasedLinePluginMaterial(material, scene, options);\r\n            break;\r\n        case GreasedLineMeshMaterialType.MATERIAL_TYPE_SIMPLE:\r\n            material = new GreasedLineSimpleMaterial(name, scene, options);\r\n            break;\r\n        default:\r\n            material = new StandardMaterial(name, scene);\r\n            new GreasedLinePluginMaterial(material, scene, options);\r\n            break;\r\n    }\r\n\r\n    return material;\r\n}\r\n\r\n/**\r\n * Creates a GreasedLine mesh\r\n * @param name name of the mesh\r\n * @param options options for the mesh\r\n * @param materialOptions material options for the mesh\r\n * @param scene scene where the mesh will be created\r\n * @returns instance of GreasedLineMesh\r\n */\r\nexport function CreateGreasedLine(name: string, options: GreasedLineMeshBuilderOptions, materialOptions?: Nullable<GreasedLineMaterialBuilderOptions>, scene?: Nullable<Scene>) {\r\n    scene = <Scene>(scene ?? EngineStore.LastCreatedScene);\r\n\r\n    let instance;\r\n    const allPoints = GreasedLineTools.ConvertPoints(options.points);\r\n\r\n    options.widthDistribution = options.widthDistribution ?? GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START;\r\n    if (options.ribbonOptions) {\r\n        options.ribbonOptions.facesMode = options.ribbonOptions.facesMode ?? GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING;\r\n        options.ribbonOptions.pointsMode = options.ribbonOptions.pointsMode ?? GreasedLineRibbonPointsMode.POINTS_MODE_POINTS;\r\n        options.ribbonOptions.directionsAutoMode =\r\n            options.ribbonOptions.directionsAutoMode ??\r\n            (options.ribbonOptions.directions ? GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE : GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT);\r\n    }\r\n\r\n    materialOptions = materialOptions ?? {\r\n        color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n    };\r\n    materialOptions.createAndAssignMaterial = materialOptions.createAndAssignMaterial ?? true;\r\n    materialOptions.colorDistribution = materialOptions?.colorDistribution ?? GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START;\r\n    materialOptions.materialType = materialOptions.materialType ?? GreasedLineMeshMaterialType.MATERIAL_TYPE_STANDARD;\r\n\r\n    let length = 0;\r\n    if (Array.isArray(allPoints[0])) {\r\n        allPoints.forEach((points) => {\r\n            length += points.length / 3;\r\n        });\r\n    }\r\n\r\n    const widths = CompleteGreasedLineWidthTable(length, options.widths ?? [], options.widthDistribution);\r\n\r\n    const colors = materialOptions?.colors\r\n        ? CompleteGreasedLineColorTable(length, materialOptions.colors, materialOptions.colorDistribution, materialOptions.color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR)\r\n        : undefined;\r\n\r\n    // create new mesh if instance is not defined\r\n    const initialGreasedLineOptions: GreasedLineMeshOptions = {\r\n        points: allPoints,\r\n        updatable: options.updatable,\r\n        widths,\r\n        lazy: options.lazy,\r\n        ribbonOptions: options.ribbonOptions,\r\n        uvs: options.uvs,\r\n        colorPointers: options.colorPointers,\r\n    };\r\n\r\n    if (initialGreasedLineOptions.ribbonOptions) {\r\n        if (initialGreasedLineOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\r\n            initialGreasedLineOptions.ribbonOptions.width = materialOptions.width ?? initialGreasedLineOptions.ribbonOptions.width ?? GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        }\r\n    }\r\n\r\n    if (!options.instance) {\r\n        instance = initialGreasedLineOptions.ribbonOptions\r\n            ? new GreasedLineRibbonMesh(name, scene, initialGreasedLineOptions)\r\n            : new GreasedLineMesh(name, scene, initialGreasedLineOptions);\r\n\r\n        if (materialOptions) {\r\n            const initialMaterialOptions: GreasedLineMaterialOptions = {\r\n                materialType: materialOptions.materialType,\r\n                dashCount: materialOptions.dashCount,\r\n                dashOffset: materialOptions.dashOffset,\r\n                dashRatio: materialOptions.dashRatio,\r\n                resolution: materialOptions.resolution,\r\n                sizeAttenuation: materialOptions.sizeAttenuation,\r\n                useColors: materialOptions.useColors,\r\n                useDash: materialOptions.useDash,\r\n                visibility: materialOptions.visibility,\r\n                width: materialOptions.width,\r\n                color: materialOptions.color,\r\n                colorMode: materialOptions.colorMode,\r\n                colorsSampling: materialOptions.colorsSampling,\r\n                colorDistributionType: materialOptions.colorDistributionType,\r\n                colors,\r\n                cameraFacing: !options.ribbonOptions,\r\n                colorsTexture: materialOptions.colorsTexture,\r\n            };\r\n\r\n            if (materialOptions.createAndAssignMaterial) {\r\n                const material = CreateGreasedLineMaterial(name, initialMaterialOptions, scene);\r\n                instance.material = material;\r\n\r\n                if (options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING) {\r\n                    material.backFaceCulling = false;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        // update the data on the mesh instance\r\n        instance = options.instance;\r\n        if (instance instanceof GreasedLineRibbonMesh) {\r\n            instance.addPoints(allPoints, initialGreasedLineOptions);\r\n        } else {\r\n            const currentWidths = instance.widths;\r\n\r\n            if (currentWidths) {\r\n                const newWidths = currentWidths.slice();\r\n                for (const w of widths) {\r\n                    newWidths.push(w);\r\n                }\r\n                instance.widths = newWidths;\r\n            } else {\r\n                instance.widths = widths;\r\n            }\r\n            instance.addPoints(allPoints);\r\n        }\r\n    }\r\n\r\n    // add colors\r\n    // it will merge if any colors already on the instance\r\n    if (colors && options.instance) {\r\n        if (options.instance.greasedLineMaterial) {\r\n            const currentColors = options.instance.greasedLineMaterial.colors;\r\n            if (currentColors) {\r\n                const newColors = currentColors.concat(colors);\r\n                options.instance.greasedLineMaterial.setColors(newColors, instance.isLazy());\r\n            }\r\n        }\r\n    }\r\n\r\n    return instance;\r\n}\r\n\r\n/**\r\n * Completes the width table/fills the missing entries. It means it creates a width entry for every point of the line mesh.\r\n * You can provide more points the widths when creating the mesh. This function will fill the empty entries.\r\n * The algorithm used to fill the empty entries can be\r\n * GreasedLineMeshWidthDistribution.REPEAT - the width table will be repeatedly copied to the empty values [wL, wU] = [wL, wU, wL, wU, wL, wU, wL, wU, ...]\r\n * GreasedLineMeshWidthDistribution.EVEN - the width table will be evenly copied to the empty values [wL, wU] = [wL, wL, wL, wL, wU, wU, wU, wU]\r\n * GreasedLineMeshWidthDistribution.START - the width table will be copied at the start of the empty values\r\n * and rest will be filled width the default width upper and default width lower values [wU, wL] = [wL, wU, dwL, dwU, dwL, dwU, dwL, dwU]\r\n * GreasedLineMeshWidthDistribution.END - the width table will be copied at the end of the empty values\r\n * and rest will be filled width the default values [wL, wU] = [wL, wU, dwL, dwU, dwL, dwU, wL, wU]\r\n * @param pointCount number of points of the line mesh\r\n * @param widths array of widths [widhtLower, widthUpper, widthLower, widthUpper ...]. Two widths (lower/upper) per point.\r\n * @param widthsDistribution how to distribute widths if the widths array has fewer entries than pointCount\r\n * @param defaultWidthUpper the default value which will be used to fill empty width entries - upper width\r\n * @param defaultWidthLower the default value which will be used to fill empty width entries - lower width\r\n * @returns completed width table.\r\n */\r\nexport function CompleteGreasedLineWidthTable(\r\n    pointCount: number,\r\n    widths: number[],\r\n    widthsDistribution: GreasedLineMeshWidthDistribution,\r\n    defaultWidthUpper = 1,\r\n    defaultWidthLower = 1\r\n): number[] {\r\n    const missingCount = pointCount - widths.length / 2;\r\n\r\n    const widthsData: number[] = [];\r\n    if (missingCount < 0) {\r\n        return widths.slice(0, pointCount * 2);\r\n    }\r\n\r\n    // is the width table shorter than the point table?\r\n    if (missingCount > 0) {\r\n        if (widths.length % 2 != 0) {\r\n            widths.push(defaultWidthUpper);\r\n        }\r\n        // it is, fill in the missing elements\r\n        if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START_END) {\r\n            const halfCount = Math.floor(widths.length / 2);\r\n\r\n            // start sector\r\n            for (let i = 0, j = 0; i < halfCount - 1; i++) {\r\n                widthsData.push(widths[j++]);\r\n                widthsData.push(widths[j++]);\r\n            }\r\n\r\n            // middle sector\r\n            const widthL = widths[halfCount / 2];\r\n            const widthU = widths[halfCount / 2 + 1];\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(widthU);\r\n                widthsData.push(widthL);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = halfCount; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START) {\r\n            // start sector\r\n            for (let i = 0; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(defaultWidthUpper);\r\n                widthsData.push(defaultWidthLower);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_END) {\r\n            // start sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                widthsData.push(defaultWidthUpper);\r\n                widthsData.push(defaultWidthLower);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < widths.length; i += 2) {\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_REPEAT) {\r\n            let i = 0;\r\n            for (let x = 0; x < pointCount; x++) {\r\n                widthsData.push(widths[i++]);\r\n                widthsData.push(widths[i++]);\r\n\r\n                if (i === widths.length) {\r\n                    i = 0;\r\n                }\r\n            }\r\n        } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_EVEN) {\r\n            let j = 0;\r\n            const widthsectorLength = widths.length / ((pointCount - 1) * 2);\r\n            for (let x = 0; x < pointCount; x++) {\r\n                const i = Math.floor(j);\r\n\r\n                widthsData.push(widths[i]);\r\n                widthsData.push(widths[i + 1]);\r\n\r\n                j += widthsectorLength;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = 0; i < widths.length; i++) {\r\n            widthsData.push(widths[i]);\r\n        }\r\n    }\r\n\r\n    return widthsData;\r\n}\r\n\r\n/**\r\n * Completes the color table/fill the missing color entries. It means it creates a color entry for every point of the line mesh.\r\n * You can provide more points the colors when creating the mesh. This function will fill the empty entries.\r\n * The algorithm used to fill the empty entries can be\r\n * GreasedLineMesColorhDistribution.REPEAT - the color table will be repeatedly copied to the empty values [c1, c2] = [c1, c2, c1, c2, c1, c2, c1, c2]\r\n * GreasedLineMesColorhDistribution.EVEN - the color table will be evenly copied to the empty values [c1, c2] = [c1, c1, c1, c1, c2, c2, c2, c2]\r\n * GreasedLineMesColorhDistribution.START - the color table will be copied at the start of the empty values\r\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, dc, dc]\r\n * GreasedLineMesColorhDistribution.START_END - the color table will be copied at the start and the end of the empty values\r\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, c1, c2]\r\n * @param pointCount number of points of the line mesh\r\n * @param colors array of Color3 for the color table\r\n * @param colorDistribution how to distribute colors if the colors array has fewer entries than pointCount\r\n * @param defaultColor default color to be used to fill empty entries in the color table\r\n * @returns completed array of Color3s\r\n */\r\nexport function CompleteGreasedLineColorTable(pointCount: number, colors: Color3[], colorDistribution: GreasedLineMeshColorDistribution, defaultColor: Color3): Color3[] {\r\n    pointCount = Math.max(colors.length, pointCount);\r\n    const missingCount = pointCount - colors.length;\r\n    if (missingCount < 0) {\r\n        return colors.slice(0, pointCount);\r\n    }\r\n\r\n    const colorsData: Color3[] = [];\r\n    // is the color table shorter than the point table?\r\n    if (missingCount > 0) {\r\n        // it is, fill in the missing elements\r\n        if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START_END) {\r\n            const halfCount = Math.floor(colors.length / 2);\r\n\r\n            // start sector\r\n            for (let i = 0; i < halfCount; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n\r\n            // middle sector\r\n            for (let i = 0; i < missingCount - 1; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = halfCount; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START) {\r\n            // start sector\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < missingCount; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_END) {\r\n            // start sector\r\n            for (let i = 0; i < missingCount - 1; i++) {\r\n                colorsData.push(defaultColor);\r\n            }\r\n\r\n            // end sector\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_REPEAT) {\r\n            let i = 0;\r\n            for (let x = 0; x < pointCount; x++) {\r\n                colorsData.push(colors[i]);\r\n\r\n                i++;\r\n\r\n                if (i === colors.length) {\r\n                    i = 0;\r\n                }\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_EVEN) {\r\n            let j = 0;\r\n            const colorSectorLength = colors.length / (pointCount - 1);\r\n            for (let x = 0; x < pointCount - 1; x++) {\r\n                const i = Math.floor(j);\r\n\r\n                colorsData.push(colors[i]);\r\n\r\n                j += colorSectorLength;\r\n            }\r\n        } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_NONE) {\r\n            for (let i = 0; i < colors.length; i++) {\r\n                colorsData.push(colors[i]);\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = 0; i < pointCount; i++) {\r\n            colorsData.push(colors[i]);\r\n        }\r\n    }\r\n\r\n    return colorsData;\r\n}\r\n", "import { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGPUDataBuffer extends DataBuffer {\r\n    private _buffer: Nullable<GPUBuffer>;\r\n\r\n    public constructor(resource: GPUBuffer, capacity = 0) {\r\n        super();\r\n        this.capacity = capacity;\r\n        this._buffer = resource;\r\n    }\r\n\r\n    public get underlyingResource(): any {\r\n        return this._buffer;\r\n    }\r\n}\r\n", "import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = false): Buffer {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = false): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = [] as Matrix[];\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n        const boundingInfo = this.getBoundingInfo();\r\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n", "/**\r\n * Defines the kind of connection point for node geometry\r\n */\r\nexport enum NodeGeometryBlockConnectionPointTypes {\r\n    /** Int */\r\n    Int = 0x0001,\r\n    /** Float */\r\n    Float = 0x0002,\r\n    /** Vector2 */\r\n    Vector2 = 0x0004,\r\n    /** Vector3 */\r\n    Vector3 = 0x0008,\r\n    /** Vector4 */\r\n    Vector4 = 0x0010,\r\n    /** Matrix */\r\n    Matrix = 0x0020,\r\n    /** Geometry */\r\n    Geometry = 0x0040,\r\n    /** Texture */\r\n    Texture = 0x0080,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x0400,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x0800,\r\n    /** Undefined */\r\n    Undefined = 0x1000,\r\n    /** Bitmask of all types */\r\n    All = 0x0fff,\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { NodeGeometryBlock } from \"./nodeGeometryBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { GeometryInputBlock } from \"./Blocks/geometryInputBlock\";\r\nimport type { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeGeometryConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeGeometryConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeGeometryConnectionPoint {\r\n    /** @internal */\r\n    public _ownerBlock: NodeGeometryBlock;\r\n    /** @internal */\r\n    public _connectedPoint: Nullable<NodeGeometryConnectionPoint> = null;\r\n    /** @internal */\r\n    public _storedValue: any = null;\r\n    /** @internal */\r\n    public _storedFunction: Nullable<(state: NodeGeometryBuildState) => any> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeGeometryConnectionPoint>();\r\n    private _direction: NodeGeometryConnectionPointDirection;\r\n    private _type = NodeGeometryBlockConnectionPointTypes.Geometry;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeGeometryConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeGeometryBlockConnectionPointTypes> = null;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes: NodeGeometryBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes: NodeGeometryBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeGeometryConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets the default value used for this point at creation time\r\n     */\r\n    public defaultValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the default value used for this point if nothing is connected\r\n     */\r\n    public value: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the min value accepted for this point if nothing is connected\r\n     */\r\n    public valueMin: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the max value accepted for this point if nothing is connected\r\n     */\r\n    public valueMax: Nullable<any> = null;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeGeometryBlockConnectionPointTypes {\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as GeometryInputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeGeometryBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point display name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeGeometryConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeGeometryBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeGeometryBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeGeometryBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /** @internal */\r\n    public _callCount = 0;\r\n\r\n    /** @internal */\r\n    public _executionCount = 0;\r\n\r\n    /** @internal */\r\n    public _resetCounters() {\r\n        this._callCount = 0;\r\n        this._executionCount = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of times this point was called\r\n     */\r\n    public get callCount() {\r\n        return this._callCount;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of times this point was executed\r\n     */\r\n    public get executionCount() {\r\n        return this._executionCount;\r\n    }\r\n\r\n    /**\r\n     * Gets the value represented by this connection point\r\n     * @param state current evaluation state\r\n     * @returns the connected value or the value if nothing is connected\r\n     */\r\n    public getConnectedValue(state: NodeGeometryBuildState) {\r\n        if (this.isConnected) {\r\n            if (this._connectedPoint?._storedFunction) {\r\n                this._connectedPoint!._callCount++;\r\n                this._connectedPoint!._executionCount++;\r\n                return this._connectedPoint!._storedFunction(state);\r\n            }\r\n            this._connectedPoint!._callCount++;\r\n            this._connectedPoint!._executionCount = 1;\r\n            return this._connectedPoint!._storedValue;\r\n        }\r\n        this._callCount++;\r\n        this._executionCount = 1;\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeGeometryBlock, direction: NodeGeometryConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeGeometryConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeGeometryConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeGeometryConnectionPoint): NodeGeometryConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            // Accepted types\r\n            if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n                return NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeGeometryConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeGeometryConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeGeometryConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeGeometryConnectionPoint, ignoreConstraints = false): NodeGeometryConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeGeometryConnectionPoint): NodeGeometryConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeGeometryBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n        if (this.value !== undefined && this.value !== null) {\r\n            if (this.value.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this.value.getClassName();\r\n                serializationObject.value = this.value.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this.value;\r\n            }\r\n        }\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n", "import { GetClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryConnectionPoint, NodeGeometryConnectionPointDirection } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based geometry\r\n */\r\nexport class NodeGeometryBlock {\r\n    private _name = \"\";\r\n    private _buildId: number;\r\n    protected _isInput = false;\r\n    protected _isTeleportOut = false;\r\n    protected _isTeleportIn = false;\r\n    protected _isDebug = false;\r\n    protected _isUnique = false;\r\n    private _buildExecutionTime: number = 0;\r\n\r\n    /**\r\n     * Gets an observable raised when the block is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeGeometryBlock>();\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _preparationId: number;\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return this._buildExecutionTime;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeGeometryConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeGeometryConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or set the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is an input\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a debug block\r\n     */\r\n    public get isDebug(): boolean {\r\n        return this._isDebug;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeGeometry\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the block\r\n     */\r\n    @serialize(\"comment\")\r\n    public comments: string;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeGeometryBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeGeometryBlock\";\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeGeometryBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeGeometryBlock) => boolean): Nullable<NodeGeometryBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\r\n\r\n                if (descendant) {\r\n                    return descendant;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeGeometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param value value to return if there is no connection\r\n     * @param valueMin min value accepted for value\r\n     * @param valueMax max value accepted for value\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeGeometryBlockConnectionPointTypes, isOptional: boolean = false, value?: any, valueMin?: any, valueMax?: any) {\r\n        const point = new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        point.defaultValue = value;\r\n        point.value = value;\r\n        point.valueMin = valueMin;\r\n        point.valueMax = valueMax;\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeGeometryBlockConnectionPointTypes, point?: NodeGeometryConnectionPoint) {\r\n        point = point ?? new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Output);\r\n        point.type = type;\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeGeometryBuildState): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Build the current node and generate the vertex data\r\n     * @param state defines the current generation state\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeGeometryBuildState): boolean {\r\n        if (this._buildId === state.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (this._outputs.length > 0) {\r\n            if (!this._outputs.some((o) => o.hasEndpoints) && !this.isDebug) {\r\n                return false;\r\n            }\r\n\r\n            this.outputs.forEach((o) => o._resetCounters());\r\n        }\r\n\r\n        this._buildId = state.buildId;\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                block.build(state);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state);\r\n\r\n        // Logs\r\n        if (state.verbose) {\r\n            console.log(`Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        const now = PrecisionDate.Now;\r\n        this._buildBlock(state);\r\n        this._buildExecutionTime = PrecisionDate.Now - now;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block) {\r\n                    block.build(state);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     */\r\n    public initialize() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     */\r\n    public autoConfigure() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _deserialize(serializationObject: any) {\r\n        this._name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any) => {\r\n                const input = this.inputs.find((i) => i.name === port.name);\r\n\r\n                if (!input) {\r\n                    return;\r\n                }\r\n\r\n                if (port.displayName) {\r\n                    input.displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    input.isExposedOnFrame = port.isExposedOnFrame;\r\n                    input.exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n                if (port.value !== undefined && port.value !== null) {\r\n                    if (port.valueType === \"number\") {\r\n                        input.value = port.value;\r\n                    } else {\r\n                        const valueType = GetClass(port.valueType);\r\n\r\n                        if (valueType) {\r\n                            input.value = valueType.FromArray(port.value);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeGeometryBlock = new blockType();\r\n            block._deserialize(serializationObject);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n\r\n        this.onBuildObservable.clear();\r\n    }\r\n}\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../types\";\r\n\r\n/**\r\n * Block used to generate the final geometry\r\n */\r\nexport class GeometryOutputBlock extends NodeGeometryBlock {\r\n    private _vertexData: Nullable<VertexData> = null;\r\n\r\n    /**\r\n     * Gets the current vertex data if the graph was successfully built\r\n     */\r\n    public get currentVertexData() {\r\n        return this._vertexData;\r\n    }\r\n\r\n    /**\r\n     * Create a new GeometryOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryOutputBlock\";\r\n    }\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        state.vertexData = this.geometry.getConnectedValue(state);\r\n        this._vertexData = state.vertexData;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryOutputBlock\", GeometryOutputBlock);\r\n", "/**\r\n * Defines the kind of contextual sources for node geometry\r\n */\r\nexport enum NodeGeometryContextualSources {\r\n    /** None */\r\n    None = 0x0000,\r\n    /** Positions */\r\n    Positions = 0x0001,\r\n    /** Normals */\r\n    Normals = 0x0002,\r\n    /** Tangents */\r\n    Tangents = 0x0003,\r\n    /** UV */\r\n    UV = 0x0004,\r\n    /** UV2 */\r\n    UV2 = 0x0005,\r\n    /** UV3 */\r\n    UV3 = 0x0006,\r\n    /** UV4 */\r\n    UV4 = 0x0007,\r\n    /** UV5 */\r\n    UV5 = 0x0008,\r\n    /** UV6 */\r\n    UV6 = 0x0009,\r\n    /** Colors */\r\n    Colors = 0x000a,\r\n    /** VertexID */\r\n    VertexID = 0x000b,\r\n    /** FaceID */\r\n    FaceID = 0x000c,\r\n    /** GeometryID */\r\n    GeometryID = 0x000d,\r\n    /** CollectionID */\r\n    CollectionID = 0x000e,\r\n    /** LoopID */\r\n    LoopID = 0x000f,\r\n    /** InstanceID */\r\n    InstanceID = 0x0010,\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { VertexData } from \"../mesh.vertexData\";\r\nimport type { NodeGeometryConnectionPoint } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport { NodeGeometryContextualSources } from \"./Enums/nodeGeometryContextualSources\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport type { INodeGeometryExecutionContext } from \"./Interfaces/nodeGeometryExecutionContext\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryInstancingContext } from \"./Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Class used to store node based geometry build state\r\n */\r\nexport class NodeGeometryBuildState {\r\n    private _rotationMatrix = new Matrix();\r\n    private _scalingMatrix = new Matrix();\r\n    private _positionMatrix = new Matrix();\r\n    private _scalingRotationMatrix = new Matrix();\r\n    private _transformMatrix = new Matrix();\r\n    private _tempVector3 = new Vector3();\r\n\r\n    /** Gets or sets the list of non connected mandatory inputs */\r\n    public notConnectedNonOptionalInputs: NodeGeometryConnectionPoint[] = [];\r\n    /** Gets or sets the list of non contextual inputs having no contextudal data */\r\n    public noContextualData: NodeGeometryContextualSources[] = [];\r\n    /** Gets or sets the build identifier */\r\n    public buildId: number;\r\n    /** Gets or sets a boolean indicating that verbose mode is on */\r\n    public verbose: boolean;\r\n    /** Gets or sets the vertex data */\r\n    public vertexData: Nullable<VertexData> = null;\r\n\r\n    private _geometryContext: Nullable<VertexData> = null;\r\n    private _executionContext: Nullable<INodeGeometryExecutionContext> = null;\r\n    private _instancingContext: Nullable<INodeGeometryInstancingContext> = null;\r\n\r\n    private _geometryContextStack: Array<Nullable<VertexData>> = [];\r\n    private _executionContextStack: Array<Nullable<INodeGeometryExecutionContext>> = [];\r\n    private _instancingContextStack: Array<Nullable<INodeGeometryInstancingContext>> = [];\r\n\r\n    /** Gets or sets the geometry context */\r\n    public get geometryContext() {\r\n        return this._geometryContext;\r\n    }\r\n\r\n    /** Gets or sets the execution context */\r\n    public get executionContext() {\r\n        return this._executionContext;\r\n    }\r\n\r\n    /** Gets or sets the instancing context */\r\n    public get instancingContext() {\r\n        return this._instancingContext;\r\n    }\r\n\r\n    /**\r\n     * Push the new active geometry context\r\n     * @param geometryContext defines the geometry context\r\n     */\r\n    public pushGeometryContext(geometryContext: VertexData) {\r\n        this._geometryContext = geometryContext;\r\n        this._geometryContextStack.push(this._geometryContext);\r\n    }\r\n\r\n    /**\r\n     * Push the new active execution context\r\n     * @param executionContext defines the execution context\r\n     */\r\n    public pushExecutionContext(executionContext: INodeGeometryExecutionContext) {\r\n        this._executionContext = executionContext;\r\n        this._executionContextStack.push(this._executionContext);\r\n    }\r\n\r\n    /**\r\n     * Push the new active instancing context\r\n     * @param instancingContext defines the instancing context\r\n     */\r\n    public pushInstancingContext(instancingContext: INodeGeometryInstancingContext) {\r\n        this._instancingContext = instancingContext;\r\n        this._instancingContextStack.push(this._instancingContext);\r\n    }\r\n\r\n    /**\r\n     * Remove current geometry context and restore the previous one\r\n     */\r\n    public restoreGeometryContext() {\r\n        this._geometryContextStack.pop();\r\n        this._geometryContext = this._geometryContextStack.length > 0 ? this._geometryContextStack[this._geometryContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Remove current execution context and restore the previous one\r\n     */\r\n    public restoreExecutionContext() {\r\n        this._executionContextStack.pop();\r\n        this._executionContext = this._executionContextStack.length > 0 ? this._executionContextStack[this._executionContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Remove current isntancing context and restore the previous one\r\n     */\r\n    public restoreInstancingContext() {\r\n        this._instancingContextStack.pop();\r\n        this._instancingContext = this._instancingContextStack.length > 0 ? this._instancingContextStack[this._instancingContextStack.length - 1] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual source\r\n     * @param source Source of the contextual value\r\n     * @param skipWarning Do not store the warning for reporting if true\r\n     * @returns the value associated with the source\r\n     */\r\n    public getContextualValue(source: NodeGeometryContextualSources, skipWarning = false) {\r\n        if (!this.executionContext) {\r\n            if (!skipWarning) {\r\n                this.noContextualData.push(source);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const index = this.executionContext.getExecutionIndex();\r\n\r\n        switch (source) {\r\n            case NodeGeometryContextualSources.Positions:\r\n                if (this.executionContext.getOverridePositionsContextualValue) {\r\n                    return this.executionContext.getOverridePositionsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.positions) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.positions as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Normals:\r\n                if (this.executionContext.getOverrideNormalsContextualValue) {\r\n                    return this.executionContext.getOverrideNormalsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.normals) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.normals as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Colors:\r\n                if (!this.geometryContext || !this.geometryContext.colors) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.colors as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.Tangents:\r\n                if (!this.geometryContext || !this.geometryContext.tangents) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.tangents as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.UV:\r\n                if (this.executionContext.getOverrideUVs1ContextualValue) {\r\n                    return this.executionContext.getOverrideUVs1ContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.uvs) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV2:\r\n                if (!this.geometryContext || !this.geometryContext.uvs2) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs2 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV3:\r\n                if (!this.geometryContext || !this.geometryContext.uvs3) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs3 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV4:\r\n                if (!this.geometryContext || !this.geometryContext.uvs4) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs4 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV5:\r\n                if (!this.geometryContext || !this.geometryContext.uvs5) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs5 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV6:\r\n                if (!this.geometryContext || !this.geometryContext.uvs6) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs6 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.VertexID:\r\n                return index;\r\n            case NodeGeometryContextualSources.FaceID:\r\n                return this.executionContext.getExecutionFaceIndex();\r\n            case NodeGeometryContextualSources.LoopID:\r\n                return this.executionContext.getExecutionLoopIndex();\r\n            case NodeGeometryContextualSources.InstanceID:\r\n                return this.instancingContext ? this.instancingContext.getInstanceIndex() : 0;\r\n            case NodeGeometryContextualSources.GeometryID:\r\n                return !this.geometryContext ? 0 : this.geometryContext.uniqueId;\r\n            case NodeGeometryContextualSources.CollectionID: {\r\n                if (!this.geometryContext || !this.geometryContext.metadata) {\r\n                    return 0;\r\n                }\r\n                return this.geometryContext.metadata.collectionId || 0;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt a value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @returns the adapted value\r\n     */\r\n    adapt(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes) {\r\n        const value = source.getConnectedValue(this) || 0;\r\n\r\n        if (source.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt an input value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @param defaultValue defines the default value to use if not connected\r\n     * @returns the adapted value\r\n     */\r\n    adaptInput(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes, defaultValue: any) {\r\n        if (!source.isConnected) {\r\n            return source.value || defaultValue;\r\n        }\r\n\r\n        const value = source.getConnectedValue(this);\r\n\r\n        if (source._connectedPoint?.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        for (const notConnectedInput of this.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n\r\n        for (const source of this.noContextualData) {\r\n            errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeGeometry failed:\\n\" + errorMessage;\r\n        }\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiate(clone: VertexData, currentPosition: Vector3, rotation: Vector3, scaling: Vector3, additionalVertexData: VertexData[]) {\r\n        // Transform\r\n        Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\r\n        Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\r\n        Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\r\n\r\n        this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\r\n        this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiateWithMatrix(clone: VertexData, transform: Matrix, additionalVertexData: VertexData[]) {\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiateWithPositionAndMatrix(clone: VertexData, currentPosition: Vector3, transform: Matrix, additionalVertexData: VertexData[]) {\r\n        Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\r\n        transform.multiplyToRef(this._positionMatrix, this._transformMatrix);\r\n\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n}\r\n", "import { Observable } from \"../../../Misc/observable\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { GetClass, RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources\";\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class GeometryInputBlock extends NodeGeometryBlock {\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeGeometryBlockConnectionPointTypes = NodeGeometryBlockConnectionPointTypes.Undefined;\r\n    private _contextualSource = NodeGeometryContextualSources.None;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<GeometryInputBlock>();\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeGeometryBlockConnectionPointTypes {\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeGeometryBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a contextual value\r\n     */\r\n    public get isContextual(): boolean {\r\n        return this._contextualSource !== NodeGeometryContextualSources.None;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current contextual value\r\n     */\r\n    public get contextualValue(): NodeGeometryContextualSources {\r\n        return this._contextualSource;\r\n    }\r\n\r\n    public set contextualValue(value: NodeGeometryContextualSources) {\r\n        this._contextualSource = value;\r\n\r\n        switch (value) {\r\n            case NodeGeometryContextualSources.Positions:\r\n            case NodeGeometryContextualSources.Normals:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\r\n                break;\r\n            case NodeGeometryContextualSources.Colors:\r\n            case NodeGeometryContextualSources.Tangents:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\r\n                break;\r\n            case NodeGeometryContextualSources.UV:\r\n            case NodeGeometryContextualSources.UV2:\r\n            case NodeGeometryContextualSources.UV3:\r\n            case NodeGeometryContextualSources.UV4:\r\n            case NodeGeometryContextualSources.UV5:\r\n            case NodeGeometryContextualSources.UV6:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\r\n                break;\r\n            case NodeGeometryContextualSources.VertexID:\r\n            case NodeGeometryContextualSources.GeometryID:\r\n            case NodeGeometryContextualSources.CollectionID:\r\n            case NodeGeometryContextualSources.FaceID:\r\n            case NodeGeometryContextualSources.LoopID:\r\n            case NodeGeometryContextualSources.InstanceID:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Int;\r\n                break;\r\n        }\r\n\r\n        if (this.output) {\r\n            this.output.type = this._type;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param type defines the type of the input (can be set to NodeGeometryBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, type: NodeGeometryBlockConnectionPointTypes = NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n        super(name);\r\n\r\n        this._type = type;\r\n        this._isInput = true;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeGeometryBlockConnectionPointTypes.Float) {\r\n            if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryInputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        this.contextualValue = NodeGeometryContextualSources.None;\r\n        switch (this.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n            case NodeGeometryBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isContextual) {\r\n            this.output._storedValue = null;\r\n            this.output._storedFunction = (state) => {\r\n                return state.getContextualValue(this._contextualSource);\r\n            };\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = this.value;\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isContextual) {\r\n            return (\r\n                super._dumpPropertiesCode() + `${variableName}.contextualValue = BABYLON.NodeGeometryContextualSources.${NodeGeometryContextualSources[this._contextualSource]};\\n`\r\n            );\r\n        }\r\n        const codes: string[] = [];\r\n\r\n        let valueString = \"\";\r\n\r\n        switch (this.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Float:\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n                valueString = `${this.value}`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                break;\r\n        }\r\n\r\n        // Common Property \"Value\"\r\n        codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n        // Float-Value-Specific Properties\r\n        if (this.type === NodeGeometryBlockConnectionPointTypes.Float || this.type === NodeGeometryBlockConnectionPointTypes.Int) {\r\n            codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`);\r\n        }\r\n\r\n        codes.push(\"\");\r\n\r\n        return super._dumpPropertiesCode() + codes.join(\";\\n\");\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.contextualValue = this.contextualValue;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n\r\n        if (this._storedValue !== null && !this.isContextual) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this.contextualValue = serializationObject.contextualValue;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryInputBlock\", GeometryInputBlock);\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Enum defining the type of properties that can be edited in the property pages in the node editor\r\n */\r\nexport enum PropertyTypeForEdition {\r\n    /** property is a boolean */\r\n    Boolean,\r\n    /** property is a float */\r\n    Float,\r\n    /** property is a int */\r\n    Int,\r\n    /** property is a Vector2 */\r\n    Vector2,\r\n    /** property is a list of values */\r\n    List,\r\n}\r\n\r\n/**\r\n * Interface that defines an option in a variable of type list\r\n */\r\nexport interface IEditablePropertyListOption {\r\n    /** label of the option */\r\n    label: string;\r\n    /** value of the option */\r\n    value: number;\r\n}\r\n\r\n/**\r\n * Interface that defines the options available for an editable property\r\n */\r\nexport interface IEditablePropertyOption {\r\n    /** min value */\r\n    min?: number;\r\n    /** max value */\r\n    max?: number;\r\n    /** notifiers: indicates which actions to take when the property is changed */\r\n    notifiers?: {\r\n        /** the entity should be rebuilt */\r\n        rebuild?: boolean;\r\n        /** the preview should be updated */\r\n        update?: boolean;\r\n        /** the onPreviewCommandActivated observer of the preview manager should be triggered */\r\n        activatePreviewCommand?: boolean;\r\n        /** a callback to trigger */\r\n        callback?: (scene: Nullable<Scene>, block: any) => boolean | undefined | void;\r\n        /** a callback to validate the property. Returns true if the property is ok, else false. If false, the rebuild/update/callback events won't be called */\r\n        onValidation?: (block: any, propertyName: string) => boolean;\r\n    };\r\n    /** list of the options for a variable of type list */\r\n    options?: IEditablePropertyListOption[];\r\n}\r\n\r\n/**\r\n * Interface that describes an editable property\r\n */\r\nexport interface IPropertyDescriptionForEdition {\r\n    /** name of the property */\r\n    propertyName: string;\r\n    /** display name of the property */\r\n    displayName: string;\r\n    /** type of the property */\r\n    type: PropertyTypeForEdition;\r\n    /** group of the property - all properties with the same group value will be displayed in a specific section */\r\n    groupName: string;\r\n    /** options for the property */\r\n    options: IEditablePropertyOption;\r\n}\r\n\r\n/**\r\n * Decorator that flags a property in a node block as being editable\r\n * @param displayName\r\n * @param propertyType\r\n * @param groupName\r\n * @param options\r\n */\r\nexport function editableInPropertyPage(\r\n    displayName: string,\r\n    propertyType: PropertyTypeForEdition = PropertyTypeForEdition.Boolean,\r\n    groupName: string = \"PROPERTIES\",\r\n    options?: IEditablePropertyOption\r\n) {\r\n    return (target: any, propertyKey: string) => {\r\n        let propStore: IPropertyDescriptionForEdition[] = target._propStore;\r\n        if (!propStore) {\r\n            propStore = [];\r\n            target._propStore = propStore;\r\n        }\r\n        propStore.push({\r\n            propertyName: propertyKey,\r\n            displayName: displayName,\r\n            type: propertyType,\r\n            groupName: groupName,\r\n            options: options ?? {},\r\n        });\r\n    };\r\n}\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { CreateSegmentedBoxVertexData } from \"core/Meshes/Builders/boxBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate box geometry data\r\n */\r\nexport class BoxBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new BoxBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"size\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"width\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"depth\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 1);\r\n        this.registerInput(\"subdivisionsX\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n        this.registerInput(\"subdivisionsY\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n        this.registerInput(\"subdivisionsZ\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"BoxBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the size input component\r\n     */\r\n    public get size(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the width input component\r\n     */\r\n    public get width(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth input component\r\n     */\r\n    public get depth(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsX input component\r\n     */\r\n    public get subdivisionsX(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsY input component\r\n     */\r\n    public get subdivisionsY(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsZ input component\r\n     */\r\n    public get subdivisionsZ(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (this.size.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected && !this.height.isConnected && !this.depth.isConnected) {\r\n            const sizeInput = new GeometryInputBlock(\"Size\");\r\n            sizeInput.value = 1;\r\n            sizeInput.output.connectTo(this.size);\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected) {\r\n            const widthInput = new GeometryInputBlock(\"Width\");\r\n            widthInput.value = 1;\r\n            widthInput.output.connectTo(this.width);\r\n        }\r\n\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n\r\n        if (!this.depth.isConnected) {\r\n            const depthInput = new GeometryInputBlock(\"Depth\");\r\n            depthInput.value = 1;\r\n            depthInput.output.connectTo(this.depth);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            size?: number;\r\n            width?: number;\r\n            height?: number;\r\n            depth?: number;\r\n            segments?: number;\r\n            widthSegments?: number;\r\n            heightSegments?: number;\r\n            depthSegments?: number;\r\n        } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.size = this.size.getConnectedValue(state);\r\n            options.width = this.width.getConnectedValue(state);\r\n            options.height = this.height.getConnectedValue(state);\r\n            options.depth = this.depth.getConnectedValue(state);\r\n\r\n            const subdivisions = this.subdivisions.getConnectedValue(state);\r\n            const subdivisionsX = this.subdivisionsX.getConnectedValue(state);\r\n            const subdivisionsY = this.subdivisionsY.getConnectedValue(state);\r\n            const subdivisionsZ = this.subdivisionsZ.getConnectedValue(state);\r\n\r\n            if (subdivisions) {\r\n                options.segments = subdivisions;\r\n            }\r\n\r\n            if (subdivisionsX) {\r\n                options.widthSegments = subdivisionsX;\r\n            }\r\n\r\n            if (subdivisionsY) {\r\n                options.heightSegments = subdivisionsY;\r\n            }\r\n\r\n            if (subdivisionsZ) {\r\n                options.depthSegments = subdivisionsZ;\r\n            }\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateSegmentedBoxVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BoxBlock\", BoxBlock);\r\n", "import { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GeometryOutputBlock } from \"./Blocks/geometryOutputBlock\";\r\nimport type { NodeGeometryBlock } from \"./nodeGeometryBlock\";\r\nimport { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { SerializationHelper, serialize } from \"../../Misc/decorators\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\nimport { BoxBlock } from \"./Blocks/Sources/boxBlock\";\r\nimport type { GeometryInputBlock } from \"./Blocks/geometryInputBlock\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport type { TeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\nimport type { TeleportInBlock } from \"./Blocks/Teleport/teleportInBlock\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Engine } from \"../../Engines/engine\";\r\n\r\n// declare NODEGEOMETRYEDITOR namespace for compilation issue\r\ndeclare let NODEGEOMETRYEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node geometry editor\r\n */\r\nexport interface INodeGeometryEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the NGE */\r\n    nodeGeometryEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n        hostScene?: Scene;\r\n        hostMesh?: Mesh;\r\n    };\r\n}\r\n\r\n/**\r\n * Defines a node based geometry\r\n * @see demo at https://playground.babylonjs.com#PYY6XE#69\r\n */\r\nexport class NodeGeometry {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _buildId: number = NodeGeometry._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _vertexData: Nullable<VertexData> = null;\r\n    private _buildExecutionTime: number = 0;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private BJSNODEGEOMETRYEDITOR = this._getGlobalNodeGeometryEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeGeometryEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEGEOMETRYEDITOR !== \"undefined\") {\r\n            return NODEGEOMETRYEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeGeometryEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return this._buildExecutionTime;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nge.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks: NodeGeometryBlock[] = [];\r\n\r\n    /**\r\n     * Observable raised when the geometry is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeGeometry>();\r\n\r\n    /** Gets or sets the GeometryOutputBlock used to gather the final geometry data */\r\n    public outputBlock: Nullable<GeometryOutputBlock> = null;\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The name of the geometry\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * A free comment about the geometry\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param name defines the name of the geometry\r\n     */\r\n    public constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the geometry e.g. \"NodeGeometry\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeGeometry\";\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeGeometryBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: GeometryInputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as GeometryInputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Launch the node geometry editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeGeometryEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\r\n            if (typeof this.BJSNODEGEOMETRYEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeGeometry.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadBabylonScript(editorUrl, () => {\r\n                    this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\r\n                    this._createNodeEditor(config?.nodeGeometryEditorConfig);\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor(config?.nodeGeometryEditorConfig);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor(additionalConfig?: any) {\r\n        const nodeEditorConfig: any = {\r\n            nodeGeometry: this,\r\n            ...additionalConfig,\r\n        };\r\n        this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(nodeEditorConfig);\r\n    }\r\n\r\n    /**\r\n     * Build the final geometry\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = false) {\r\n        this._buildWasSuccessful = false;\r\n\r\n        if (!this.outputBlock) {\r\n            throw \"You must define the outputBlock property before building the geometry\";\r\n        }\r\n        const now = PrecisionDate.Now;\r\n        // Initialize blocks\r\n        this._initializeBlock(this.outputBlock, autoConfigure);\r\n\r\n        // Build\r\n        const state = new NodeGeometryBuildState();\r\n\r\n        state.buildId = this._buildId;\r\n        state.verbose = verbose;\r\n\r\n        this.outputBlock.build(state);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeGeometry._BuildIdGenerator++;\r\n        }\r\n\r\n        this._buildExecutionTime = PrecisionDate.Now - now;\r\n\r\n        // Errors\r\n        state.emitErrors();\r\n\r\n        this._buildWasSuccessful = true;\r\n        this._vertexData = state.vertexData;\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a mesh from the geometry blocks\r\n     * @param name defines the name of the mesh\r\n     * @param scene The scene the mesh is scoped to\r\n     * @returns The new mesh\r\n     */\r\n    public createMesh(name: string, scene: Nullable<Scene> = null): Nullable<Mesh> {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        if (!this._vertexData) {\r\n            return null;\r\n        }\r\n\r\n        const mesh = new Mesh(name, scene);\r\n        this._vertexData.applyToMesh(mesh);\r\n\r\n        mesh._internalMetadata = mesh._internalMetadata || {};\r\n        mesh._internalMetadata.nodeGeometry = this;\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a mesh from the geometry blocks\r\n     * @param mesh the mesh to update\r\n     * @returns True if successfully updated\r\n     */\r\n    public updateMesh(mesh: Mesh) {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        if (!this._vertexData) {\r\n            return false;\r\n        }\r\n\r\n        this._vertexData.applyToMesh(mesh);\r\n\r\n        mesh._internalMetadata = mesh._internalMetadata || {};\r\n        mesh._internalMetadata.nodeGeometry = this;\r\n\r\n        return mesh;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeGeometryBlock, autoConfigure = true) {\r\n        node.initialize();\r\n        if (autoConfigure) {\r\n            node.autoConfigure();\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._initializeBlock(block, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current geometry\r\n     */\r\n    public clear() {\r\n        this.outputBlock = null;\r\n        this.attachedBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current geometry\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeGeometryBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block === this.outputBlock) {\r\n            this.outputBlock = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the geometry\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public parseSerializedObject(source: any, merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeGeometryBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeGeometryBlock = new blockType();\r\n                block._deserialize(parsedBlock);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Reconnect teleportation\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isTeleportOut) {\r\n                const teleportOut = block as TeleportOutBlock;\r\n                const id = teleportOut._tempEntryPointUniqueId;\r\n                if (id) {\r\n                    const source = map[id] as TeleportInBlock;\r\n                    if (source) {\r\n                        source.attachToEndpoint(teleportOut);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && parsedBlock.inputs.some((i: any) => i.targetConnectionName) && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodeId) {\r\n            this.outputBlock = map[source.outputNodeId] as GeometryOutputBlock;\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeGeometryBlock, source: any, map: { [key: number]: NodeGeometryBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this geometry\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeGeometryBlock[] = [];\r\n        const blocks: NodeGeometryBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        if (this.outputBlock) {\r\n            this._gatherBlocks(this.outputBlock, blocks);\r\n        }\r\n\r\n        // Generate\r\n        let codeString = `let nodeGeometry = new BABYLON.NodeGeometry(\"${this.name || \"node geometry\"}\");\\n`;\r\n        for (const node of blocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        if (this.outputBlock) {\r\n            // Connections\r\n            alreadyDumped = [];\r\n            codeString += \"// Connections\\n\";\r\n            codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n\r\n            // Output nodes\r\n            codeString += \"// Output nodes\\n\";\r\n            codeString += `nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};\\n`;\r\n            codeString += `nodeGeometry.build();\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeGeometryBlock, list: NodeGeometryBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (rootNode.isTeleportOut) {\r\n            const block = rootNode as TeleportOutBlock;\r\n            if (block.entryPoint) {\r\n                this._gatherBlocks(block.entryPoint, list);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current geometry and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Source\r\n        const dataBlock = new BoxBlock(\"Box\");\r\n        dataBlock.autoConfigure();\r\n\r\n        // Final output\r\n        const output = new GeometryOutputBlock(\"Geometry Output\");\r\n        dataBlock.geometry.connectTo(output.geometry);\r\n\r\n        this.outputBlock = output;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current geometry.\r\n     * @param name defines the name to use for the new geometry\r\n     */\r\n    public clone(name: string): NodeGeometry {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeGeometry(name), this);\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this geometry in a JSON representation\r\n     * @param selectedBlocks defines the list of blocks to save (if null the whole geometry will be saved)\r\n     * @returns the serialized geometry object\r\n     */\r\n    public serialize(selectedBlocks?: NodeGeometryBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeGeometryBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeGeometry\";\r\n            if (this.outputBlock) {\r\n                serializationObject.outputNodeId = this.outputBlock.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Disposes the ressources\r\n     */\r\n    public dispose(): void {\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        this.onBuildObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Creates a new node geometry set to default basic configuration\r\n     * @param name defines the name of the geometry\r\n     * @returns a new NodeGeometry\r\n     */\r\n    public static CreateDefault(name: string) {\r\n        const nodeGeometry = new NodeGeometry(name);\r\n\r\n        nodeGeometry.setToDefault();\r\n        nodeGeometry.build();\r\n\r\n        return nodeGeometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a node geometry from parsed geometry data\r\n     * @param source defines the JSON representation of the geometry\r\n     * @returns a new node geometry\r\n     */\r\n    public static Parse(source: any): NodeGeometry {\r\n        const nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(source.name), source, null);\r\n\r\n        nodeGeometry.parseSerializedObject(source);\r\n        nodeGeometry.build();\r\n\r\n        return nodeGeometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a node geometry from a snippet saved by the node geometry editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param nodeGeometry defines a node geometry to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node geometry\r\n     * @returns a promise that will resolve to the new node geometry\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, nodeGeometry?: NodeGeometry, skipBuild: boolean = false): Promise<NodeGeometry> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeGeometry.CreateDefault(\"blank\"));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeGeometry);\r\n\r\n                        if (!nodeGeometry) {\r\n                            nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(snippetId), serializationObject, null);\r\n                        }\r\n\r\n                        nodeGeometry.parseSerializedObject(serializationObject);\r\n                        nodeGeometry.snippetId = snippetId;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeGeometry.build();\r\n                            }\r\n                            resolve(nodeGeometry);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport type { FloatArray } from \"../../../types\";\r\nimport { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n/**\r\n * Block used to extract unique positions from a geometry\r\n */\r\nexport class GeometryOptimizeBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Define the epsilon used to compare similar positions\r\n     */\r\n    @editableInPropertyPage(\"Epsilon\", PropertyTypeForEdition.Float, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public epsilon = Epsilon;\r\n\r\n    /**\r\n     * Creates a new GeometryOptimizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryOptimizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            if (!this.geometry.isConnected) {\r\n                return null;\r\n            }\r\n            const vertexData = this.geometry.getConnectedValue(state);\r\n            const newPositions: FloatArray = [];\r\n            const newIndicesMap: { [key: number]: number } = {};\r\n\r\n            for (let index = 0; index < vertexData.positions.length; index += 3) {\r\n                const x = vertexData.positions[index];\r\n                const y = vertexData.positions[index + 1];\r\n                const z = vertexData.positions[index + 2];\r\n\r\n                // check if we already have it\r\n                let found = false;\r\n                for (let checkIndex = 0; checkIndex < newPositions.length; checkIndex += 3) {\r\n                    if (\r\n                        Scalar.WithinEpsilon(x, newPositions[checkIndex], this.epsilon) &&\r\n                        Scalar.WithinEpsilon(y, newPositions[checkIndex + 1], this.epsilon) &&\r\n                        Scalar.WithinEpsilon(z, newPositions[checkIndex + 2], this.epsilon)\r\n                    ) {\r\n                        newIndicesMap[index / 3] = checkIndex / 3;\r\n                        found = true;\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    newIndicesMap[index / 3] = newPositions.length / 3;\r\n                    newPositions.push(x, y, z);\r\n                }\r\n            }\r\n            const newVertexData = new VertexData();\r\n            newVertexData.positions = newPositions;\r\n            newVertexData.indices = vertexData.indices.map((index: number) => newIndicesMap[index]);\r\n\r\n            return newVertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        codeString += `${this._codeVariableName}.epsilon = ${this.epsilon};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n        serializationObject.epsilon = this.epsilon;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n        this.epsilon = serializationObject.epsilon;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryOptimizeBlock\", GeometryOptimizeBlock);\r\n", "import { CreatePlaneVertexData } from \"../../../../Meshes/Builders/planeBuilder\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate plane geometry data\r\n */\r\nexport class PlaneBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new PlaneBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"size\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"width\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"PlaneBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the size input component\r\n     */\r\n    public get size(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the width input component\r\n     */\r\n    public get width(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (this.size.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected && !this.height.isConnected) {\r\n            const sizeInput = new GeometryInputBlock(\"Size\");\r\n            sizeInput.value = 1;\r\n            sizeInput.output.connectTo(this.size);\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected) {\r\n            const widthInput = new GeometryInputBlock(\"Width\");\r\n            widthInput.value = 1;\r\n            widthInput.output.connectTo(this.width);\r\n        }\r\n\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.size = this.size.getConnectedValue(state);\r\n            options.width = this.width.getConnectedValue(state);\r\n            options.height = this.height.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreatePlaneVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PlaneBlock\", PlaneBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { VertexData } from \"../../../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate a user defined mesh geometry data\r\n */\r\nexport class MeshBlock extends NodeGeometryBlock {\r\n    private _mesh: Nullable<Mesh>;\r\n    private _cachedVertexData: Nullable<VertexData> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that winding order needs to be reserved\r\n     */\r\n    public reverseWindingOrder = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block should serialize its cached data\r\n     */\r\n    @editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public serializedCachedData = false;\r\n\r\n    /**\r\n     * Gets or sets the mesh to use to get vertex data\r\n     */\r\n    public get mesh() {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<Mesh>) {\r\n        this._mesh = value;\r\n    }\r\n\r\n    /**\r\n     * Create a new MeshBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MeshBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the block is using cached data\r\n     */\r\n    public get isUsingCachedData() {\r\n        return !this.mesh && !!this._cachedVertexData;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Remove stored data\r\n     */\r\n    public cleanData() {\r\n        this._mesh = null;\r\n        this._cachedVertexData = null;\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this._mesh) {\r\n            if (this._cachedVertexData) {\r\n                this.geometry._storedValue = this._cachedVertexData.clone();\r\n            } else {\r\n                this.geometry._storedValue = null;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const vertexData = VertexData.ExtractFromMesh(this._mesh, false, true);\r\n        this._cachedVertexData = null;\r\n\r\n        if (this.reverseWindingOrder && vertexData.indices) {\r\n            for (let index = 0; index < vertexData.indices.length; index += 3) {\r\n                const tmp = vertexData.indices[index];\r\n                vertexData.indices[index] = vertexData.indices[index + 2];\r\n                vertexData.indices[index + 2] = tmp;\r\n            }\r\n        }\r\n\r\n        this.geometry._storedFunction = () => {\r\n            return vertexData.clone();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.serializedCachedData = this.serializedCachedData;\r\n\r\n        if (this.serializedCachedData) {\r\n            if (this._mesh) {\r\n                serializationObject.cachedVertexData = VertexData.ExtractFromMesh(this._mesh, false, true).serialize();\r\n            } else if (this._cachedVertexData) {\r\n                serializationObject.cachedVertexData = this._cachedVertexData.serialize();\r\n            }\r\n        }\r\n\r\n        serializationObject.reverseWindingOrder = this.reverseWindingOrder;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.cachedVertexData) {\r\n            this._cachedVertexData = VertexData.Parse(serializationObject.cachedVertexData);\r\n        }\r\n\r\n        this.serializedCachedData = !!serializationObject.serializedCachedData;\r\n        this.reverseWindingOrder = serializationObject.reverseWindingOrder;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MeshBlock\", MeshBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { CreateIcoSphereVertexData } from \"core/Meshes/Builders/icoSphereBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate icosphere geometry data\r\n */\r\nexport class IcoSphereBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new IcoSphereBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"radiusX\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"radiusY\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"radiusZ\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 4);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"IcoSphereBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the radius input component\r\n     */\r\n    public get radius(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the radiusX input component\r\n     */\r\n    public get radiusX(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the radiusY input component\r\n     */\r\n    public get radiusY(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the radiusZ input component\r\n     */\r\n    public get radiusZ(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.radius.isConnected) {\r\n            const radiusInput = new GeometryInputBlock(\"Radius\");\r\n            radiusInput.value = 0.2;\r\n            radiusInput.output.connectTo(this.radius);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            radius?: number;\r\n            radiusX?: number;\r\n            radiusY?: number;\r\n            radiusZ?: number;\r\n            flat?: boolean;\r\n            subdivisions?: number;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n        } = {};\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.radius = this.radius.getConnectedValue(state);\r\n            options.subdivisions = this.subdivisions.getConnectedValue(state);\r\n            options.radiusX = this.radiusX.getConnectedValue(state);\r\n            options.radiusY = this.radiusY.getConnectedValue(state);\r\n            options.radiusZ = this.radiusZ.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateIcoSphereVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.IcoSphereBlock\", IcoSphereBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { CreateSphereVertexData } from \"core/Meshes/Builders/sphereBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate sphere geometry data\r\n */\r\nexport class SphereBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new SphereBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"segments\", NodeGeometryBlockConnectionPointTypes.Int, true, 32);\r\n        this.registerInput(\"diameter\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"diameterX\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"diameterY\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"diameterZ\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"arc\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"slice\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SphereBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the segments input component\r\n     */\r\n    public get segments(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameter input component\r\n     */\r\n    public get diameter(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameterX input component\r\n     */\r\n    public get diameterX(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameterY input component\r\n     */\r\n    public get diameterY(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameterZ input component\r\n     */\r\n    public get diameterZ(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the arc input component\r\n     */\r\n    public get arc(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the slice input component\r\n     */\r\n    public get slice(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.diameter.isConnected) {\r\n            const diameterInput = new GeometryInputBlock(\"Diameter\");\r\n            diameterInput.value = 1;\r\n            diameterInput.output.connectTo(this.diameter);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            segments?: number;\r\n            diameter?: number;\r\n            diameterX?: number;\r\n            diameterY?: number;\r\n            diameterZ?: number;\r\n            arc?: number;\r\n            slice?: number;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n            dedupTopBottomIndices?: boolean;\r\n        } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.segments = this.segments.getConnectedValue(state);\r\n            options.diameter = this.diameter.getConnectedValue(state);\r\n            options.diameterX = this.diameterX.getConnectedValue(state);\r\n            options.diameterY = this.diameterY.getConnectedValue(state);\r\n            options.diameterZ = this.diameterZ.getConnectedValue(state);\r\n            options.arc = this.arc.getConnectedValue(state);\r\n            options.slice = this.slice.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateSphereVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SphereBlock\", SphereBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { CreateGroundVertexData } from \"../../../Builders/groundBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate grid geometry data\r\n */\r\nexport class GridBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new GridBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"width\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 1);\r\n        this.registerInput(\"subdivisionsX\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n        this.registerInput(\"subdivisionsY\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GridBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the width input component\r\n     */\r\n    public get width(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsX input component\r\n     */\r\n    public get subdivisionsX(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsY input component\r\n     */\r\n    public get subdivisionsY(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.width.isConnected) {\r\n            const widthInput = new GeometryInputBlock(\"Width\");\r\n            widthInput.value = 1;\r\n            widthInput.output.connectTo(this.width);\r\n        }\r\n\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.width = this.width.getConnectedValue(state);\r\n            options.height = this.height.getConnectedValue(state);\r\n            options.subdivisions = this.subdivisions.getConnectedValue(state);\r\n            options.subdivisionsX = this.subdivisionsX.getConnectedValue(state);\r\n            options.subdivisionsY = this.subdivisionsY.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateGroundVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridBlock\", GridBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { CreateTorusVertexData } from \"core/Meshes/Builders/torusBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate torus geometry data\r\n */\r\nexport class TorusBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new TorusBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"diameter\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"thickness\", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5);\r\n        this.registerInput(\"tessellation\", NodeGeometryBlockConnectionPointTypes.Int, true, 16);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TorusBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the diameter input component\r\n     */\r\n    public get diameter(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the thickness input component\r\n     */\r\n    public get thickness(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tessellation input component\r\n     */\r\n    public get tessellation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.diameter.isConnected) {\r\n            const diameterInput = new GeometryInputBlock(\"Diameter\");\r\n            diameterInput.value = 1;\r\n            diameterInput.output.connectTo(this.diameter);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            diameter?: number;\r\n            thickness?: number;\r\n            tessellation?: number;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n        } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.thickness = this.thickness.getConnectedValue(state);\r\n            options.diameter = this.diameter.getConnectedValue(state);\r\n            options.tessellation = this.tessellation.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateTorusVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TorusBlock\", TorusBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { CreateCylinderVertexData } from \"core/Meshes/Builders/cylinderBuilder\";\r\nimport type { Color4 } from \"../../../../Maths/math.color\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate cylinder geometry data\r\n */\r\nexport class CylinderBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new SphereBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 25);\r\n        this.registerInput(\"diameter\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"diameterTop\", NodeGeometryBlockConnectionPointTypes.Float, true, -1);\r\n        this.registerInput(\"diameterBottom\", NodeGeometryBlockConnectionPointTypes.Float, true, -1);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 1);\r\n        this.registerInput(\"tessellation\", NodeGeometryBlockConnectionPointTypes.Int, true, 24);\r\n        this.registerInput(\"arc\", NodeGeometryBlockConnectionPointTypes.Float, true, 1.0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"CylinderBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameter input component\r\n     */\r\n    public get diameter(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameterTop input component\r\n     */\r\n    public get diameterTop(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the diameterBottom input component\r\n     */\r\n    public get diameterBottom(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the tessellation input component\r\n     */\r\n    public get tessellation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the arc input component\r\n     */\r\n    public get arc(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.diameter.isConnected) {\r\n            const diameterInput = new GeometryInputBlock(\"Diameter\");\r\n            diameterInput.value = 1;\r\n            diameterInput.output.connectTo(this.diameter);\r\n        }\r\n\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            height?: number;\r\n            diameterTop?: number;\r\n            diameterBottom?: number;\r\n            diameter?: number;\r\n            tessellation?: number;\r\n            subdivisions?: number;\r\n            arc?: number;\r\n            faceColors?: Color4[];\r\n            faceUV?: Vector4[];\r\n            hasRings?: boolean;\r\n            enclose?: boolean;\r\n            cap?: number;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n        } = {};\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.height = this.height.getConnectedValue(state);\r\n            options.diameter = this.diameter.getConnectedValue(state);\r\n            options.diameterTop = this.diameterTop.getConnectedValue(state);\r\n            options.diameterBottom = this.diameterBottom.getConnectedValue(state);\r\n\r\n            if (options.diameterTop === -1) {\r\n                options.diameterTop = options.diameter;\r\n            }\r\n\r\n            if (options.diameterBottom === -1) {\r\n                options.diameterBottom = options.diameter;\r\n            }\r\n\r\n            options.tessellation = this.tessellation.getConnectedValue(state);\r\n            options.subdivisions = this.subdivisions.getConnectedValue(state);\r\n            options.arc = this.arc.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateCylinderVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CylinderBlock\", CylinderBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { CreateCapsuleVertexData } from \"core/Meshes/Builders/capsuleBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate capsule geometry data\r\n */\r\nexport class CapsuleBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new CapsuleBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Float, true, 0.25);\r\n        this.registerInput(\"tessellation\", NodeGeometryBlockConnectionPointTypes.Int, true, 16);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 2);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"CapsuleBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the radius input component\r\n     */\r\n    public get radius(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tessellation input component\r\n     */\r\n    public get tessellation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n        if (!this.radius.isConnected) {\r\n            const radiusInput = new GeometryInputBlock(\"Radius\");\r\n            radiusInput.value = 0.2;\r\n            radiusInput.output.connectTo(this.radius);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            orientation?: Vector3;\r\n            subdivisions?: number;\r\n            tessellation?: number;\r\n            height?: number;\r\n            radius?: number;\r\n            capSubdivisions?: number;\r\n            radiusTop?: number;\r\n            radiusBottom?: number;\r\n            topCapSubdivisions?: number;\r\n            bottomCapSubdivisions?: number;\r\n            updatable?: boolean;\r\n        } = {};\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.height = this.height.getConnectedValue(state);\r\n            options.radius = this.radius.getConnectedValue(state);\r\n            options.tessellation = this.tessellation.getConnectedValue(state);\r\n            options.subdivisions = this.subdivisions.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateCapsuleVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CapsuleBlock\", CapsuleBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { CreateDiscVertexData } from \"core/Meshes/Builders/discBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate disc geometry data\r\n */\r\nexport class DiscBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new DiscBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5);\r\n        this.registerInput(\"tessellation\", NodeGeometryBlockConnectionPointTypes.Int, true, 64);\r\n        this.registerInput(\"arc\", NodeGeometryBlockConnectionPointTypes.Float, true, 1.0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"DiscBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the radius input component\r\n     */\r\n    public get radius(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tessellation input component\r\n     */\r\n    public get tessellation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the arc input component\r\n     */\r\n    public get arc(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.radius.isConnected) {\r\n            const radiusInput = new GeometryInputBlock(\"Radius\");\r\n            radiusInput.value = 0.2;\r\n            radiusInput.output.connectTo(this.radius);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            radius?: number;\r\n            tessellation?: number;\r\n            arc?: number;\r\n            sideOrientation?: number;\r\n            frontUVs?: Vector4;\r\n            backUVs?: Vector4;\r\n        } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.radius = this.radius.getConnectedValue(state);\r\n            options.tessellation = this.tessellation.getConnectedValue(state);\r\n            options.arc = this.arc.getConnectedValue(state);\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateDiscVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            const value = func(state);\r\n            this.geometry._storedFunction = () => {\r\n                this.geometry._executionCount = 1;\r\n                return value.clone();\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DiscBlock\", DiscBlock);\r\n", "import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Defines a block used to generate a null geometry data\r\n */\r\nexport class NullBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new NullBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NullBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.geometry._storedValue = null;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NullBlock\", NullBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../../Meshes/mesh.vertexData\";\r\nimport type { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to set positions for a geometry\r\n */\r\nexport class SetPositionsBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new SetPositionsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"positions\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetPositionsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the positions input component\r\n     */\r\n    public get positions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n\r\n            if (this._vertexData) {\r\n                this._vertexData = this._vertexData.clone(); // Preserve source data\r\n            }\r\n\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this.positions.isConnected) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            const vertexCount = this._vertexData.positions.length / 3;\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const tempVector3 = this.positions.getConnectedValue(state) as Vector3;\r\n                if (tempVector3) {\r\n                    tempVector3.toArray(this._vertexData.positions, this._currentIndex * 3);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetPositionsBlock\", SetPositionsBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport type { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to set normals for a geometry\r\n */\r\nexport class SetNormalsBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new SetNormalsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"normals\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetNormalsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normals input component\r\n     */\r\n    public get normals(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n\r\n            if (this._vertexData) {\r\n                this._vertexData = this._vertexData.clone(); // Preserve source data\r\n            }\r\n\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            if (!this.normals.isConnected) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = this._vertexData;\r\n                return;\r\n            }\r\n\r\n            if (!this._vertexData.normals) {\r\n                this._vertexData.normals = [];\r\n            }\r\n\r\n            // Processing\r\n            const vertexCount = this._vertexData.positions.length / 3;\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const tempVector3 = this.normals.getConnectedValue(state) as Vector3;\r\n                if (tempVector3) {\r\n                    tempVector3.toArray(this._vertexData.normals, this._currentIndex * 3);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetNormalsBlock\", SetNormalsBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport type { Vector2 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to set texture coordinates for a geometry\r\n */\r\nexport class SetUVsBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Gets or sets a value indicating which UV to set\r\n     */\r\n    @editableInPropertyPage(\"Texture coordinates index\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { update: true },\r\n        options: [\r\n            { label: \"UV1\", value: 0 },\r\n            { label: \"UV2\", value: 1 },\r\n            { label: \"UV3\", value: 2 },\r\n            { label: \"UV4\", value: 3 },\r\n            { label: \"UV5\", value: 4 },\r\n            { label: \"UV6\", value: 5 },\r\n        ],\r\n    })\r\n    public textureCoordinateIndex = 0;\r\n\r\n    /**\r\n     * Create a new SetUVsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"uvs\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetUVsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the uvs input component\r\n     */\r\n    public get uvs(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n\r\n            if (this._vertexData) {\r\n                this._vertexData = this._vertexData.clone(); // Preserve source data\r\n            }\r\n\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            if (!this.uvs.isConnected) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = this._vertexData;\r\n                return;\r\n            }\r\n\r\n            const uvs: number[] = [];\r\n\r\n            // Processing\r\n            const vertexCount = this._vertexData.positions.length / 3;\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const tempVector2 = this.uvs.getConnectedValue(state) as Vector2;\r\n                if (tempVector2) {\r\n                    tempVector2.toArray(uvs, this._currentIndex * 2);\r\n                }\r\n            }\r\n\r\n            switch (this.textureCoordinateIndex) {\r\n                case 0:\r\n                    this._vertexData.uvs = uvs;\r\n                    break;\r\n                case 1:\r\n                    this._vertexData.uvs2 = uvs;\r\n                    break;\r\n                case 2:\r\n                    this._vertexData.uvs3 = uvs;\r\n                    break;\r\n                case 3:\r\n                    this._vertexData.uvs4 = uvs;\r\n                    break;\r\n                case 4:\r\n                    this._vertexData.uvs5 = uvs;\r\n                    break;\r\n                case 5:\r\n                    this._vertexData.uvs6 = uvs;\r\n                    break;\r\n            }\r\n\r\n            // Storage\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.textureCoordinateIndex};\\n`;\r\n        codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n        serializationObject.textureCoordinateIndex = this.textureCoordinateIndex;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.textureCoordinateIndex = serializationObject.textureCoordinateIndex;\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetUVsBlock\", SetUVsBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to set colors for a geometry\r\n */\r\nexport class SetColorsBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new SetColorsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"colors\", NodeGeometryBlockConnectionPointTypes.Vector4);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetColorsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the colors input component\r\n     */\r\n    public get colors(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n\r\n            if (this._vertexData) {\r\n                this._vertexData = this._vertexData.clone(); // Preserve source data\r\n            }\r\n\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            if (!this.colors.isConnected) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = this._vertexData;\r\n                return;\r\n            }\r\n\r\n            if (!this._vertexData.colors) {\r\n                this._vertexData.colors = [];\r\n            }\r\n\r\n            // Processing\r\n            const vertexCount = this._vertexData.positions.length / 3;\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const tempVector4 = this.colors.getConnectedValue(state) as Vector4;\r\n                if (tempVector4) {\r\n                    tempVector4.toArray(this._vertexData.colors, this._currentIndex * 4);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetColorsBlock\", SetColorsBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport type { Vector4 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to set tangents for a geometry\r\n */\r\nexport class SetTangentsBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new SetTangentsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"tangents\", NodeGeometryBlockConnectionPointTypes.Vector4);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetTangentsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangents input component\r\n     */\r\n    public get tangents(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n\r\n            if (this._vertexData) {\r\n                this._vertexData = this._vertexData.clone(); // Preserve source data\r\n            }\r\n\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            if (!this.tangents.isConnected) {\r\n                state.restoreGeometryContext();\r\n                state.restoreExecutionContext();\r\n                this.output._storedValue = this._vertexData;\r\n                return;\r\n            }\r\n\r\n            if (!this._vertexData.tangents) {\r\n                this._vertexData.tangents = [];\r\n            }\r\n\r\n            // Processing\r\n            const vertexCount = this._vertexData.positions.length / 3;\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const tempVector4 = this.tangents.getConnectedValue(state) as Vector4;\r\n                if (tempVector4) {\r\n                    tempVector4.toArray(this._vertexData.tangents, this._currentIndex * 4);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetTangentsBlock\", SetTangentsBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { Vector2, Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Math block\r\n */\r\nexport enum MathBlockOperations {\r\n    /** Add */\r\n    Add,\r\n    /** Subtract */\r\n    Subtract,\r\n    /** Multiply */\r\n    Multiply,\r\n    /** Divide */\r\n    Divide,\r\n    /** Max */\r\n    Max,\r\n    /** Min */\r\n    Min,\r\n}\r\n\r\n/**\r\n * Block used to apply math functions\r\n */\r\nexport class MathBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Add\", value: MathBlockOperations.Add },\r\n            { label: \"Subtract\", value: MathBlockOperations.Subtract },\r\n            { label: \"Multiply\", value: MathBlockOperations.Multiply },\r\n            { label: \"Divide\", value: MathBlockOperations.Divide },\r\n            { label: \"Max\", value: MathBlockOperations.Max },\r\n            { label: \"Min\", value: MathBlockOperations.Min },\r\n        ],\r\n    })\r\n    public operation = MathBlockOperations.Add;\r\n\r\n    /**\r\n     * Create a new MathBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"left\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MathBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left input component\r\n     */\r\n    public get left(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right input component\r\n     */\r\n    public get right(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        let func: (state: NodeGeometryBuildState) => any;\r\n        const left = this.left;\r\n        const right = this.right;\r\n\r\n        if (!left.isConnected || !right.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const isFloat = left.type === NodeGeometryBlockConnectionPointTypes.Float || left.type === NodeGeometryBlockConnectionPointTypes.Int;\r\n\r\n        switch (this.operation) {\r\n            case MathBlockOperations.Add: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) + right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).add(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Subtract: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) - right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).subtract(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Multiply: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) * right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).multiply(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Divide: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state) / right.getConnectedValue(state);\r\n                    };\r\n                } else {\r\n                    func = (state) => {\r\n                        return left.getConnectedValue(state).divide(state.adapt(right, left.type));\r\n                    };\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Min: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return Math.min(left.getConnectedValue(state), right.getConnectedValue(state));\r\n                    };\r\n                } else {\r\n                    switch (left.type) {\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                            func = (state) => {\r\n                                return Vector2.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                            func = (state) => {\r\n                                return Vector3.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                            func = (state) => {\r\n                                return Vector4.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case MathBlockOperations.Max: {\r\n                if (isFloat) {\r\n                    func = (state) => {\r\n                        return Math.max(left.getConnectedValue(state), right.getConnectedValue(state));\r\n                    };\r\n                } else {\r\n                    switch (left.type) {\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                            func = (state) => {\r\n                                return Vector2.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                            func = (state) => {\r\n                                return Vector3.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                        case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                            func = (state) => {\r\n                                return Vector4.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\r\n                            };\r\n                            break;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.output._storedFunction = (state) => {\r\n            if (left.type === NodeGeometryBlockConnectionPointTypes.Int) {\r\n                return func(state) | 0;\r\n            }\r\n            return func(state);\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${MathBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MathBlock\", MathBlock);\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\n\r\n/**\r\n * Defines a block used to move a value from a range to another\r\n */\r\nexport class MapRangeBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new MapRangeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"value\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"fromMin\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"fromMax\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"toMin\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"toMax\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector2);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector4);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MapRangeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the fromMin input component\r\n     */\r\n    public get fromMin(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the fromMax input component\r\n     */\r\n    public get fromMax(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the toMin input component\r\n     */\r\n    public get toMin(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the toMax input component\r\n     */\r\n    public get toMax(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this.value.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        this.output._storedFunction = (state) => {\r\n            const value = this.value.getConnectedValue(state);\r\n            const fromMin = this.fromMin.getConnectedValue(state);\r\n            const fromMax = this.fromMax.getConnectedValue(state);\r\n            const toMin = this.toMin.getConnectedValue(state);\r\n            const toMax = this.toMax.getConnectedValue(state);\r\n\r\n            const result = ((value - fromMin) / (fromMax - fromMin)) * (toMax - toMin) + toMin;\r\n\r\n            if (this.output.type === NodeGeometryBlockConnectionPointTypes.Int) {\r\n                return Math.floor(result);\r\n            }\r\n\r\n            return result;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MapRangeBlock\", MapRangeBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n/**\r\n * Conditions supported by the condition block\r\n */\r\nexport enum ConditionBlockTests {\r\n    /** Equal */\r\n    Equal,\r\n    /** NotEqual */\r\n    NotEqual,\r\n    /** LessThan */\r\n    LessThan,\r\n    /** GreaterThan */\r\n    GreaterThan,\r\n    /** LessOrEqual */\r\n    LessOrEqual,\r\n    /** GreaterOrEqual */\r\n    GreaterOrEqual,\r\n    /** Logical Exclusive OR */\r\n    Xor,\r\n    /** Logical Or */\r\n    Or,\r\n    /** Logical And */\r\n    And,\r\n}\r\n\r\n/**\r\n * Block used to evaluate a condition and return a true or false value\r\n */\r\nexport class ConditionBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the test used by the block\r\n     */\r\n    @editableInPropertyPage(\"Test\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Equal\", value: ConditionBlockTests.Equal },\r\n            { label: \"NotEqual\", value: ConditionBlockTests.NotEqual },\r\n            { label: \"LessThan\", value: ConditionBlockTests.LessThan },\r\n            { label: \"GreaterThan\", value: ConditionBlockTests.GreaterThan },\r\n            { label: \"LessOrEqual\", value: ConditionBlockTests.LessOrEqual },\r\n            { label: \"GreaterOrEqual\", value: ConditionBlockTests.GreaterOrEqual },\r\n            { label: \"Xor\", value: ConditionBlockTests.Xor },\r\n            { label: \"Or\", value: ConditionBlockTests.Or },\r\n            { label: \"And\", value: ConditionBlockTests.And },\r\n        ],\r\n    })\r\n    public test = ConditionBlockTests.Equal;\r\n\r\n    /**\r\n     * Create a new ConditionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"left\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"right\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"ifTrue\", NodeGeometryBlockConnectionPointTypes.AutoDetect, true, 1);\r\n        this.registerInput(\"ifFalse\", NodeGeometryBlockConnectionPointTypes.AutoDetect, true, 0);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[2];\r\n        this._outputs[0]._defaultConnectionPointType = NodeGeometryBlockConnectionPointTypes.Float;\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Int);\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Int);\r\n        this._linkConnectionTypes(2, 3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ConditionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left input component\r\n     */\r\n    public get left(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right input component\r\n     */\r\n    public get right(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the ifTrue input component\r\n     */\r\n    public get ifTrue(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the ifFalse input component\r\n     */\r\n    public get ifFalse(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this.left.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const left = this.left.getConnectedValue(state) as number;\r\n            const right = this.right.getConnectedValue(state) as number;\r\n            let condition = false;\r\n\r\n            switch (this.test) {\r\n                case ConditionBlockTests.Equal:\r\n                    condition = Scalar.WithinEpsilon(left, right, Epsilon);\r\n                    break;\r\n                case ConditionBlockTests.NotEqual:\r\n                    condition = left !== right;\r\n                    break;\r\n                case ConditionBlockTests.LessThan:\r\n                    condition = left < right;\r\n                    break;\r\n                case ConditionBlockTests.GreaterThan:\r\n                    condition = left > right;\r\n                    break;\r\n                case ConditionBlockTests.LessOrEqual:\r\n                    condition = left <= right;\r\n                    break;\r\n                case ConditionBlockTests.GreaterOrEqual:\r\n                    condition = left >= right;\r\n                    break;\r\n                case ConditionBlockTests.Xor:\r\n                    condition = (!!left && !right) || (!left && !!right);\r\n                    break;\r\n                case ConditionBlockTests.Or:\r\n                    condition = !!left || !!right;\r\n                    break;\r\n                case ConditionBlockTests.And:\r\n                    condition = !!left && !!right;\r\n                    break;\r\n            }\r\n            return condition;\r\n        };\r\n\r\n        this.output._storedFunction = (state) => {\r\n            if (func(state)) {\r\n                return this.ifTrue.getConnectedValue(state);\r\n            }\r\n\r\n            return this.ifFalse.getConnectedValue(state);\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.test = BABYLON.ConditionBlockTests.${ConditionBlockTests[this.test]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.test = this.test;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.test = serializationObject.test;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ConditionBlock\", ConditionBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"./geometryInputBlock\";\r\nimport { Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources\";\r\n\r\n/**\r\n * Locks supported by the random block\r\n */\r\nexport enum RandomBlockLocks {\r\n    /** None */\r\n    None,\r\n    /** LoopID */\r\n    LoopID,\r\n    /** InstanceID */\r\n    InstanceID,\r\n}\r\n\r\n/**\r\n * Block used to get a random number\r\n */\r\nexport class RandomBlock extends NodeGeometryBlock {\r\n    private _currentLockId = -1;\r\n    /**\r\n     * Gets or sets a value indicating if that block will lock its value for a specific duration\r\n     */\r\n    @editableInPropertyPage(\"LockMode\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"None\", value: RandomBlockLocks.None },\r\n            { label: \"LoopID\", value: RandomBlockLocks.LoopID },\r\n            { label: \"InstanceID\", value: RandomBlockLocks.InstanceID },\r\n        ],\r\n    })\r\n    public lockMode = RandomBlockLocks.None;\r\n\r\n    /**\r\n     * Create a new RandomBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"min\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"max\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RandomBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the min input component\r\n     */\r\n    public get min(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the max input component\r\n     */\r\n    public get max(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.min.isConnected) {\r\n            const minInput = new GeometryInputBlock(\"Min\");\r\n            minInput.value = 0;\r\n            minInput.output.connectTo(this.min);\r\n        }\r\n\r\n        if (!this.max.isConnected) {\r\n            const maxInput = new GeometryInputBlock(\"Max\");\r\n            maxInput.value = 1;\r\n            maxInput.output.connectTo(this.max);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        let func: Nullable<(state: NodeGeometryBuildState) => any> = null;\r\n        this._currentLockId = -1;\r\n\r\n        switch (this.min.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n            case NodeGeometryBlockConnectionPointTypes.Float: {\r\n                func = (state) => {\r\n                    const min = this.min.getConnectedValue(state) || 0;\r\n                    const max = this.max.getConnectedValue(state) || 0;\r\n                    return min + Math.random() * (max - min);\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                func = (state) => {\r\n                    const min = this.min.getConnectedValue(state) || Vector2.Zero();\r\n                    const max = this.max.getConnectedValue(state) || Vector2.Zero();\r\n                    return new Vector2(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y));\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                func = (state) => {\r\n                    const min = this.min.getConnectedValue(state) || Vector3.Zero();\r\n                    const max = this.max.getConnectedValue(state) || Vector3.Zero();\r\n                    return new Vector3(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y), min.z + Math.random() * (max.z - min.z));\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                func = (state) => {\r\n                    const min = this.min.getConnectedValue(state) || Vector4.Zero();\r\n                    const max = this.max.getConnectedValue(state) || Vector4.Zero();\r\n                    return new Vector4(\r\n                        min.x + Math.random() * (max.x - min.x),\r\n                        min.y + Math.random() * (max.y - min.y),\r\n                        min.z + Math.random() * (max.z - min.z),\r\n                        min.w + Math.random() * (max.w - min.w)\r\n                    );\r\n                };\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.lockMode === RandomBlockLocks.None || !func) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = (state) => {\r\n                let lockId = 0;\r\n\r\n                switch (this.lockMode) {\r\n                    case RandomBlockLocks.InstanceID:\r\n                        lockId = state.getContextualValue(NodeGeometryContextualSources.InstanceID, true) || 0;\r\n                        break;\r\n                    case RandomBlockLocks.LoopID:\r\n                        lockId = state.getContextualValue(NodeGeometryContextualSources.LoopID, true) || 0;\r\n                        break;\r\n                }\r\n\r\n                if (this._currentLockId !== lockId || this.lockMode === RandomBlockLocks.None) {\r\n                    this._currentLockId = lockId;\r\n                    this.output._storedValue = func!(state);\r\n                }\r\n                return this.output._storedValue;\r\n            };\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.lockMode = BABYLON.RandomBlockLocks.${RandomBlockLocks[this.lockMode]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.lockMode = this.lockMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.lockMode = serializationObject.lockMode;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RandomBlock\", RandomBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Vector3 } from \"../../../Maths/math.vector\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources\";\r\n\r\n/**\r\n * Block used to get a noise value\r\n */\r\nexport class NoiseBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new NoiseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"offset\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scale\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n\r\n        this.registerInput(\"octaves\", NodeGeometryBlockConnectionPointTypes.Float, true, 2, 0, 16);\r\n        this.registerInput(\"roughness\", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5, 0, 1);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NoiseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the offset input component\r\n     */\r\n    public get offset(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the scale input component\r\n     */\r\n    public get scale(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the octaves input component\r\n     */\r\n    public get octaves(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughtness input component\r\n     */\r\n    public get roughness(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _negateIf(value: number, condition: number) {\r\n        return condition !== 0 ? -value : value;\r\n    }\r\n\r\n    private _noiseGrad(hash: number, x: number, y: number, z: number) {\r\n        const h = hash & 15;\r\n        const u = h < 8 ? x : y;\r\n        const vt = h === 12 || h == 14 ? x : z;\r\n        const v = h < 4 ? y : vt;\r\n        return this._negateIf(u, h & u) + this._negateIf(v, h & 2);\r\n    }\r\n\r\n    private _fade(t: number) {\r\n        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r\n    }\r\n\r\n    private _hashBitRotate(x: number, k: number) {\r\n        return (x << k) | (x >> (32 - k));\r\n    }\r\n\r\n    private _hash(kx: number, ky: number, kz: number) {\r\n        let a: number, b: number, c: number;\r\n        a = b = c = 0xdeadbeef + (3 << 2) + 13;\r\n\r\n        c += kz;\r\n        b += ky;\r\n        a += kx;\r\n\r\n        c ^= b;\r\n        c -= this._hashBitRotate(b, 14);\r\n        a ^= c;\r\n        a -= this._hashBitRotate(c, 11);\r\n        b ^= a;\r\n        b -= this._hashBitRotate(a, 25);\r\n        c ^= b;\r\n        c -= this._hashBitRotate(b, 16);\r\n        a ^= c;\r\n        a -= this._hashBitRotate(c, 4);\r\n        b ^= a;\r\n        b -= this._hashBitRotate(a, 14);\r\n        c ^= b;\r\n        c -= this._hashBitRotate(b, 24);\r\n\r\n        return c;\r\n    }\r\n\r\n    private _mix(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, x: number, y: number, z: number) {\r\n        const x1 = 1.0 - x;\r\n        const y1 = 1.0 - y;\r\n        const z1 = 1.0 - z;\r\n        return z1 * (y1 * (v0 * x1 + v1 * x) + y * (v2 * x1 + v3 * x)) + z * (y1 * (v4 * x1 + v5 * x) + y * (v6 * x1 + v7 * x));\r\n    }\r\n\r\n    private _perlinNoise(position: Vector3) {\r\n        const X = (position.x | 0) - (position.x < 0 ? 1 : 0);\r\n        const Y = (position.y | 0) - (position.y < 0 ? 1 : 0);\r\n        const Z = (position.z | 0) - (position.z < 0 ? 1 : 0);\r\n\r\n        const fx = position.x - X;\r\n        const fy = position.y - Y;\r\n        const fz = position.z - Z;\r\n\r\n        const u = this._fade(fx);\r\n        const v = this._fade(fy);\r\n        const w = this._fade(fz);\r\n\r\n        return this._mix(\r\n            this._noiseGrad(this._hash(X, Y, Z), fx, fy, fz),\r\n            this._noiseGrad(this._hash(X + 1, Y, Z), fx - 1, fy, fz),\r\n            this._noiseGrad(this._hash(X, Y + 1, Z), fx, fy - 1, fz),\r\n            this._noiseGrad(this._hash(X + 1, Y + 1, Z), fx - 1, fy - 1, fz),\r\n            this._noiseGrad(this._hash(X, Y, Z + 1), fx, fy, fz - 1),\r\n            this._noiseGrad(this._hash(X + 1, Y, Z + 1), fx - 1, fy, fz - 1),\r\n            this._noiseGrad(this._hash(X, Y + 1, Z + 1), fx, fy - 1, fz - 1),\r\n            this._noiseGrad(this._hash(X + 1, Y + 1, Z + 1), fx - 1, fy - 1, fz - 1),\r\n            u,\r\n            v,\r\n            w\r\n        );\r\n    }\r\n\r\n    private _perlinSigned(position: Vector3) {\r\n        return this._perlinNoise(position) * 0.982;\r\n    }\r\n\r\n    private _perlin(position: Vector3) {\r\n        return this._perlinSigned(position) / 2.0 + 0.5;\r\n    }\r\n\r\n    /**\r\n     * Gets a perlin noise value\r\n     * @param octaves\r\n     * @param roughness\r\n     * @param position\r\n     * @returns a value between 0 and 1\r\n     * @see Based on https://github.com/blender/blender/blob/main/source/blender/blenlib/intern/noise.cc#L533\r\n     */\r\n    noise(octaves: number, roughness: number, _position: Vector3, offset: Vector3, scale: number) {\r\n        const position = new Vector3(_position.x * scale + offset.x, _position.y * scale + offset.y, _position.z * scale + offset.z);\r\n\r\n        let fscale = 1.0;\r\n        let amp = 1.0;\r\n        let maxamp = 0.0;\r\n        let sum = 0.0;\r\n        octaves = Scalar.Clamp(octaves, 0, 15.0);\r\n        const step = octaves | 0;\r\n\r\n        for (let i = 0; i <= step; i++) {\r\n            const t = this._perlin(position.scale(fscale));\r\n            sum += t * amp;\r\n            maxamp += amp;\r\n            amp *= Scalar.Clamp(roughness, 0.0, 1.0);\r\n            fscale *= 2.0;\r\n        }\r\n\r\n        const rmd = octaves - Math.floor(octaves);\r\n        if (rmd == 0.0) {\r\n            return sum / maxamp;\r\n        }\r\n\r\n        const t = this._perlin(position.scale(fscale));\r\n        let sum2 = sum + t * amp;\r\n        sum /= maxamp;\r\n        sum2 /= maxamp + amp;\r\n        return (1.0 - rmd) * sum + rmd * sum2;\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.output._storedFunction = (state) => {\r\n            const position = state.getContextualValue(NodeGeometryContextualSources.Positions) as Vector3;\r\n            const octaves = this.octaves.getConnectedValue(state);\r\n            const roughness = this.roughness.getConnectedValue(state);\r\n\r\n            const offset = this.offset.getConnectedValue(state) as Vector3;\r\n            const scale = this.scale.getConnectedValue(state);\r\n\r\n            return this.noise(octaves, roughness, position, offset, scale);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NoiseBlock\", NoiseBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to merge several geometries\r\n */\r\nexport class MergeGeometryBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new MergeGeometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry0\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"geometry1\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry2\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry3\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry4\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MergeGeometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry0 input component\r\n     */\r\n    public get geometry0(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry1 input component\r\n     */\r\n    public get geometry1(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry2 input component\r\n     */\r\n    public get geometry2(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry3 input component\r\n     */\r\n    public get geometry3(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry4 input component\r\n     */\r\n    public get geometry4(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            let vertexData = this.geometry0.getConnectedValue(state) as VertexData;\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            if (vertexData) {\r\n                vertexData = vertexData.clone(); // Preserve source data\r\n            } else {\r\n                return null;\r\n            }\r\n\r\n            if (this.geometry1.isConnected) {\r\n                const data = this.geometry1.getConnectedValue(state);\r\n                if (data) {\r\n                    additionalVertexData.push(data);\r\n                }\r\n            }\r\n            if (this.geometry2.isConnected) {\r\n                const data = this.geometry2.getConnectedValue(state);\r\n                if (data) {\r\n                    additionalVertexData.push(data);\r\n                }\r\n            }\r\n            if (this.geometry3.isConnected) {\r\n                const data = this.geometry3.getConnectedValue(state);\r\n                if (data) {\r\n                    additionalVertexData.push(data);\r\n                }\r\n            }\r\n            if (this.geometry4.isConnected) {\r\n                const data = this.geometry4.getConnectedValue(state);\r\n                if (data) {\r\n                    additionalVertexData.push(data);\r\n                }\r\n            }\r\n\r\n            if (additionalVertexData.length && vertexData) {\r\n                vertexData = vertexData.merge(additionalVertexData, true, false, true, true);\r\n            }\r\n            return vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MergeGeometryBlock\", MergeGeometryBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { VertexData } from \"../../mesh.vertexData\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to randomly pick a geometry from a collection\r\n */\r\nexport class GeometryCollectionBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new GeometryCollectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry0\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry1\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry2\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry3\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry4\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry5\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry6\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry7\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry8\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"geometry9\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryCollectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry0 input component\r\n     */\r\n    public get geometry0(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry1 input component\r\n     */\r\n    public get geometry1(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry2 input component\r\n     */\r\n    public get geometry2(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry3 input component\r\n     */\r\n    public get geometry3(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry4 input component\r\n     */\r\n    public get geometry4(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry5 input component\r\n     */\r\n    public get geometry5(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry6 input component\r\n     */\r\n    public get geometry6(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry7 input component\r\n     */\r\n    public get geometry7(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry8 input component\r\n     */\r\n    public get geometry8(): NodeGeometryConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry9 input component\r\n     */\r\n    public get geometry9(): NodeGeometryConnectionPoint {\r\n        return this._inputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _storeGeometry(input: NodeGeometryConnectionPoint, state: NodeGeometryBuildState, index: number, availables: VertexData[]) {\r\n        if (input.isConnected) {\r\n            const vertexData = input.getConnectedValue(state) as VertexData;\r\n            if (!vertexData) {\r\n                return;\r\n            }\r\n            vertexData.metadata = vertexData.metadata || {};\r\n            vertexData.metadata.collectionId = index;\r\n            availables.push(vertexData);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const availables: VertexData[] = [];\r\n\r\n            this._storeGeometry(this.geometry0, state, 0, availables);\r\n            this._storeGeometry(this.geometry1, state, 1, availables);\r\n            this._storeGeometry(this.geometry2, state, 2, availables);\r\n            this._storeGeometry(this.geometry3, state, 3, availables);\r\n            this._storeGeometry(this.geometry4, state, 4, availables);\r\n            this._storeGeometry(this.geometry5, state, 5, availables);\r\n            this._storeGeometry(this.geometry6, state, 6, availables);\r\n            this._storeGeometry(this.geometry7, state, 7, availables);\r\n            this._storeGeometry(this.geometry8, state, 8, availables);\r\n            this._storeGeometry(this.geometry9, state, 9, availables);\r\n\r\n            if (!availables.length) {\r\n                return null;\r\n            }\r\n            return availables[Math.round(Math.random() * (availables.length - 1))];\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryCollectionBlock\", GeometryCollectionBlock);\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n/**\r\n * Block used as a pass through\r\n */\r\nexport class GeometryElbowBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Creates a new GeometryElbowBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryElbowBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const input = this._inputs[0];\r\n\r\n        output._storedFunction = (state) => {\r\n            return input.getConnectedValue(state);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryElbowBlock\", GeometryElbowBlock);\r\n", "import { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\n/**\r\n * Block used to recompute normals for a geometry\r\n */\r\nexport class ComputeNormalsBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Creates a new ComputeNormalsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ComputeNormalsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.output._storedFunction = (state) => {\r\n            if (!this.geometry.isConnected) {\r\n                return null;\r\n            }\r\n\r\n            const vertexData = this.geometry.getConnectedValue(state);\r\n            if (!vertexData.normals) {\r\n                vertexData.normals = [];\r\n            }\r\n\r\n            VertexData.ComputeNormals(vertexData.positions, vertexData.indices, vertexData.normals);\r\n\r\n            return vertexData;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeNormalsBlock\", ComputeNormalsBlock);\r\n", "import { Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Block used to create a Vector2/3/4 out of individual or partial inputs\r\n */\r\nexport class VectorConverterBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new VectorConverterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"xyzw \", NodeGeometryBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeGeometryBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeGeometryBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"zw \", NodeGeometryBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"x \", NodeGeometryBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"y \", NodeGeometryBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"z \", NodeGeometryBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"w \", NodeGeometryBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"xyzw\", NodeGeometryBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"x\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"y\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"z\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"w\", NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VectorConverterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzwIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (input)\r\n     */\r\n    public get zwIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (input)\r\n     */\r\n    public get xIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (input)\r\n     */\r\n    public get yIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (input)\r\n     */\r\n    public get zIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (input)\r\n     */\r\n    public get wIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (output)\r\n     */\r\n    public get xyzwOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zwOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (output)\r\n     */\r\n    public get xOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (output)\r\n     */\r\n    public get yOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (output)\r\n     */\r\n    public get zOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (output)\r\n     */\r\n    public get wOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[7];\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"xyzw \") {\r\n            return \"xyzwIn\";\r\n        }\r\n        if (name === \"xyz \") {\r\n            return \"xyzIn\";\r\n        }\r\n        if (name === \"xy \") {\r\n            return \"xyIn\";\r\n        }\r\n        if (name === \"zw \") {\r\n            return \"zwIn\";\r\n        }\r\n        if (name === \"x \") {\r\n            return \"xIn\";\r\n        }\r\n        if (name === \"y \") {\r\n            return \"yIn\";\r\n        }\r\n        if (name === \"z \") {\r\n            return \"zIn\";\r\n        }\r\n        if (name === \"w \") {\r\n            return \"wIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        switch (name) {\r\n            case \"x\":\r\n                return \"xOut\";\r\n            case \"y\":\r\n                return \"yOut\";\r\n            case \"z\":\r\n                return \"zOut\";\r\n            case \"w\":\r\n                return \"wOut\";\r\n            case \"xy\":\r\n                return \"xyOut\";\r\n            case \"zw\":\r\n                return \"zwOut\";\r\n            case \"xyz\":\r\n                return \"xyzOut\";\r\n            case \"xyzw\":\r\n                return \"xyzwOut\";\r\n            default:\r\n                return name;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const xInput = this.xIn;\r\n        const yInput = this.yIn;\r\n        const zInput = this.zIn;\r\n        const wInput = this.wIn;\r\n        const xyInput = this.xyIn;\r\n        const zwInput = this.zwIn;\r\n        const xyzInput = this.xyzIn;\r\n        const xyzwInput = this.xyzwIn;\r\n\r\n        const xyzwOutput = this.xyzwOut;\r\n        const xyzOutput = this.xyzOut;\r\n        const xyOutput = this.xyOut;\r\n        const zwOutput = this.zwOut;\r\n        const xOutput = this.xOut;\r\n        const yOutput = this.yOut;\r\n        const zOutput = this.zOut;\r\n        const wOutput = this.wOut;\r\n\r\n        const getData = (state: NodeGeometryBuildState): Vector4 => {\r\n            if (xyzwInput.isConnected) {\r\n                return xyzwInput.getConnectedValue(state);\r\n            }\r\n\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let z: number = 0;\r\n            let w: number = 0;\r\n\r\n            if (xInput.isConnected) {\r\n                x = xInput.getConnectedValue(state);\r\n            }\r\n            if (yInput.isConnected) {\r\n                y = yInput.getConnectedValue(state);\r\n            }\r\n            if (zInput.isConnected) {\r\n                z = zInput.getConnectedValue(state);\r\n            }\r\n            if (wInput.isConnected) {\r\n                w = wInput.getConnectedValue(state);\r\n            }\r\n\r\n            if (xyInput.isConnected) {\r\n                const temp = xyInput.getConnectedValue(state);\r\n                if (temp) {\r\n                    x = temp.x;\r\n                    y = temp.y;\r\n                }\r\n            }\r\n            if (zwInput.isConnected) {\r\n                const temp = zwInput.getConnectedValue(state);\r\n                if (temp) {\r\n                    z = temp.x;\r\n                    w = temp.y;\r\n                }\r\n            }\r\n            if (xyzInput.isConnected) {\r\n                const temp = xyzInput.getConnectedValue(state);\r\n                if (temp) {\r\n                    x = temp.x;\r\n                    y = temp.y;\r\n                    z = temp.z;\r\n                }\r\n            }\r\n\r\n            return new Vector4(x, y, z, w);\r\n        };\r\n\r\n        xyzwOutput._storedFunction = (state) => getData(state);\r\n        xyzOutput._storedFunction = (state) => {\r\n            const data = getData(state);\r\n            return new Vector3(data.x, data.y, data.z);\r\n        };\r\n        xyOutput._storedFunction = (state) => {\r\n            const data = getData(state);\r\n            return new Vector2(data.x, data.y);\r\n        };\r\n        zwOutput._storedFunction = (state) => {\r\n            const data = getData(state);\r\n            return new Vector2(data.z, data.w);\r\n        };\r\n        xOutput._storedFunction = (state) => getData(state).x;\r\n        yOutput._storedFunction = (state) => getData(state).y;\r\n        zOutput._storedFunction = (state) => getData(state).z;\r\n        wOutput._storedFunction = (state) => getData(state).w;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorConverterBlock\", VectorConverterBlock);\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n/**\r\n * Block used to normalize vectors\r\n */\r\nexport class NormalizeVectorBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Creates a new NormalizeVectorBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NormalizeVectorBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n        this.output._storedFunction = null;\r\n\r\n        if (!this.input.isConnected) {\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        this.output._storedFunction = (state) => this.input.getConnectedValue(state).normalize();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalizeVectorBlock\", NormalizeVectorBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { VertexDataMaterialInfo, type VertexData } from \"../../../../Meshes/mesh.vertexData\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Block used to affect a material ID to a geometry\r\n */\r\nexport class SetMaterialIDBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new SetMaterialIDBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"id\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.id.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SetMaterialIDBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the id input component\r\n     */\r\n    public get id(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        if (!this.geometry.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const vertexData = this.geometry.getConnectedValue(state) as VertexData;\r\n            if (!vertexData || !vertexData.indices || !vertexData.positions) {\r\n                return vertexData;\r\n            }\r\n\r\n            const materialInfo = new VertexDataMaterialInfo();\r\n            materialInfo.materialIndex = this.id.getConnectedValue(state) | 0;\r\n            materialInfo.indexStart = 0;\r\n            materialInfo.indexCount = vertexData.indices.length;\r\n            materialInfo.verticesStart = 0;\r\n            materialInfo.verticesCount = vertexData.positions.length / 3;\r\n\r\n            vertexData.materialInfos = [materialInfo];\r\n\r\n            return vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SetMaterialIDBlock\", SetMaterialIDBlock);\r\n", "import type { Nullable } from \"../../../types\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Trigonometry block\r\n */\r\nexport enum GeometryTrigonometryBlockOperations {\r\n    /** Cos */\r\n    Cos,\r\n    /** Sin */\r\n    Sin,\r\n    /** Abs */\r\n    Abs,\r\n    /** Exp */\r\n    Exp,\r\n    /** Round */\r\n    Round,\r\n    /** Floor */\r\n    Floor,\r\n    /** Ceiling */\r\n    Ceiling,\r\n    /** Square root */\r\n    Sqrt,\r\n    /** Log */\r\n    Log,\r\n    /** Tangent */\r\n    Tan,\r\n    /** Arc tangent */\r\n    ArcTan,\r\n    /** Arc cosinus */\r\n    ArcCos,\r\n    /** Arc sinus */\r\n    ArcSin,\r\n    /** Sign */\r\n    Sign,\r\n    /** Negate */\r\n    Negate,\r\n    /** OneMinus */\r\n    OneMinus,\r\n    /** Reciprocal */\r\n    Reciprocal,\r\n    /** ToDegrees */\r\n    ToDegrees,\r\n    /** ToRadians */\r\n    ToRadians,\r\n}\r\n\r\n/**\r\n * Block used to apply trigonometry operation to floats\r\n */\r\nexport class GeometryTrigonometryBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Cos\", value: GeometryTrigonometryBlockOperations.Cos },\r\n            { label: \"Sin\", value: GeometryTrigonometryBlockOperations.Sin },\r\n            { label: \"Abs\", value: GeometryTrigonometryBlockOperations.Abs },\r\n            { label: \"Exp\", value: GeometryTrigonometryBlockOperations.Exp },\r\n            { label: \"Round\", value: GeometryTrigonometryBlockOperations.Round },\r\n            { label: \"Floor\", value: GeometryTrigonometryBlockOperations.Floor },\r\n            { label: \"Ceiling\", value: GeometryTrigonometryBlockOperations.Ceiling },\r\n            { label: \"Sqrt\", value: GeometryTrigonometryBlockOperations.Sqrt },\r\n            { label: \"Log\", value: GeometryTrigonometryBlockOperations.Log },\r\n            { label: \"Tan\", value: GeometryTrigonometryBlockOperations.Tan },\r\n            { label: \"ArcTan\", value: GeometryTrigonometryBlockOperations.ArcTan },\r\n            { label: \"ArcCos\", value: GeometryTrigonometryBlockOperations.ArcCos },\r\n            { label: \"ArcSin\", value: GeometryTrigonometryBlockOperations.ArcSin },\r\n            { label: \"Sign\", value: GeometryTrigonometryBlockOperations.Sign },\r\n            { label: \"Negate\", value: GeometryTrigonometryBlockOperations.Negate },\r\n            { label: \"OneMinus\", value: GeometryTrigonometryBlockOperations.OneMinus },\r\n            { label: \"Reciprocal\", value: GeometryTrigonometryBlockOperations.Reciprocal },\r\n            { label: \"ToDegrees\", value: GeometryTrigonometryBlockOperations.ToDegrees },\r\n            { label: \"ToRadians\", value: GeometryTrigonometryBlockOperations.ToRadians },\r\n        ],\r\n    })\r\n    public operation = GeometryTrigonometryBlockOperations.Cos;\r\n\r\n    /**\r\n     * Creates a new GeometryTrigonometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryTrigonometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n        let func: Nullable<(value: number) => number> = null;\r\n\r\n        switch (this.operation) {\r\n            case GeometryTrigonometryBlockOperations.Cos: {\r\n                func = (value: number) => Math.cos(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Sin: {\r\n                func = (value: number) => Math.sin(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Abs: {\r\n                func = (value: number) => Math.abs(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Exp: {\r\n                func = (value: number) => Math.exp(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Round: {\r\n                func = (value: number) => Math.round(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Floor: {\r\n                func = (value: number) => Math.floor(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Ceiling: {\r\n                func = (value: number) => Math.ceil(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Sqrt: {\r\n                func = (value: number) => Math.sqrt(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Log: {\r\n                func = (value: number) => Math.log(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Tan: {\r\n                func = (value: number) => Math.tan(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.ArcTan: {\r\n                func = (value: number) => Math.atan(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.ArcCos: {\r\n                func = (value: number) => Math.acos(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.ArcSin: {\r\n                func = (value: number) => Math.asin(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Sign: {\r\n                func = (value: number) => Math.sign(value);\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Negate: {\r\n                func = (value: number) => -value;\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.OneMinus: {\r\n                func = (value: number) => 1 - value;\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.Reciprocal: {\r\n                func = (value: number) => 1 / value;\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.ToRadians: {\r\n                func = (value: number) => (value * Math.PI) / 180;\r\n                break;\r\n            }\r\n            case GeometryTrigonometryBlockOperations.ToDegrees: {\r\n                func = (value: number) => (value * 180) / Math.PI;\r\n                break;\r\n            }\r\n        }\r\n        if (!func) {\r\n            this.input._storedFunction = null;\r\n            this.input._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        switch (this.input.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n            case NodeGeometryBlockConnectionPointTypes.Float: {\r\n                this.output._storedFunction = (state) => {\r\n                    const source = this.input.getConnectedValue(state);\r\n                    return func!(source);\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2: {\r\n                this.output._storedFunction = (state) => {\r\n                    const source = this.input.getConnectedValue(state);\r\n                    return new Vector2(func!(source.x), func!(source.y));\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3: {\r\n                this.output._storedFunction = (state) => {\r\n                    const source = this.input.getConnectedValue(state);\r\n                    return new Vector3(func!(source.x), func!(source.y), func!(source.z));\r\n                };\r\n                break;\r\n            }\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4: {\r\n                this.output._storedFunction = (state) => {\r\n                    const source = this.input.getConnectedValue(state);\r\n                    return new Vector4(func!(source.x), func!(source.y), func!(source.z), func!(source.w));\r\n                };\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() +\r\n            `${this._codeVariableName}.operation = BABYLON.GeometryTrigonometryBlockOperations.${GeometryTrigonometryBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryTrigonometryBlock\", GeometryTrigonometryBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport type { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Block used to apply a transform to a vector / geometry\r\n */\r\nexport class GeometryTransformBlock extends NodeGeometryBlock {\r\n    private _rotationMatrix = new Matrix();\r\n    private _scalingMatrix = new Matrix();\r\n    private _translationMatrix = new Matrix();\r\n    private _scalingRotationMatrix = new Matrix();\r\n    private _transformMatrix = new Matrix();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new GeometryTransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"value\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"translation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryTransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the translation input component\r\n     */\r\n    public get translation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        if (!this.value.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const value = this.value.getConnectedValue(state);\r\n\r\n            if (!value) {\r\n                return null;\r\n            }\r\n\r\n            let matrix: Matrix;\r\n\r\n            if (this.matrix.isConnected) {\r\n                matrix = this.matrix.getConnectedValue(state);\r\n            } else {\r\n                const scaling = this.scaling.getConnectedValue(state);\r\n                const rotation = this.rotation.getConnectedValue(state);\r\n                const translation = this.translation.getConnectedValue(state);\r\n\r\n                // Transform\r\n                Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\r\n                Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\r\n                Matrix.TranslationToRef(translation.x, translation.y, translation.z, this._translationMatrix);\r\n\r\n                this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\r\n                this._scalingRotationMatrix.multiplyToRef(this._translationMatrix, this._transformMatrix);\r\n                matrix = this._transformMatrix;\r\n            }\r\n\r\n            switch (this.value.type) {\r\n                case NodeGeometryBlockConnectionPointTypes.Geometry: {\r\n                    const geometry = (value as VertexData).clone();\r\n                    geometry.transform(matrix);\r\n                    return geometry;\r\n                }\r\n                case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                    return Vector2.Transform(value, matrix);\r\n                case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                    return Vector3.TransformCoordinates(value, matrix);\r\n                case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                    return Vector4.TransformCoordinates(value, matrix);\r\n            }\r\n\r\n            return null;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryTransformBlock\", GeometryTransformBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a rotation matrix on X Axis\r\n */\r\nexport class RotationXBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new RotationXBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"angle\", NodeGeometryBlockConnectionPointTypes.Float, false, 0);\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RotationXBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the angle input component\r\n     */\r\n    public get angle(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.angle.isConnected) {\r\n            const angleInput = new GeometryInputBlock(\"Angle\");\r\n            angleInput.value = 0;\r\n            angleInput.output.connectTo(this.angle);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            return Matrix.RotationX(this.angle.getConnectedValue(state));\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RotationXBlock\", RotationXBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a rotation matrix on Y Axis\r\n */\r\nexport class RotationYBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new RotationYBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"angle\", NodeGeometryBlockConnectionPointTypes.Float, false, 0);\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RotationYBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the angle input component\r\n     */\r\n    public get angle(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.angle.isConnected) {\r\n            const angleInput = new GeometryInputBlock(\"Angle\");\r\n            angleInput.value = 0;\r\n            angleInput.output.connectTo(this.angle);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            return Matrix.RotationY(this.angle.getConnectedValue(state));\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RotationYBlock\", RotationYBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a rotation matrix on Z Axis\r\n */\r\nexport class RotationZBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new RotationZBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"angle\", NodeGeometryBlockConnectionPointTypes.Float, false, 0);\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RotationZBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the angle input component\r\n     */\r\n    public get angle(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.angle.isConnected) {\r\n            const angleInput = new GeometryInputBlock(\"Angle\");\r\n            angleInput.value = 0;\r\n            angleInput.output.connectTo(this.angle);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            return Matrix.RotationZ(this.angle.getConnectedValue(state));\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RotationZBlock\", RotationZBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a scaling matrix\r\n */\r\nexport class ScalingBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new ScalingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"scale\", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.One());\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ScalingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the scale input component\r\n     */\r\n    public get scale(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.scale.isConnected) {\r\n            const scaleInput = new GeometryInputBlock(\"Scale\");\r\n            scaleInput.value = new Vector3(1, 1, 1);\r\n            scaleInput.output.connectTo(this.scale);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            const value = this.scale.getConnectedValue(state) as Vector3;\r\n            return Matrix.Scaling(value.x, value.y, value.z);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScalingBlock\", ScalingBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a align matrix\r\n */\r\nexport class AlignBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new AlignBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"source\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Up());\r\n        this.registerInput(\"target\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Left());\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AlignBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the target input component\r\n     */\r\n    public get target(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            const source = (this.source.getConnectedValue(state) as Vector3).clone();\r\n            const target = (this.target.getConnectedValue(state) as Vector3).clone();\r\n            const result = new Matrix();\r\n\r\n            source.normalize();\r\n            target.normalize();\r\n\r\n            Matrix.RotationAlignToRef(source, target, result, true);\r\n\r\n            return result;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AlignBlock\", AlignBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to get a translation matrix\r\n */\r\nexport class TranslationBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new TranslationBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"translation\", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.Zero());\r\n        this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TranslationBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the translation input component\r\n     */\r\n    public get translation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix output component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.translation.isConnected) {\r\n            const translationInput = new GeometryInputBlock(\"Translation\");\r\n            translationInput.value = new Vector3(0, 0, 0);\r\n            translationInput.output.connectTo(this.translation);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.matrix._storedFunction = (state) => {\r\n            const value = this.translation.getConnectedValue(state) as Vector3;\r\n            return Matrix.Translation(value.x, value.y, value.z);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TranslationBlock\", TranslationBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport { Epsilon } from \"../../../../Maths/math.constants\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry on every vertex of a geometry\r\n */\r\nexport class InstantiateOnVerticesBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentIndex: number;\r\n    private _currentLoopIndex: number;\r\n    private _indexTranslation: Nullable<{ [key: number]: number }> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the block should remove duplicated positions\r\n     */\r\n    @editableInPropertyPage(\"Remove duplicated positions\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public removeDuplicatedPositions = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnVerticesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"density\", NodeGeometryBlockConnectionPointTypes.Float, true, 1, 0, 1);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._indexTranslation ? this._indexTranslation[this._currentIndex] : this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnVerticesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the density input component\r\n     */\r\n    public get density(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let vertexCount = this._vertexData.positions.length / 3;\r\n            const additionalVertexData: VertexData[] = [];\r\n            const currentPosition = new Vector3();\r\n            const alreadyDone: number[] = [];\r\n            let vertices = this._vertexData.positions;\r\n            this._currentLoopIndex = 0;\r\n\r\n            if (this.removeDuplicatedPositions) {\r\n                this._indexTranslation = {};\r\n                for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                    const x = vertices[this._currentIndex * 3];\r\n                    const y = vertices[this._currentIndex * 3 + 1];\r\n                    const z = vertices[this._currentIndex * 3 + 2];\r\n                    let found = false;\r\n                    for (let index = 0; index < alreadyDone.length; index += 3) {\r\n                        if (Math.abs(alreadyDone[index] - x) < Epsilon && Math.abs(alreadyDone[index + 1] - y) < Epsilon && Math.abs(alreadyDone[index + 2] - z) < Epsilon) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (found) {\r\n                        continue;\r\n                    }\r\n                    this._indexTranslation[alreadyDone.length / 3] = this._currentIndex;\r\n                    alreadyDone.push(x, y, z);\r\n                }\r\n\r\n                vertices = alreadyDone;\r\n                vertexCount = vertices.length / 3;\r\n            } else {\r\n                this._indexTranslation = null;\r\n            }\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const density = this.density.getConnectedValue(state);\r\n\r\n                if (density < 1) {\r\n                    if (Math.random() > density) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                currentPosition.fromArray(vertices, this._currentIndex * 3);\r\n\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                // Transform\r\n                if (this.matrix.isConnected) {\r\n                    const transform = this.matrix.getConnectedValue(state);\r\n                    state._instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData);\r\n                } else {\r\n                    const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                    const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    state._instantiate(clone, currentPosition, rotation, scaling, additionalVertexData);\r\n                }\r\n                this._currentLoopIndex++;\r\n            }\r\n\r\n            // Restore\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions ? \"true\" : \"false\"};\\n`;\r\n        codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.removeDuplicatedPositions = this.removeDuplicatedPositions;\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.removeDuplicatedPositions = serializationObject.removeDuplicatedPositions;\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnVerticesBlock\", InstantiateOnVerticesBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector2, Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry on every face of a geometry\r\n */\r\nexport class InstantiateOnFacesBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentFaceIndex: number;\r\n    private _currentLoopIndex: number;\r\n    private _currentPosition = new Vector3();\r\n    private _currentUV = new Vector2();\r\n    private _vertex0 = new Vector3();\r\n    private _vertex1 = new Vector3();\r\n    private _vertex2 = new Vector3();\r\n    private _tempVector0 = new Vector3();\r\n    private _tempVector1 = new Vector3();\r\n    private _uv0 = new Vector2();\r\n    private _uv1 = new Vector2();\r\n    private _uv2 = new Vector2();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnFacesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return this._currentFaceIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual positions\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverridePositionsContextualValue() {\r\n        return this._currentPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual normals\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverrideNormalsContextualValue() {\r\n        this._vertex1.subtractToRef(this._vertex0, this._tempVector0);\r\n        this._vertex2.subtractToRef(this._vertex1, this._tempVector1);\r\n        this._tempVector0.normalize();\r\n        this._tempVector1.normalize();\r\n        return Vector3.Cross(this._tempVector1, this._tempVector0);\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual UV1 se\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverrideUVs1ContextualValue() {\r\n        return this._currentUV;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnFacesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the count input component\r\n     */\r\n    public get count(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let instanceGeometry: Nullable<VertexData> = null;\r\n            const instanceCount = this.count.getConnectedValue(state);\r\n            const faceCount = this._vertexData.indices.length / 3;\r\n            const instancePerFace = instanceCount / faceCount;\r\n            let accumulatedCount = 0;\r\n            const additionalVertexData: VertexData[] = [];\r\n            let totalDone = 0;\r\n            this._currentLoopIndex = 0;\r\n\r\n            for (this._currentFaceIndex = 0; this._currentFaceIndex < faceCount; this._currentFaceIndex++) {\r\n                accumulatedCount += instancePerFace;\r\n                const countPerFace = (accumulatedCount | 0) - totalDone;\r\n\r\n                if (countPerFace < 1) {\r\n                    continue;\r\n                }\r\n\r\n                const faceID0 = this._vertexData.indices[this._currentFaceIndex * 3];\r\n                const faceID1 = this._vertexData.indices[this._currentFaceIndex * 3 + 1];\r\n                const faceID2 = this._vertexData.indices[this._currentFaceIndex * 3 + 2];\r\n\r\n                // Extract face vertices\r\n                this._vertex0.fromArray(this._vertexData.positions, faceID0 * 3);\r\n                this._vertex1.fromArray(this._vertexData.positions, faceID1 * 3);\r\n                this._vertex2.fromArray(this._vertexData.positions, faceID2 * 3);\r\n\r\n                if (this._vertexData.uvs) {\r\n                    this._uv0.fromArray(this._vertexData.uvs, faceID0 * 2);\r\n                    this._uv1.fromArray(this._vertexData.uvs, faceID1 * 2);\r\n                    this._uv2.fromArray(this._vertexData.uvs, faceID2 * 2);\r\n                }\r\n\r\n                for (let faceDispatchCount = 0; faceDispatchCount < countPerFace; faceDispatchCount++) {\r\n                    if (totalDone >= instanceCount) {\r\n                        break;\r\n                    }\r\n\r\n                    // Get random point on face\r\n                    let x = Math.random();\r\n                    let y = Math.random();\r\n\r\n                    if (x > y) {\r\n                        const temp = x;\r\n                        x = y;\r\n                        y = temp;\r\n                    }\r\n                    const s = x;\r\n                    const t = y - x;\r\n                    const u = 1 - s - t;\r\n\r\n                    this._currentPosition.set(\r\n                        s * this._vertex0.x + t * this._vertex1.x + u * this._vertex2.x,\r\n                        s * this._vertex0.y + t * this._vertex1.y + u * this._vertex2.y,\r\n                        s * this._vertex0.z + t * this._vertex1.z + u * this._vertex2.z\r\n                    );\r\n\r\n                    if (this._vertexData.uvs) {\r\n                        this._currentUV.set(s * this._uv0.x + t * this._uv1.x + u * this._uv2.x, s * this._uv0.y + t * this._uv1.y + u * this._uv2.y);\r\n                    }\r\n\r\n                    // Clone the instance\r\n                    instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                    if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                        accumulatedCount -= instancePerFace;\r\n                        continue;\r\n                    }\r\n                    const clone = instanceGeometry!.clone();\r\n\r\n                    if (this.matrix.isConnected) {\r\n                        const transform = this.matrix.getConnectedValue(state);\r\n                        state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\r\n                    } else {\r\n                        const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                        const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                        state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\r\n                    }\r\n                    totalDone++;\r\n                    this._currentLoopIndex++;\r\n                }\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            state.restoreGeometryContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnFacesBlock\", InstantiateOnFacesBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Ray } from \"../../../../Culling/ray\";\r\nimport { extractMinAndMax } from \"../../../../Maths/math.functions\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used to instance geometry inside a geometry\r\n */\r\nexport class InstantiateOnVolumeBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    private _vertexData: VertexData;\r\n    private _currentLoopIndex: number;\r\n    private _currentPosition = new Vector3();\r\n    private _vertex0 = new Vector3();\r\n    private _vertex1 = new Vector3();\r\n    private _vertex2 = new Vector3();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new InstantiateOnVolumeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentLoopIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the value associated with a contextual positions\r\n     * @returns the value associated with the source\r\n     */\r\n    public getOverridePositionsContextualValue() {\r\n        return this._currentPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateOnVolumeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the count input component\r\n     */\r\n    public get count(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            this._vertexData = this.geometry.getConnectedValue(state);\r\n            state.pushGeometryContext(this._vertexData);\r\n\r\n            if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\r\n                state.restoreExecutionContext();\r\n                state.restoreInstancingContext();\r\n                state.restoreGeometryContext();\r\n                this.output._storedValue = null;\r\n                return;\r\n            }\r\n\r\n            // Processing\r\n            let instanceGeometry: Nullable<VertexData> = null;\r\n            const instanceCount = this.count.getConnectedValue(state);\r\n            const additionalVertexData: VertexData[] = [];\r\n            const boundingInfo = extractMinAndMax(this._vertexData.positions!, 0, this._vertexData.positions!.length / 3);\r\n            const min = boundingInfo.minimum;\r\n            const max = boundingInfo.maximum;\r\n            const direction = new Vector3(1, 0, 0);\r\n            const faceCount = this._vertexData.indices.length / 3;\r\n            this._currentLoopIndex = 0;\r\n\r\n            for (let index = 0; index < instanceCount; index++) {\r\n                this._currentPosition.set(Math.random() * (max.x - min.x) + min.x, Math.random() * (max.y - min.y) + min.y, Math.random() * (max.z - min.z) + min.z);\r\n\r\n                // Cast a ray from the random point in an arbitrary direction\r\n                const ray = new Ray(this._currentPosition, direction);\r\n\r\n                let intersectionCount = 0;\r\n                for (let currentFaceIndex = 0; currentFaceIndex < faceCount; currentFaceIndex++) {\r\n                    // Extract face vertices\r\n                    this._vertex0.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3] * 3);\r\n                    this._vertex1.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3 + 1] * 3);\r\n                    this._vertex2.fromArray(this._vertexData.positions!, this._vertexData.indices![currentFaceIndex * 3 + 2] * 3);\r\n\r\n                    const currentIntersectInfo = ray.intersectsTriangle(this._vertex0, this._vertex1, this._vertex2);\r\n\r\n                    if (currentIntersectInfo && currentIntersectInfo.distance > 0) {\r\n                        intersectionCount++;\r\n                    }\r\n                }\r\n\r\n                if (intersectionCount % 2 === 0) {\r\n                    // We are outside, try again\r\n                    index--;\r\n                    continue;\r\n                }\r\n\r\n                // Clone the instance\r\n                instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                const clone = instanceGeometry!.clone();\r\n\r\n                if (this.matrix.isConnected) {\r\n                    const transform = this.matrix.getConnectedValue(state);\r\n                    state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\r\n                } else {\r\n                    const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                    const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\r\n                }\r\n                this._currentLoopIndex++;\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            state.restoreGeometryContext();\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateOnVolumeBlock\", InstantiateOnVolumeBlock);\r\n", "import { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryExecutionContext } from \"../../Interfaces/nodeGeometryExecutionContext\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\nimport type { INodeGeometryInstancingContext } from \"../../Interfaces/nodeGeometryInstancingContext\";\r\n\r\n/**\r\n * Block used as a base for InstantiateXXX blocks\r\n */\r\nexport abstract class InstantiateBaseBlock extends NodeGeometryBlock implements INodeGeometryExecutionContext, INodeGeometryInstancingContext {\r\n    protected _vertexData: VertexData;\r\n    protected _currentIndex: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = true;\r\n\r\n    /**\r\n     * Create a new InstantiateBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\r\n        this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 1);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the instance input component\r\n     */\r\n    public get instance(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the count input component\r\n     */\r\n    public get count(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        if (serializationObject.evaluateContext !== undefined) {\r\n            this.evaluateContext = serializationObject.evaluateContext;\r\n        }\r\n    }\r\n}\r\n", "import type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"../../../mesh.vertexData\";\r\nimport { Vector3 } from \"../../../../Maths/math.vector\";\r\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock\";\r\n\r\n/**\r\n * Block used to instantiate a geometry inside a loop\r\n */\r\nexport class InstantiateBlock extends InstantiateBaseBlock {\r\n    protected _vertexData: VertexData;\r\n    protected _currentIndex: number;\r\n\r\n    /**\r\n     * Create a new InstantiateBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\r\n        this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\r\n\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getInstanceIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current index in the current flow\r\n     * @returns the current index\r\n     */\r\n    public getExecutionIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current loop index in the current flow\r\n     * @returns the current loop index\r\n     */\r\n    public getExecutionLoopIndex(): number {\r\n        return this._currentIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the current face index in the current flow\r\n     * @returns the current face index\r\n     */\r\n    public getExecutionFaceIndex(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix input component\r\n     */\r\n    public get matrix(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            // Processing\r\n            const iterationCount = this.count.getConnectedValue(state);\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                // Transform\r\n                if (this.matrix.isConnected) {\r\n                    const transform = this.matrix.getConnectedValue(state);\r\n                    state._instantiateWithMatrix(clone, transform, additionalVertexData);\r\n                } else {\r\n                    const position = this.position.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n                    const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\r\n                    state._instantiate(clone, position, rotation, scaling, additionalVertexData);\r\n                }\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        // Storage\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateBlock\", InstantiateBlock);\r\n", "import type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock\";\r\n\r\n/**\r\n * Block used to clone geometry along a line\r\n */\r\nexport class InstantiateLinearBlock extends InstantiateBaseBlock {\r\n    /**\r\n     * Create a new Instantiate Linear Block\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        // Direction is magnitude per step\r\n        this.registerInput(\"direction\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(1, 0, 0));\r\n\r\n        // Rotation is magnitude per step\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Scaling is magnitude per step\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateLinearBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            const iterationCount = this.count.getConnectedValue(state) as number;\r\n\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            const transformMatrix = Matrix.Identity();\r\n            const transformOffset = Vector3.Zero();\r\n            const rotationOffset = Vector3.Zero();\r\n            const scaleOffset = Vector3.Zero();\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                const direction = this.direction.getConnectedValue(state) as Vector3;\r\n                const rotation = this.rotation.getConnectedValue(state) as Vector3;\r\n                const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n\r\n                transformOffset.copyFrom(direction.clone().scale(this._currentIndex));\r\n                rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\r\n                scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\r\n                scaleOffset.addInPlaceFromFloats(1, 1, 1);\r\n\r\n                Matrix.ComposeToRef(scaleOffset, Quaternion.FromEulerAngles(rotationOffset.x, rotationOffset.y, rotationOffset.z), transformOffset, transformMatrix);\r\n\r\n                state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            // Storage\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateLinearBlock\", InstantiateLinearBlock);\r\n", "import type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock\";\r\n\r\n/**\r\n * Block used to clone geometry in a radial shape\r\n */\r\nexport class InstantiateRadialBlock extends InstantiateBaseBlock {\r\n    /**\r\n     * Create a new InstantiateRadialBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Int, true, 0, 0);\r\n\r\n        // Angle start and end\r\n        this.registerInput(\"angleStart\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"angleEnd\", NodeGeometryBlockConnectionPointTypes.Float, true, Math.PI * 2);\r\n\r\n        // Transform offset\r\n        this.registerInput(\"transform\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Rotation is magnitude per step\r\n        this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n\r\n        // Scale is magnitude per step\r\n        this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\r\n        this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InstantiateRadialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get radius(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get angleStart(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get angleEnd(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the transform input component\r\n     */\r\n    public get transform(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rotation input component\r\n     */\r\n    public get rotation(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the scaling input component\r\n     */\r\n    public get scaling(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            state.pushExecutionContext(this);\r\n            state.pushInstancingContext(this);\r\n\r\n            const iterationCount = this.count.getConnectedValue(state) as number;\r\n\r\n            const additionalVertexData: VertexData[] = [];\r\n\r\n            const rotMatrix = Matrix.Identity();\r\n            const radiusMatrix = Matrix.Identity();\r\n            const transformMatrix = Matrix.Identity();\r\n            const transformOffset = Vector3.Zero();\r\n            const rotationOffset = Vector3.Zero();\r\n            const scaleOffset = Vector3.Zero();\r\n\r\n            for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\r\n                const instanceGeometry = this.instance.getConnectedValue(state) as VertexData;\r\n\r\n                if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\r\n                    continue;\r\n                }\r\n                // Clone the instance\r\n                const clone = instanceGeometry.clone();\r\n\r\n                const radius = this.radius.getConnectedValue(state) as number;\r\n                const angleStart: number = this.angleStart.getConnectedValue(state) as number;\r\n                const angleEnd = this.angleEnd.getConnectedValue(state) as number;\r\n\r\n                const transform = this.transform.getConnectedValue(state) as Vector3;\r\n\r\n                const rotation = this.rotation.getConnectedValue(state) as Vector3;\r\n\r\n                const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\r\n\r\n                // Define arc size\r\n                const pieSlice = angleEnd - angleStart;\r\n                const rStep = pieSlice / iterationCount;\r\n\r\n                const angle = angleStart + rStep * this._currentIndex;\r\n                const angleQuat = Quaternion.FromEulerAngles(0, angle, 0);\r\n\r\n                // Get local transforms\r\n                transformOffset.copyFrom(transform.clone().scale(this._currentIndex));\r\n                rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\r\n                scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\r\n                scaleOffset.addInPlaceFromFloats(1, 1, 1);\r\n\r\n                // Compose (rotMatrix x radius x scale x angle x user transform)\r\n                Matrix.RotationYawPitchRollToRef(rotationOffset.y, rotationOffset.x, rotationOffset.z, rotMatrix);\r\n                radiusMatrix.setTranslationFromFloats(0, 0, radius);\r\n                Matrix.ComposeToRef(scaleOffset, angleQuat, transformOffset, transformMatrix);\r\n\r\n                rotMatrix.multiplyToRef(radiusMatrix, radiusMatrix);\r\n                radiusMatrix.multiplyToRef(transformMatrix, transformMatrix);\r\n\r\n                state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\r\n            }\r\n\r\n            // Merge\r\n            if (additionalVertexData.length) {\r\n                if (additionalVertexData.length === 1) {\r\n                    this._vertexData = additionalVertexData[0];\r\n                } else {\r\n                    // We do not merge the main one as user can use a merge node if wanted\r\n                    const main = additionalVertexData.splice(0, 1)[0];\r\n                    this._vertexData = main.merge(additionalVertexData, true, false, true, true);\r\n                }\r\n            }\r\n\r\n            // Storage\r\n            state.restoreExecutionContext();\r\n            state.restoreInstancingContext();\r\n            return this._vertexData;\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstantiateRadialBlock\", InstantiateRadialBlock);\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\n\r\n/**\r\n * Defines a block used to convert from int to float\r\n */\r\nexport class IntFloatConverterBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new IntFloatConverterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"float \", NodeGeometryBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"int \", NodeGeometryBlockConnectionPointTypes.Int, true);\r\n\r\n        this.registerOutput(\"float\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"int\", NodeGeometryBlockConnectionPointTypes.Int);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"IntFloatConverterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the float input component\r\n     */\r\n    public get floatIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the int input component\r\n     */\r\n    public get intIn(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the float output component\r\n     */\r\n    public get floatOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the int output component\r\n     */\r\n    public get intOut(): NodeGeometryConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"float \") {\r\n            return \"floatIn\";\r\n        }\r\n        if (name === \"int \") {\r\n            return \"intIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.floatOut._storedFunction = (state) => {\r\n            if (this.floatIn.isConnected) {\r\n                return this.floatIn.getConnectedValue(state);\r\n            }\r\n            if (this.intIn.isConnected) {\r\n                return this.intIn.getConnectedValue(state);\r\n            }\r\n\r\n            return 0;\r\n        };\r\n\r\n        this.intOut._storedFunction = (state) => {\r\n            if (this.floatIn.isConnected) {\r\n                return Math.floor(this.floatIn.getConnectedValue(state));\r\n            }\r\n            if (this.intIn.isConnected) {\r\n                return Math.floor(this.intIn.getConnectedValue(state));\r\n            }\r\n\r\n            return 0;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.IntFloatConverterBlock\", IntFloatConverterBlock);\r\n", "import { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Defines a block used to debug values going through it\r\n */\r\nexport class DebugBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets the log entries\r\n     */\r\n    public log: string[] = [];\r\n\r\n    /**\r\n     * Create a new DebugBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isDebug = true;\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"DebugBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        if (!this.input.isConnected) {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        this.log = [];\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const input = this.input.getConnectedValue(state);\r\n\r\n            if (input === null || input === undefined) {\r\n                this.log.push(\"null\");\r\n                return input;\r\n            }\r\n\r\n            this.log.push(input.toString());\r\n\r\n            return input;\r\n        };\r\n\r\n        if (this.output.isConnected) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DebugBlock\", DebugBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { VertexData } from \"../../mesh.vertexData\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Block used to get information about a geometry\r\n */\r\nexport class GeometryInfoBlock extends NodeGeometryBlock {\r\n    private _currentVertexData: VertexData;\r\n    /**\r\n     * Create a new GeometryInfoBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerOutput(\"id\", NodeGeometryBlockConnectionPointTypes.Int);\r\n        this.registerOutput(\"collectionId\", NodeGeometryBlockConnectionPointTypes.Int);\r\n        this.registerOutput(\"verticesCount\", NodeGeometryBlockConnectionPointTypes.Int);\r\n        this.registerOutput(\"facesCount\", NodeGeometryBlockConnectionPointTypes.Int);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryInfoBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the id output component\r\n     */\r\n    public get id(): NodeGeometryConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the collectionId output component\r\n     */\r\n    public get collectionId(): NodeGeometryConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the verticesCount output component\r\n     */\r\n    public get verticesCount(): NodeGeometryConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the facesCount output component\r\n     */\r\n    public get facesCount(): NodeGeometryConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this.geometry.isConnected) {\r\n            this.id._storedValue = 0;\r\n            this.collectionId._storedValue = 0;\r\n            this.verticesCount._storedValue = 0;\r\n            this.facesCount._storedValue = 0;\r\n            this.output._storedValue = 0;\r\n            this.id._storedFunction = null;\r\n            this.collectionId._storedFunction = null;\r\n            this.verticesCount._storedFunction = null;\r\n            this.facesCount._storedFunction = null;\r\n            this.output._storedFunction = null;\r\n            return;\r\n        }\r\n\r\n        this.output._storedFunction = (state: NodeGeometryBuildState) => {\r\n            this._currentVertexData = this.geometry.getConnectedValue(state) as VertexData;\r\n            return this._currentVertexData;\r\n        };\r\n        this.id._storedFunction = (state: NodeGeometryBuildState) => {\r\n            this._currentVertexData = this._currentVertexData || (this.geometry.getConnectedValue(state) as VertexData);\r\n            return this._currentVertexData.uniqueId;\r\n        };\r\n        this.collectionId._storedFunction = (state: NodeGeometryBuildState) => {\r\n            this._currentVertexData = this._currentVertexData || (this.geometry.getConnectedValue(state) as VertexData);\r\n            return this._currentVertexData.metadata ? this._currentVertexData.metadata.collectionId : 0;\r\n        };\r\n        this.verticesCount._storedFunction = (state: NodeGeometryBuildState) => {\r\n            this._currentVertexData = this._currentVertexData || (this.geometry.getConnectedValue(state) as VertexData);\r\n            return this._currentVertexData.positions ? this._currentVertexData.positions.length / 3 : 0;\r\n        };\r\n        this.facesCount._storedFunction = (state: NodeGeometryBuildState) => {\r\n            this._currentVertexData = this._currentVertexData || (this.geometry.getConnectedValue(state) as VertexData);\r\n            return this._currentVertexData.indices ? this._currentVertexData.indices.length / 3 : 0;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryInfoBlock\", GeometryInfoBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport { Vector2, Vector3 } from \"../../../Maths/math.vector\";\r\n\r\n/**\r\n * Type of mappings supported by the mapping block\r\n */\r\nexport enum MappingTypes {\r\n    /** Spherical */\r\n    Spherical,\r\n    /** Cylindrical */\r\n    Cylindrical,\r\n    /** Cubic */\r\n    Cubic,\r\n}\r\n\r\n/**\r\n * Block used to generate UV coordinates\r\n */\r\nexport class MappingBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets the mapping type used by the block\r\n     */\r\n    @editableInPropertyPage(\"Mapping\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Spherical\", value: MappingTypes.Spherical },\r\n            { label: \"Cylindrical\", value: MappingTypes.Cylindrical },\r\n            { label: \"Cubic\", value: MappingTypes.Cubic },\r\n        ],\r\n    })\r\n    public mapping = MappingTypes.Spherical;\r\n\r\n    /**\r\n     * Create a new MappingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"center\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\r\n        this.registerOutput(\"uv\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MappingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the center input component\r\n     */\r\n    public get center(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get uv(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this.position.isConnected) {\r\n            this.uv._storedFunction = null;\r\n            this.uv._storedValue = null;\r\n            return;\r\n        }\r\n        const tempDirection = Vector3.Zero();\r\n\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const position = (this.position.getConnectedValue(state) as Vector3) || Vector3.Zero();\r\n            const normal = (this.normal.getConnectedValue(state) as Vector3) || Vector3.Zero();\r\n            const center = this.center.getConnectedValue(state) as Vector3;\r\n            const uv = Vector2.Zero();\r\n\r\n            switch (this.mapping) {\r\n                case MappingTypes.Spherical: {\r\n                    position.subtractToRef(center, tempDirection);\r\n                    const len = tempDirection.length();\r\n                    if (len > 0) {\r\n                        uv.x = Math.acos(tempDirection.y / len) / Math.PI;\r\n                        if (tempDirection.x !== 0 || tempDirection.z !== 0) {\r\n                            uv.y = Math.atan2(tempDirection.x, tempDirection.z) / (Math.PI * 2);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MappingTypes.Cylindrical: {\r\n                    position.subtractToRef(center, tempDirection);\r\n                    const len = tempDirection.length();\r\n                    if (len > 0) {\r\n                        uv.x = Math.atan2(tempDirection.x / len, tempDirection.z / len) / (Math.PI * 2);\r\n                        uv.y = (tempDirection.y + 1.0) / 2.0;\r\n                    }\r\n                    break;\r\n                }\r\n                case MappingTypes.Cubic: {\r\n                    // Find the largest component of the normal vector\r\n                    const absX = Math.abs(normal.x);\r\n                    const absY = Math.abs(normal.y);\r\n                    const absZ = Math.abs(normal.z);\r\n                    const maxDim = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));\r\n\r\n                    let u = 0,\r\n                        v = 0;\r\n\r\n                    if (absX >= absY && absX >= absZ) {\r\n                        u = position.y / maxDim - center.y;\r\n                        v = position.z / maxDim - center.z;\r\n                    } else if (absY >= absX && absY >= absZ) {\r\n                        u = position.x / maxDim - center.x;\r\n                        v = position.z / maxDim - center.z;\r\n                    } else {\r\n                        u = position.x / maxDim - center.x;\r\n                        v = position.y / maxDim - center.y;\r\n                    }\r\n\r\n                    uv.x = (u + 1) / 2;\r\n                    uv.y = (v + 1) / 2;\r\n                }\r\n            }\r\n            return uv;\r\n        };\r\n\r\n        this.uv._storedFunction = (state) => {\r\n            return func(state);\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.mapping = BABYLON.MappingTypes.${MappingTypes[this.mapping]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.mapping = this.mapping;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.mapping = serializationObject.mapping;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MappingBlock\", MappingBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Block used to compose two matrices\r\n */\r\nexport class MatrixComposeBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new MatrixComposeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"matrix0\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n        this.registerInput(\"matrix1\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MatrixComposeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix0 input component\r\n     */\r\n    public get matrix0(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix1 input component\r\n     */\r\n    public get matrix1(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.output._storedFunction = (state: NodeGeometryBuildState) => {\r\n            if (!this.matrix0.isConnected || !this.matrix1.isConnected) {\r\n                return null;\r\n            }\r\n\r\n            const matrix0 = this.matrix0.getConnectedValue(state) as Matrix;\r\n            const matrix1 = this.matrix1.getConnectedValue(state) as Matrix;\r\n\r\n            if (!matrix0 || !matrix1) {\r\n                return null;\r\n            }\r\n            return matrix0.multiply(matrix1);\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MatrixComposeBlock\", MatrixComposeBlock);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { TeleportOutBlock } from \"./teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block used to teleport a value to an endpoint\r\n */\r\nexport class TeleportInBlock extends NodeGeometryBlock {\r\n    private _endpoints: TeleportOutBlock[] = [];\r\n\r\n    /** Gets the list of attached endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /**\r\n     * Create a new TeleportInBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n        this._isTeleportIn = true;\r\n\r\n        this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TeleportInBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = super._dumpCode(uniqueNames, alreadyDumped);\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (alreadyDumped.indexOf(endpoint) === -1) {\r\n                codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint.isAnAncestorOfType(type)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeGeometryBlock): boolean {\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint === block) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.isAnAncestorOf(block)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeGeometryBlock) => boolean): Nullable<NodeGeometryBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            const descendant = endpoint.getDescendantOfPredicate(predicate);\r\n\r\n            if (descendant) {\r\n                return descendant;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add an enpoint to this block\r\n     * @param endpoint define the endpoint to attach to\r\n     */\r\n    public attachToEndpoint(endpoint: TeleportOutBlock) {\r\n        endpoint.detach();\r\n\r\n        this._endpoints.push(endpoint);\r\n        endpoint._entryPoint = this;\r\n        endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        endpoint._tempEntryPointUniqueId = null;\r\n        endpoint.name = \"> \" + this.name;\r\n    }\r\n\r\n    /**\r\n     * Remove enpoint from this block\r\n     * @param endpoint define the endpoint to remove\r\n     */\r\n    public detachFromEndpoint(endpoint: TeleportOutBlock) {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index !== -1) {\r\n            this._endpoints.splice(index, 1);\r\n            endpoint._outputs[0]._typeConnectionSource = null;\r\n            endpoint._entryPoint = null;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        for (const endpoint of this._endpoints) {\r\n            endpoint.output._storedFunction = (state) => {\r\n                return this.input.getConnectedValue(state);\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TeleportInBlock\", TeleportInBlock);\r\n", "import type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { TeleportInBlock } from \"./teleportInBlock\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Defines a block used to receive a value from a teleport entry point\r\n */\r\nexport class TeleportOutBlock extends NodeGeometryBlock {\r\n    /** @internal */\r\n    public _entryPoint: Nullable<TeleportInBlock> = null;\r\n    /** @internal */\r\n    public _tempEntryPointUniqueId: Nullable<number> = null;\r\n\r\n    /**\r\n     * Create a new TeleportOutBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isTeleportOut = true;\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\r\n    }\r\n\r\n    /**\r\n     * Gets the entry point\r\n     */\r\n    public get entryPoint() {\r\n        return this._entryPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TeleportOutBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /** Detach from entry point */\r\n    public detach() {\r\n        if (!this._entryPoint) {\r\n            return;\r\n        }\r\n        this._entryPoint.detachFromEndpoint(this);\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        // Do nothing\r\n        // All work done by the emitter\r\n    }\r\n\r\n    protected _customBuildStep(state: NodeGeometryBuildState): void {\r\n        if (this.entryPoint) {\r\n            this.entryPoint.build(state);\r\n        }\r\n    }\r\n\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString: string = \"\";\r\n        if (this.entryPoint) {\r\n            if (alreadyDumped.indexOf(this.entryPoint) === -1) {\r\n                codeString += this.entryPoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString + super._dumpCode(uniqueNames, alreadyDumped);\r\n    }\r\n\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = super._dumpCodeForOutputConnections(alreadyDumped);\r\n\r\n        if (this.entryPoint) {\r\n            codeString += this.entryPoint._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone() {\r\n        const clone = super.clone();\r\n\r\n        if (this.entryPoint) {\r\n            this.entryPoint.attachToEndpoint(clone as TeleportOutBlock);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        if (this.entryPoint) {\r\n            codeString += `${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});\\n`;\r\n        }\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.entryPoint = this.entryPoint?.uniqueId ?? \"\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this._tempEntryPointUniqueId = serializationObject.entryPoint;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TeleportOutBlock\", TeleportOutBlock);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryTextureData } from \"../../Interfaces/nodeGeometryTextureData\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\n/**\r\n * Block used to load texture data\r\n */\r\nexport class GeometryTextureBlock extends NodeGeometryBlock {\r\n    private _data: Nullable<Float32Array> = null;\r\n    private _width: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this block should serialize its cached data\r\n     */\r\n    @editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public serializedCachedData = false;\r\n\r\n    /**\r\n     * Gets the texture data\r\n     */\r\n    public get textureData() {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture width\r\n     */\r\n    public get textureWidth() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Gets the texture height\r\n     */\r\n    public get textureHeight() {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * Creates a new GeometryTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerOutput(\"texture\", NodeGeometryBlockConnectionPointTypes.Texture);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the texture component\r\n     */\r\n    public get texture(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _prepareImgToLoadAsync(url: string) {\r\n        return new Promise<void>((resolve, reject) => {\r\n            const img = new Image();\r\n            const canvas = document.createElement(\"canvas\");\r\n            const ctx = canvas.getContext(\"2d\");\r\n\r\n            img.onload = () => {\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n\r\n                ctx!.drawImage(img, 0, 0);\r\n\r\n                const imageData = ctx!.getImageData(0, 0, img.width, img.height);\r\n                const pixels = imageData.data;\r\n                const floatArray = new Float32Array(pixels.length);\r\n\r\n                for (let i = 0; i < pixels.length; i++) {\r\n                    floatArray[i] = pixels[i] / 255.0;\r\n                }\r\n\r\n                this._data = floatArray;\r\n                this._width = img.width;\r\n                this._height = img.height;\r\n                resolve();\r\n            };\r\n\r\n            img.onerror = () => {\r\n                this._data = null;\r\n                reject();\r\n            };\r\n\r\n            img.src = url;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove stored data\r\n     */\r\n    public cleanData() {\r\n        this._data = null;\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param imageFile defines the file to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public loadTextureFromFileAsync(imageFile: File) {\r\n        return this._prepareImgToLoadAsync(URL.createObjectURL(imageFile));\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param url defines the url to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public loadTextureFromUrlAsync(url: string) {\r\n        return this._prepareImgToLoadAsync(url);\r\n    }\r\n\r\n    /**\r\n     * Load the texture data\r\n     * @param url defines the url to load data from\r\n     * @returns a promise fulfilled when image data is loaded\r\n     */\r\n    public extractFromTextureAsync(texture: Texture) {\r\n        return new Promise<void>((resolve, reject) => {\r\n            if (!texture.isReady()) {\r\n                texture.onLoadObservable.addOnce(() => {\r\n                    return this.extractFromTextureAsync(texture).then(resolve).catch(reject);\r\n                });\r\n                return;\r\n            }\r\n            const size = texture.getSize();\r\n            TextureTools.GetTextureDataAsync(texture, size.width, size.height)\r\n                .then(async (data) => {\r\n                    const floatArray = new Float32Array(data.length);\r\n\r\n                    for (let i = 0; i < data.length; i++) {\r\n                        floatArray[i] = data[i] / 255.0;\r\n                    }\r\n                    this._data = floatArray;\r\n                    this._width = size.width;\r\n                    this._height = size.height;\r\n                    resolve();\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        if (!this._data) {\r\n            this.texture._storedValue = null;\r\n            return;\r\n        }\r\n\r\n        const textureData: INodeGeometryTextureData = {\r\n            data: this._data,\r\n            width: this._width,\r\n            height: this._height,\r\n        };\r\n\r\n        this.texture._storedValue = textureData;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n        serializationObject.serializedCachedData = this.serializedCachedData;\r\n        if (this._data && this.serializedCachedData) {\r\n            serializationObject.data = Array.from(this._data);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this._width = serializationObject.width;\r\n        this._height = serializationObject.height;\r\n        if (serializationObject.data) {\r\n            this._data = new Float32Array(serializationObject.data);\r\n            this.serializedCachedData = true;\r\n        } else {\r\n            this.serializedCachedData = !!serializationObject.serializedCachedData;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryTextureBlock\", GeometryTextureBlock);\r\n", "import { Vector4, type Vector2 } from \"core/Maths/math.vector\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { INodeGeometryTextureData } from \"../../Interfaces/nodeGeometryTextureData\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"core/Decorators/nodeDecorator\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\n\r\n/**\r\n * Block used to fetch a color from texture data\r\n */\r\nexport class GeometryTextureFetchBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating if coordinates should be clamped between 0 and 1\r\n     */\r\n    @editableInPropertyPage(\"Clamp Coordinates\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public clampCoordinates = true;\r\n\r\n    /**\r\n     * Creates a new GeometryTextureFetchBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"texture\", NodeGeometryBlockConnectionPointTypes.Texture);\r\n        this.registerInput(\"coordinates\", NodeGeometryBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"rgba\", NodeGeometryBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"rgb\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"r\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"g\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"b\", NodeGeometryBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"a\", NodeGeometryBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryTextureFetchBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the texture component\r\n     */\r\n    public get texture(): NodeGeometryConnectionPoint {\r\n        return this.inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the coordinates component\r\n     */\r\n    public get coordinates(): NodeGeometryConnectionPoint {\r\n        return this.inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component\r\n     */\r\n    public get rgba(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component\r\n     */\r\n    public get rgb(): NodeGeometryConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component\r\n     */\r\n    public get r(): NodeGeometryConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component\r\n     */\r\n    public get g(): NodeGeometryConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b component\r\n     */\r\n    public get b(): NodeGeometryConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a component\r\n     */\r\n    public get a(): NodeGeometryConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    private _repeatClamp(num: number) {\r\n        if (num >= 0) {\r\n            return num % 1;\r\n        } else {\r\n            return 1 - (Math.abs(num) % 1);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const textureData = this.texture.getConnectedValue(state) as INodeGeometryTextureData;\r\n            if (!textureData || !textureData.data) {\r\n                return null;\r\n            }\r\n\r\n            const uv = this.coordinates.getConnectedValue(state) as Vector2;\r\n\r\n            if (!uv) {\r\n                return null;\r\n            }\r\n\r\n            const u = this.clampCoordinates ? Math.max(0, Math.min(uv.x, 1.0)) : this._repeatClamp(uv.x);\r\n            const v = this.clampCoordinates ? Math.max(0, Math.min(uv.y, 1.0)) : this._repeatClamp(uv.y);\r\n\r\n            const x = Math.floor(u * (textureData.width - 1));\r\n            const y = Math.floor(v * (textureData.height - 1));\r\n            const index = x + textureData.width * y;\r\n\r\n            return Vector4.FromArray(textureData.data, index * 4);\r\n        };\r\n\r\n        this.rgba._storedFunction = (state) => {\r\n            return func(state);\r\n        };\r\n\r\n        this.rgb._storedFunction = (state) => {\r\n            const color = func(state) as Vector4;\r\n            return color ? color.toVector3() : null;\r\n        };\r\n\r\n        this.r._storedFunction = (state) => {\r\n            const color = func(state) as Vector4;\r\n            return color ? color.x : null;\r\n        };\r\n\r\n        this.g._storedFunction = (state) => {\r\n            const color = func(state) as Vector4;\r\n            return color ? color.y : null;\r\n        };\r\n\r\n        this.b._storedFunction = (state) => {\r\n            const color = func(state) as Vector4;\r\n            return color ? color.z : null;\r\n        };\r\n\r\n        this.a._storedFunction = (state) => {\r\n            const color = func(state) as Vector4;\r\n            return color ? color.w : null;\r\n        };\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.clampCoordinates = ${this.clampCoordinates};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.clampCoordinates = this.clampCoordinates;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.clampCoordinates = serializationObject.clampCoordinates;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryTextureFetchBlock\", GeometryTextureFetchBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { extractMinAndMax } from \"../../../Maths/math.functions\";\r\n\r\n/**\r\n * Block used to get the bounding info of a geometry\r\n */\r\nexport class BoundingBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Create a new BoundingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n\r\n        this.registerOutput(\"min\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"max\", NodeGeometryBlockConnectionPointTypes.Vector3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"BoundingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the min output component\r\n     */\r\n    public get min(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the max output component\r\n     */\r\n    public get max(): NodeGeometryConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected _buildBlock() {\r\n        this.min._storedFunction = (state) => {\r\n            const geometry = this.geometry.getConnectedValue(state);\r\n\r\n            if (!geometry) {\r\n                return null;\r\n            }\r\n\r\n            const boundingInfo = extractMinAndMax(geometry.positions!, 0, geometry.positions!.length / 3);\r\n            return boundingInfo.minimum;\r\n        };\r\n\r\n        this.max._storedFunction = (state) => {\r\n            const geometry = this.geometry.getConnectedValue(state);\r\n\r\n            if (!geometry) {\r\n                return null;\r\n            }\r\n\r\n            const boundingInfo = extractMinAndMax(geometry.positions!, 0, geometry.positions!.length / 3);\r\n            return boundingInfo.maximum;\r\n        };\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BoundingBlock\", BoundingBlock);\r\n", "import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { VertexData } from \"../../mesh.vertexData\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport { CSG } from \"core/Meshes/csg\";\r\n\r\n/**\r\n * Operations supported by the boolean block\r\n */\r\nexport enum BooleanGeometryOperations {\r\n    /** Intersect */\r\n    Intersect,\r\n    /** Subtract */\r\n    Subtract,\r\n    /** Union */\r\n    Union,\r\n}\r\n\r\n/**\r\n * Block used to apply a boolean operation between 2 geometries\r\n */\r\nexport class BooleanGeometryBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        options: [\r\n            { label: \"Intersect\", value: BooleanGeometryOperations.Intersect },\r\n            { label: \"Subtract\", value: BooleanGeometryOperations.Subtract },\r\n            { label: \"Union\", value: BooleanGeometryOperations.Union },\r\n        ],\r\n    })\r\n    public operation = BooleanGeometryOperations.Intersect;\r\n\r\n    /**\r\n     * Create a new BooleanGeometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"geometry0\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n        this.registerInput(\"geometry1\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n\r\n        this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"BooleanGeometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry0 input component\r\n     */\r\n    public get geometry0(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry1 input component\r\n     */\r\n    public get geometry1(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            const vertexData0 = this.geometry0.getConnectedValue(state) as VertexData;\r\n            const vertexData1 = this.geometry1.getConnectedValue(state) as VertexData;\r\n\r\n            if (!vertexData0 || !vertexData1) {\r\n                return null;\r\n            }\r\n\r\n            const vertexCount = vertexData0.positions!.length / 3;\r\n            // Ensure that all the fields are filled to avoid problems later on in the graph\r\n            if (!vertexData0.normals && vertexData1.normals) {\r\n                vertexData0.normals = new Array<number>(vertexData0.positions!.length);\r\n            }\r\n            if (!vertexData1.normals && vertexData0.normals) {\r\n                vertexData1.normals = new Array<number>(vertexData1.positions!.length);\r\n            }\r\n            if (!vertexData0.uvs && vertexData1.uvs) {\r\n                vertexData0.uvs = new Array<number>(vertexCount * 2);\r\n            }\r\n            if (!vertexData1.uvs && vertexData0.uvs) {\r\n                vertexData1.uvs = new Array<number>(vertexCount * 2);\r\n            }\r\n            if (!vertexData0.colors && vertexData1.colors) {\r\n                vertexData0.colors = new Array<number>(vertexCount * 4);\r\n            }\r\n            if (!vertexData1.colors && vertexData0.colors) {\r\n                vertexData1.colors = new Array<number>(vertexCount * 4);\r\n            }\r\n\r\n            const CSG0 = CSG.FromVertexData(vertexData0);\r\n            const CSG1 = CSG.FromVertexData(vertexData1);\r\n\r\n            let boolCSG: CSG;\r\n\r\n            switch (this.operation) {\r\n                case BooleanGeometryOperations.Intersect:\r\n                    boolCSG = CSG0.intersect(CSG1);\r\n                    break;\r\n                case BooleanGeometryOperations.Subtract:\r\n                    boolCSG = CSG0.subtract(CSG1);\r\n                    break;\r\n                case BooleanGeometryOperations.Union:\r\n                    boolCSG = CSG0.union(CSG1);\r\n                    break;\r\n            }\r\n\r\n            return boolCSG.toVertexData();\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.output._storedFunction = func;\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        codeString += `${this._codeVariableName}.operation = BABYLON.BooleanGeometryOperations.${BooleanGeometryOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n        if (serializationObject.operation) {\r\n            this.operation = serializationObject.operation;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BooleanGeometryBlock\", BooleanGeometryBlock);\r\n"],
  "mappings": "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",
  "names": ["worker", "decoder", "geometry", "data", "worker", "name", "name", "name", "effect", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "shader", "name", "name", "name", "shader", "name", "shader", "shader", "name", "name", "positions", "name", "name", "name", "name", "name", "radius", "angle", "i", "v", "name", "name", "name", "dashSize", "gapSize", "name", "idx", "name", "name", "shape", "curve", "path3D", "scale", "rotation", "scaleFunction", "rotateFunction", "cap", "custom", "adjustFrame", "name", "name", "name", "path", "path3D", "radius", "tessellation", "radiusFunction", "cap", "name", "name", "name", "indices", "_a", "_b", "_c", "_d", "v", "name", "fr", "isoId", "isoIdR", "y", "x", "name", "name", "name", "name", "points", "SimplificationType", "name", "name", "shader", "name", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "onCreatedEffectParameters", "name", "name", "array", "inputArray", "name", "GreasedLineMeshMaterialType", "GreasedLineMeshColorMode", "GreasedLineMeshColorDistributionType", "name", "shader", "name", "shader", "name", "GreasedLineRibbonPointsMode", "GreasedLineRibbonFacesMode", "GreasedLineRibbonAutoDirectionMode", "name", "name", "name", "v", "GreasedLineMeshColorDistribution", "GreasedLineMeshWidthDistribution", "name", "boundingInfo", "NodeGeometryBlockConnectionPointTypes", "NodeGeometryConnectionPointCompatibilityStates", "NodeGeometryConnectionPointDirection", "name", "name", "name", "NodeGeometryContextualSources", "name", "state", "PropertyTypeForEdition", "name", "state", "name", "source", "name", "state", "name", "state", "name", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "MathBlockOperations", "name", "name", "ConditionBlockTests", "name", "RandomBlockLocks", "name", "name", "t", "name", "state", "name", "state", "name", "state", "name", "name", "state", "name", "state", "name", "state", "GeometryTrigonometryBlockOperations", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "state", "name", "name", "state", "name", "state", "name", "state", "name", "name", "state", "name", "MappingTypes", "name", "name", "name", "name", "name", "name", "name", "BooleanGeometryOperations", "name", "state"]
}
