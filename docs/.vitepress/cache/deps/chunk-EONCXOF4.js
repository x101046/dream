import {
  SphericalHarmonics,
  SphericalPolynomial
} from "./chunk-U2HXY23P.js";
import {
  AbstractMesh,
  CreateGround,
  CreateGroundFromHeightMap,
  CreateGroundVertexData,
  CreateTiledGround,
  CreateTorus,
  CreateTorusVertexData,
  DetailMapConfiguration,
  Geometry,
  Material,
  MaterialFlags,
  MaterialPluginBase,
  MaterialPluginEvent,
  Mesh,
  PassPostProcess,
  PrePassConfiguration,
  PushMaterial,
  Ray,
  StandardMaterial,
  SubMesh,
  TransformNode,
  VertexData,
  VertexDataMaterialInfo,
  _CreationDataStorage
} from "./chunk-X3GGEY53.js";
import {
  Curve3,
  Path2,
  Path3D,
  extractMinAndMax
} from "./chunk-SDHG362Y.js";
import {
  AsyncLoop,
  BaseTexture,
  BoundingInfo,
  Buffer,
  CompatibilityOptions,
  DataBuffer,
  DeepCopier,
  EffectFallbacks,
  Engine,
  ImageProcessingConfiguration,
  InternalTexture,
  InternalTextureSource,
  Logger,
  MaterialDefines,
  MaterialHelper,
  PickingInfo,
  PostProcess,
  PrecisionDate,
  RenderTargetTexture,
  Scene,
  SceneComponentConstants,
  ShaderStore,
  SmartArray,
  Texture,
  ThinEngine,
  Tools,
  UniqueIdGenerator,
  VertexBuffer,
  WebRequest,
  addClipPlaneUniforms,
  bindClipPlane,
  prepareStringDefinesForClipPlanes
} from "./chunk-VAZZWHD2.js";
import {
  Axis,
  Color3,
  Color4,
  EngineStore,
  Epsilon,
  GetClass,
  Matrix,
  Observable,
  PHI,
  Quaternion,
  RegisterClass,
  Scalar,
  SerializationHelper,
  TmpColors,
  TmpVectors,
  ToLinearSpace,
  Vector2,
  Vector3,
  Vector4,
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsImageProcessingConfiguration,
  serializeAsTexture,
  serializeAsVector2
} from "./chunk-ZYQT2WB4.js";

// node_modules/@babylonjs/core/Meshes/abstractMesh.decalMap.js
Object.defineProperty(AbstractMesh.prototype, "decalMap", {
  get: function() {
    return this._decalMap;
  },
  set: function(decalMap) {
    this._decalMap = decalMap;
  },
  enumerable: true,
  configurable: true
});

// node_modules/@babylonjs/core/Misc/workerPool.js
var WorkerPool = class {
  /**
   * Constructor
   * @param workers Array of workers to use for actions
   */
  constructor(workers) {
    this._pendingActions = new Array();
    this._workerInfos = workers.map((worker2) => ({
      workerPromise: Promise.resolve(worker2),
      idle: true
    }));
  }
  /**
   * Terminates all workers and clears any pending actions.
   */
  dispose() {
    for (const workerInfo of this._workerInfos) {
      workerInfo.workerPromise.then((worker2) => {
        worker2.terminate();
      });
    }
    this._workerInfos.length = 0;
    this._pendingActions.length = 0;
  }
  /**
   * Pushes an action to the worker pool. If all the workers are active, the action will be
   * pended until a worker has completed its action.
   * @param action The action to perform. Call onComplete when the action is complete.
   */
  push(action) {
    if (!this._executeOnIdleWorker(action)) {
      this._pendingActions.push(action);
    }
  }
  _executeOnIdleWorker(action) {
    for (const workerInfo of this._workerInfos) {
      if (workerInfo.idle) {
        this._execute(workerInfo, action);
        return true;
      }
    }
    return false;
  }
  _execute(workerInfo, action) {
    workerInfo.idle = false;
    workerInfo.workerPromise.then((worker2) => {
      action(worker2, () => {
        const nextAction = this._pendingActions.shift();
        if (nextAction) {
          this._execute(workerInfo, nextAction);
        } else {
          workerInfo.idle = true;
        }
      });
    });
  }
};
var AutoReleaseWorkerPool = class _AutoReleaseWorkerPool extends WorkerPool {
  constructor(maxWorkers, createWorkerAsync, options = _AutoReleaseWorkerPool.DefaultOptions) {
    super([]);
    this._maxWorkers = maxWorkers;
    this._createWorkerAsync = createWorkerAsync;
    this._options = options;
  }
  push(action) {
    if (!this._executeOnIdleWorker(action)) {
      if (this._workerInfos.length < this._maxWorkers) {
        const workerInfo = {
          workerPromise: this._createWorkerAsync(),
          idle: false
        };
        this._workerInfos.push(workerInfo);
        this._execute(workerInfo, action);
      } else {
        this._pendingActions.push(action);
      }
    }
  }
  _execute(workerInfo, action) {
    if (workerInfo.timeoutId) {
      clearTimeout(workerInfo.timeoutId);
      delete workerInfo.timeoutId;
    }
    super._execute(workerInfo, (worker2, onComplete) => {
      action(worker2, () => {
        onComplete();
        if (workerInfo.idle) {
          workerInfo.timeoutId = setTimeout(() => {
            workerInfo.workerPromise.then((worker3) => {
              worker3.terminate();
            });
            const indexOf = this._workerInfos.indexOf(workerInfo);
            if (indexOf !== -1) {
              this._workerInfos.splice(indexOf, 1);
            }
          }, this._options.idleTimeElapsedBeforeRelease);
        }
      });
    });
  }
};
AutoReleaseWorkerPool.DefaultOptions = {
  idleTimeElapsedBeforeRelease: 1e3
};

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js
function createDecoderAsync(wasmBinary) {
  return new Promise((resolve) => {
    DracoDecoderModule({ wasmBinary }).then((module) => {
      resolve({ module });
    });
  });
}
function decodeMesh(decoderModule, data, attributes, onIndicesData, onAttributeData) {
  let decoder = null;
  let buffer = null;
  let geometry = null;
  try {
    decoder = new decoderModule.Decoder();
    buffer = new decoderModule.DecoderBuffer();
    buffer.Init(data, data.byteLength);
    let status;
    const type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH: {
        const mesh = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, mesh);
        if (!status.ok() || mesh.ptr === 0) {
          throw new Error(status.error_msg());
        }
        const numFaces = mesh.num_faces();
        const numIndices = numFaces * 3;
        const byteLength = numIndices * 4;
        const ptr = decoderModule._malloc(byteLength);
        try {
          decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
          const indices = new Uint32Array(numIndices);
          indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
          onIndicesData(indices);
        } finally {
          decoderModule._free(ptr);
        }
        geometry = mesh;
        break;
      }
      case decoderModule.POINT_CLOUD: {
        const pointCloud = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);
        if (!status.ok() || !pointCloud.ptr) {
          throw new Error(status.error_msg());
        }
        geometry = pointCloud;
        break;
      }
      default: {
        throw new Error(`Invalid geometry type ${type}`);
      }
    }
    const numPoints = geometry.num_points();
    const processAttribute = (decoder2, geometry2, kind, attribute) => {
      const dataType = attribute.data_type();
      const numComponents = attribute.num_components();
      const normalized = attribute.normalized();
      const byteStride = attribute.byte_stride();
      const byteOffset = attribute.byte_offset();
      const dataTypeInfo = {
        [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },
        [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },
        [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },
        [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },
        [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },
        [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },
        [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 }
      };
      const info = dataTypeInfo[dataType];
      if (!info) {
        throw new Error(`Invalid data type ${dataType}`);
      }
      const numValues = numPoints * numComponents;
      const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;
      const ptr = decoderModule._malloc(byteLength);
      try {
        decoder2.GetAttributeDataArrayForAllPoints(geometry2, attribute, dataType, byteLength, ptr);
        const data2 = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);
        onAttributeData(kind, data2.slice(), numComponents, byteOffset, byteStride, normalized);
      } finally {
        decoderModule._free(ptr);
      }
    };
    if (attributes) {
      for (const kind in attributes) {
        const id = attributes[kind];
        const attribute = decoder.GetAttributeByUniqueId(geometry, id);
        processAttribute(decoder, geometry, kind, attribute);
      }
    } else {
      const dracoAttributeTypes = {
        position: decoderModule.POSITION,
        normal: decoderModule.NORMAL,
        color: decoderModule.COLOR,
        uv: decoderModule.TEX_COORD
      };
      for (const kind in dracoAttributeTypes) {
        const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);
        if (id !== -1) {
          const attribute = decoder.GetAttribute(geometry, id);
          processAttribute(decoder, geometry, kind, attribute);
        }
      }
    }
    return numPoints;
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    if (buffer) {
      decoderModule.destroy(buffer);
    }
    if (decoder) {
      decoderModule.destroy(decoder);
    }
  }
}
function worker() {
  let decoderPromise;
  onmessage = (event) => {
    const message = event.data;
    switch (message.id) {
      case "init": {
        const decoder = message.decoder;
        if (decoder.url) {
          importScripts(decoder.url);
          decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });
        }
        postMessage({ id: "initDone" });
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then((decoder) => {
          const numPoints = decodeMesh(decoder, message.dataView, message.attributes, (indices) => {
            postMessage({ id: "indices", data: indices }, [indices.buffer]);
          }, (kind, data, size, offset, stride, normalized) => {
            postMessage({ id: "attribute", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);
          });
          postMessage({ id: "decodeMeshDone", totalVertices: numPoints });
        });
        break;
      }
    }
  };
}
var DracoCompression = class _DracoCompression {
  /**
   * Returns true if the decoder configuration is available.
   */
  static get DecoderAvailable() {
    const decoder = _DracoCompression.Configuration.decoder;
    return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" || decoder.fallbackUrl);
  }
  static GetDefaultNumWorkers() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  }
  /**
   * Default instance for the draco compression object.
   */
  static get Default() {
    if (!_DracoCompression._Default) {
      _DracoCompression._Default = new _DracoCompression();
    }
    return _DracoCompression._Default;
  }
  /**
   * Constructor
   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
   */
  constructor(numWorkers = _DracoCompression.DefaultNumWorkers) {
    const decoder = _DracoCompression.Configuration.decoder;
    const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" ? {
      url: Tools.GetBabylonScriptURL(decoder.wasmUrl, true),
      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true))
    } : {
      url: Tools.GetBabylonScriptURL(decoder.fallbackUrl),
      wasmBinaryPromise: Promise.resolve(void 0)
    };
    if (numWorkers && typeof Worker === "function" && typeof URL === "function") {
      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {
        const workerContent = `${decodeMesh}(${worker})()`;
        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        return new AutoReleaseWorkerPool(numWorkers, () => {
          return new Promise((resolve, reject) => {
            const worker2 = new Worker(workerBlobUrl);
            const onError = (error) => {
              worker2.removeEventListener("error", onError);
              worker2.removeEventListener("message", onMessage);
              reject(error);
            };
            const onMessage = (event) => {
              if (event.data.id === "initDone") {
                worker2.removeEventListener("error", onError);
                worker2.removeEventListener("message", onMessage);
                resolve(worker2);
              }
            };
            worker2.addEventListener("error", onError);
            worker2.addEventListener("message", onMessage);
            worker2.postMessage({
              id: "init",
              decoder: {
                url: decoderInfo.url,
                wasmBinary: decoderWasmBinary
              }
            });
          });
        });
      });
    } else {
      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {
        if (!decoderInfo.url) {
          throw new Error("Draco decoder module is not available");
        }
        return Tools.LoadBabylonScriptAsync(decoderInfo.url).then(() => {
          return createDecoderAsync(decoderWasmBinary);
        });
      });
    }
  }
  /**
   * Stop all async operations and release resources.
   */
  dispose() {
    if (this._workerPoolPromise) {
      this._workerPoolPromise.then((workerPool) => {
        workerPool.dispose();
      });
    }
    delete this._workerPoolPromise;
    delete this._decoderModulePromise;
  }
  /**
   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.
   * @returns a promise that resolves when ready
   */
  whenReadyAsync() {
    if (this._workerPoolPromise) {
      return this._workerPoolPromise.then(() => {
      });
    }
    if (this._decoderModulePromise) {
      return this._decoderModulePromise.then(() => {
      });
    }
    return Promise.resolve();
  }
  _decodeMeshAsync(data, attributes, gltfNormalizedOverride) {
    const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);
    const applyGltfNormalizedOverride = (kind, normalized) => {
      if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== void 0) {
        if (normalized !== gltfNormalizedOverride[kind]) {
          Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);
        }
        return gltfNormalizedOverride[kind];
      } else {
        return normalized;
      }
    };
    if (this._workerPoolPromise) {
      return this._workerPoolPromise.then((workerPool) => {
        return new Promise((resolve, reject) => {
          workerPool.push((worker2, onComplete) => {
            let resultIndices = null;
            const resultAttributes = [];
            const onError = (error) => {
              worker2.removeEventListener("error", onError);
              worker2.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            const onMessage = (event) => {
              const message = event.data;
              switch (message.id) {
                case "decodeMeshDone": {
                  worker2.removeEventListener("error", onError);
                  worker2.removeEventListener("message", onMessage);
                  resolve({ indices: resultIndices, attributes: resultAttributes, totalVertices: message.totalVertices });
                  onComplete();
                  break;
                }
                case "indices": {
                  resultIndices = message.data;
                  break;
                }
                case "attribute": {
                  resultAttributes.push({
                    kind: message.kind,
                    data: message.data,
                    size: message.size,
                    byteOffset: message.byteOffset,
                    byteStride: message.byteStride,
                    normalized: applyGltfNormalizedOverride(message.kind, message.normalized)
                  });
                  break;
                }
              }
            };
            worker2.addEventListener("error", onError);
            worker2.addEventListener("message", onMessage);
            const dataViewCopy = dataView.slice();
            worker2.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
          });
        });
      });
    }
    if (this._decoderModulePromise) {
      return this._decoderModulePromise.then((decoder) => {
        let resultIndices = null;
        const resultAttributes = [];
        const numPoints = decodeMesh(decoder.module, dataView, attributes, (indices) => {
          resultIndices = indices;
        }, (kind, data2, size, byteOffset, byteStride, normalized) => {
          resultAttributes.push({
            kind,
            data: data2,
            size,
            byteOffset,
            byteStride,
            normalized
          });
        });
        return { indices: resultIndices, attributes: resultAttributes, totalVertices: numPoints };
      });
    }
    throw new Error("Draco decoder module is not available");
  }
  /**
   * Decode Draco compressed mesh data to Babylon geometry.
   * @param name The name to use when creating the geometry
   * @param scene The scene to use when creating the geometry
   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
   * @returns A promise that resolves with the decoded geometry
   */
  decodeMeshToGeometryAsync(name52, scene, data, attributes) {
    return this._decodeMeshAsync(data, attributes).then((meshData) => {
      const geometry = new Geometry(name52, scene);
      if (meshData.indices) {
        geometry.setIndices(meshData.indices);
      }
      for (const attribute of meshData.attributes) {
        geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
      }
      return geometry;
    });
  }
  /** @internal */
  _decodeMeshToGeometryForGltfAsync(name52, scene, data, attributes, gltfNormalizedOverride) {
    return this._decodeMeshAsync(data, attributes, gltfNormalizedOverride).then((meshData) => {
      const geometry = new Geometry(name52, scene);
      if (meshData.indices) {
        geometry.setIndices(meshData.indices);
      }
      for (const attribute of meshData.attributes) {
        geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
      }
      return geometry;
    });
  }
  /**
   * Decode Draco compressed mesh data to Babylon vertex data.
   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
   * @returns A promise that resolves with the decoded vertex data
   * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases
   */
  decodeMeshAsync(data, attributes) {
    return this._decodeMeshAsync(data, attributes).then((meshData) => {
      const vertexData = new VertexData();
      if (meshData.indices) {
        vertexData.indices = meshData.indices;
      }
      for (const attribute of meshData.attributes) {
        const floatData = VertexBuffer.GetFloatData(attribute.data, attribute.size, VertexBuffer.GetDataType(attribute.data), attribute.byteOffset, attribute.byteStride, attribute.normalized, meshData.totalVertices);
        vertexData.set(floatData, attribute.kind);
      }
      return vertexData;
    });
  }
};
DracoCompression.Configuration = {
  decoder: {
    wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,
    wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,
    fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`
  }
};
DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();
DracoCompression._Default = null;

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var MeshoptCompression = class _MeshoptCompression {
  /**
   * Default instance for the meshoptimizer object.
   */
  static get Default() {
    if (!_MeshoptCompression._Default) {
      _MeshoptCompression._Default = new _MeshoptCompression();
    }
    return _MeshoptCompression._Default;
  }
  /**
   * Constructor
   */
  constructor() {
    const decoder = _MeshoptCompression.Configuration.decoder;
    this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {
      return MeshoptDecoder.ready;
    });
  }
  /**
   * Stop all async operations and release resources.
   */
  dispose() {
    delete this._decoderModulePromise;
  }
  /**
   * Decode meshopt data.
   * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder
   * @param source The input data.
   * @param count The number of elements.
   * @param stride The stride in bytes.
   * @param mode The compression mode.
   * @param filter The compression filter.
   * @returns a Promise<Uint8Array> that resolves to the decoded data
   */
  decodeGltfBufferAsync(source, count, stride, mode, filter) {
    return this._decoderModulePromise.then(() => {
      const result = new Uint8Array(count * stride);
      MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);
      return result;
    });
  }
};
MeshoptCompression.Configuration = {
  decoder: {
    url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`
  }
};
MeshoptCompression._Default = null;

// node_modules/@babylonjs/core/Meshes/csg.js
var currentCSGMeshId = 0;
var Vertex = class _Vertex {
  /**
   * Initializes the vertex
   * @param pos The position of the vertex
   * @param normal The normal of the vertex
   * @param uv The texture coordinate of the vertex
   * @param vertColor The RGBA color of the vertex
   */
  constructor(pos, normal, uv, vertColor) {
    this.pos = pos;
    this.normal = normal;
    this.uv = uv;
    this.vertColor = vertColor;
  }
  /**
   * Make a clone, or deep copy, of the vertex
   * @returns A new Vertex
   */
  clone() {
    var _a, _b;
    return new _Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());
  }
  /**
   * Invert all orientation-specific data (e.g. vertex normal). Called when the
   * orientation of a polygon is flipped.
   */
  flip() {
    this.normal = this.normal.scale(-1);
  }
  /**
   * Create a new vertex between this vertex and `other` by linearly
   * interpolating all properties using a parameter of `t`. Subclasses should
   * override this to interpolate additional properties.
   * @param other the vertex to interpolate against
   * @param t The factor used to linearly interpolate between the vertices
   */
  interpolate(other, t) {
    return new _Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : void 0, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : void 0);
  }
};
var CSGPlane = class _CSGPlane {
  /**
   * Initializes the plane
   * @param normal The normal for the plane
   * @param w
   */
  constructor(normal, w) {
    this.normal = normal;
    this.w = w;
  }
  /**
   * Construct a plane from three points
   * @param a Point a
   * @param b Point b
   * @param c Point c
   */
  static FromPoints(a, b, c) {
    const v0 = c.subtract(a);
    const v1 = b.subtract(a);
    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {
      return null;
    }
    const n = Vector3.Normalize(Vector3.Cross(v0, v1));
    return new _CSGPlane(n, Vector3.Dot(n, a));
  }
  /**
   * Clone, or make a deep copy of the plane
   * @returns a new Plane
   */
  clone() {
    return new _CSGPlane(this.normal.clone(), this.w);
  }
  /**
   * Flip the face of the plane
   */
  flip() {
    this.normal.scaleInPlace(-1);
    this.w = -this.w;
  }
  /**
   * Split `polygon` by this plane if needed, then put the polygon or polygon
   * fragments in the appropriate lists. Coplanar polygons go into either
  `* coplanarFront` or `coplanarBack` depending on their orientation with
   * respect to this plane. Polygons in front or in back of this plane go into
   * either `front` or `back`
   * @param polygon The polygon to be split
   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane
   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane
   * @param front Will contain the polygons in front of the plane
   * @param back Will contain the polygons begind the plane
   */
  splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {
    const COPLANAR = 0;
    const FRONT = 1;
    const BACK = 2;
    const SPANNING = 3;
    let polygonType = 0;
    const types = [];
    let i;
    let t;
    for (i = 0; i < polygon.vertices.length; i++) {
      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;
      const type = t < -_CSGPlane.EPSILON ? BACK : t > _CSGPlane.EPSILON ? FRONT : COPLANAR;
      polygonType |= type;
      types.push(type);
    }
    switch (polygonType) {
      case COPLANAR:
        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
        break;
      case FRONT:
        front.push(polygon);
        break;
      case BACK:
        back.push(polygon);
        break;
      case SPANNING: {
        const f = [], b = [];
        for (i = 0; i < polygon.vertices.length; i++) {
          const j = (i + 1) % polygon.vertices.length;
          const ti = types[i], tj = types[j];
          const vi = polygon.vertices[i], vj = polygon.vertices[j];
          if (ti !== BACK) {
            f.push(vi);
          }
          if (ti !== FRONT) {
            b.push(ti !== BACK ? vi.clone() : vi);
          }
          if ((ti | tj) === SPANNING) {
            t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));
            const v = vi.interpolate(vj, t);
            f.push(v);
            b.push(v.clone());
          }
        }
        let poly;
        if (f.length >= 3) {
          poly = new CSGPolygon(f, polygon.shared);
          if (poly.plane) {
            front.push(poly);
          }
        }
        if (b.length >= 3) {
          poly = new CSGPolygon(b, polygon.shared);
          if (poly.plane) {
            back.push(poly);
          }
        }
        break;
      }
    }
  }
};
CSGPlane.EPSILON = 1e-5;
var CSGPolygon = class _CSGPolygon {
  /**
   * Initializes the polygon
   * @param vertices The vertices of the polygon
   * @param shared The properties shared across all polygons
   */
  constructor(vertices, shared) {
    this.vertices = vertices;
    this.shared = shared;
    this.plane = CSGPlane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
  }
  /**
   * Clones, or makes a deep copy, or the polygon
   */
  clone() {
    const vertices = this.vertices.map((v) => v.clone());
    return new _CSGPolygon(vertices, this.shared);
  }
  /**
   * Flips the faces of the polygon
   */
  flip() {
    this.vertices.reverse().map((v) => {
      v.flip();
    });
    this.plane.flip();
  }
};
var Node = class _Node {
  /**
   * Initializes the node
   * @param polygons A collection of polygons held in the node
   */
  constructor(polygons) {
    this._plane = null;
    this._front = null;
    this._back = null;
    this._polygons = new Array();
    if (polygons) {
      this.build(polygons);
    }
  }
  /**
   * Clones, or makes a deep copy, of the node
   * @returns The cloned node
   */
  clone() {
    const node = new _Node();
    node._plane = this._plane && this._plane.clone();
    node._front = this._front && this._front.clone();
    node._back = this._back && this._back.clone();
    node._polygons = this._polygons.map((p) => p.clone());
    return node;
  }
  /**
   * Convert solid space to empty space and empty space to solid space
   */
  invert() {
    for (let i = 0; i < this._polygons.length; i++) {
      this._polygons[i].flip();
    }
    if (this._plane) {
      this._plane.flip();
    }
    if (this._front) {
      this._front.invert();
    }
    if (this._back) {
      this._back.invert();
    }
    const temp = this._front;
    this._front = this._back;
    this._back = temp;
  }
  /**
   * Recursively remove all polygons in `polygons` that are inside this BSP
   * tree.
   * @param polygons Polygons to remove from the BSP
   * @returns Polygons clipped from the BSP
   */
  clipPolygons(polygons) {
    if (!this._plane) {
      return polygons.slice();
    }
    let front = [], back = [];
    for (let i = 0; i < polygons.length; i++) {
      this._plane.splitPolygon(polygons[i], front, back, front, back);
    }
    if (this._front) {
      front = this._front.clipPolygons(front);
    }
    if (this._back) {
      back = this._back.clipPolygons(back);
    } else {
      back = [];
    }
    return front.concat(back);
  }
  /**
   * Remove all polygons in this BSP tree that are inside the other BSP tree
   * `bsp`.
   * @param bsp BSP containing polygons to remove from this BSP
   */
  clipTo(bsp) {
    this._polygons = bsp.clipPolygons(this._polygons);
    if (this._front) {
      this._front.clipTo(bsp);
    }
    if (this._back) {
      this._back.clipTo(bsp);
    }
  }
  /**
   * Return a list of all polygons in this BSP tree
   * @returns List of all polygons in this BSP tree
   */
  allPolygons() {
    let polygons = this._polygons.slice();
    if (this._front) {
      polygons = polygons.concat(this._front.allPolygons());
    }
    if (this._back) {
      polygons = polygons.concat(this._back.allPolygons());
    }
    return polygons;
  }
  /**
   * Build a BSP tree out of `polygons`. When called on an existing tree, the
   * new polygons are filtered down to the bottom of the tree and become new
   * nodes there. Each set of polygons is partitioned using the first polygon
   * (no heuristic is used to pick a good split)
   * @param polygons Polygons used to construct the BSP tree
   */
  build(polygons) {
    if (!polygons.length) {
      return;
    }
    if (!this._plane) {
      this._plane = polygons[0].plane.clone();
    }
    const front = [], back = [];
    for (let i = 0; i < polygons.length; i++) {
      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);
    }
    if (front.length) {
      if (!this._front) {
        this._front = new _Node();
      }
      this._front.build(front);
    }
    if (back.length) {
      if (!this._back) {
        this._back = new _Node();
      }
      this._back.build(back);
    }
  }
};
var CSG = class _CSG {
  constructor() {
    this._polygons = new Array();
  }
  /**
   * Convert a VertexData to CSG
   * @param mesh defines the VertexData to convert to CSG
   * @returns the new CSG
   */
  static FromVertexData(data) {
    let vertex, polygon, vertices;
    const polygons = [];
    const indices = data.indices;
    const positions = data.positions;
    const normals = data.normals;
    const uvs = data.uvs;
    const vertColors = data.colors;
    if (!indices || !positions) {
      throw "BABYLON.CSG: VertexData must at least contain positions and indices";
    }
    for (let i = 0; i < indices.length; i += 3) {
      vertices = [];
      for (let j = 0; j < 3; j++) {
        const indexIndices = i + j;
        const offset = indices[indexIndices];
        const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();
        const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : void 0;
        const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : void 0;
        const position = Vector3.FromArray(positions, offset * 3);
        vertex = new Vertex(position, normal, uv, vertColor);
        vertices.push(vertex);
      }
      polygon = new CSGPolygon(vertices, { subMeshId: 0, meshId: currentCSGMeshId, materialIndex: 0 });
      if (polygon.plane) {
        polygons.push(polygon);
      }
    }
    const csg = _CSG._FromPolygons(polygons);
    csg.matrix = Matrix.Identity();
    csg.position = Vector3.Zero();
    csg.rotation = Vector3.Zero();
    csg.scaling = Vector3.One();
    csg.rotationQuaternion = Quaternion.Identity();
    currentCSGMeshId++;
    return csg;
  }
  /**
   * Convert the Mesh to CSG
   * @param mesh The Mesh to convert to CSG
   * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)
   * @returns A new CSG from the Mesh
   */
  static FromMesh(mesh, absolute = false) {
    let vertex, normal, uv = void 0, position, vertColor = void 0, polygon, vertices;
    const polygons = [];
    let matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;
    let invertWinding = false;
    if (mesh instanceof Mesh) {
      mesh.computeWorldMatrix(true);
      matrix = mesh.getWorldMatrix();
      meshPosition = mesh.position.clone();
      meshRotation = mesh.rotation.clone();
      if (mesh.rotationQuaternion) {
        meshRotationQuaternion = mesh.rotationQuaternion.clone();
      }
      meshScaling = mesh.scaling.clone();
      if (mesh.material && absolute) {
        invertWinding = mesh.material.sideOrientation === 0;
      }
    } else {
      throw "BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";
    }
    const indices = mesh.getIndices(), positions = mesh.getVerticesData(VertexBuffer.PositionKind), normals = mesh.getVerticesData(VertexBuffer.NormalKind), uvs = mesh.getVerticesData(VertexBuffer.UVKind), vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);
    const subMeshes = mesh.subMeshes;
    for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {
      for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {
        vertices = [];
        for (let j = 0; j < 3; j++) {
          const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;
          const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);
          if (uvs) {
            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);
          }
          if (vertColors) {
            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);
          }
          const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);
          position = Vector3.TransformCoordinates(sourcePosition, matrix);
          normal = Vector3.TransformNormal(sourceNormal, matrix);
          vertex = new Vertex(position, normal, uv, vertColor);
          vertices.push(vertex);
        }
        polygon = new CSGPolygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });
        if (polygon.plane) {
          polygons.push(polygon);
        }
      }
    }
    const csg = _CSG._FromPolygons(polygons);
    csg.matrix = absolute ? Matrix.Identity() : matrix;
    csg.position = absolute ? Vector3.Zero() : meshPosition;
    csg.rotation = absolute ? Vector3.Zero() : meshRotation;
    csg.scaling = absolute ? Vector3.One() : meshScaling;
    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;
    currentCSGMeshId++;
    return csg;
  }
  /**
   * Construct a CSG solid from a list of `CSG.Polygon` instances.
   * @param polygons Polygons used to construct a CSG solid
   */
  static _FromPolygons(polygons) {
    const csg = new _CSG();
    csg._polygons = polygons;
    return csg;
  }
  /**
   * Clones, or makes a deep copy, of the CSG
   * @returns A new CSG
   */
  clone() {
    const csg = new _CSG();
    csg._polygons = this._polygons.map((p) => p.clone());
    csg.copyTransformAttributes(this);
    return csg;
  }
  /**
   * Unions this CSG with another CSG
   * @param csg The CSG to union against this CSG
   * @returns The unioned CSG
   */
  union(csg) {
    const a = new Node(this.clone()._polygons);
    const b = new Node(csg.clone()._polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    return _CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  /**
   * Unions this CSG with another CSG in place
   * @param csg The CSG to union against this CSG
   */
  unionInPlace(csg) {
    const a = new Node(this._polygons);
    const b = new Node(csg._polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    this._polygons = a.allPolygons();
  }
  /**
   * Subtracts this CSG with another CSG
   * @param csg The CSG to subtract against this CSG
   * @returns A new CSG
   */
  subtract(csg) {
    const a = new Node(this.clone()._polygons);
    const b = new Node(csg.clone()._polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    return _CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  /**
   * Subtracts this CSG with another CSG in place
   * @param csg The CSG to subtract against this CSG
   */
  subtractInPlace(csg) {
    const a = new Node(this._polygons);
    const b = new Node(csg._polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    this._polygons = a.allPolygons();
  }
  /**
   * Intersect this CSG with another CSG
   * @param csg The CSG to intersect against this CSG
   * @returns A new CSG
   */
  intersect(csg) {
    const a = new Node(this.clone()._polygons);
    const b = new Node(csg.clone()._polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    return _CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
  }
  /**
   * Intersects this CSG with another CSG in place
   * @param csg The CSG to intersect against this CSG
   */
  intersectInPlace(csg) {
    const a = new Node(this._polygons);
    const b = new Node(csg._polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    this._polygons = a.allPolygons();
  }
  /**
   * Return a new CSG solid with solid and empty space switched. This solid is
   * not modified.
   * @returns A new CSG solid with solid and empty space switched
   */
  inverse() {
    const csg = this.clone();
    csg.inverseInPlace();
    return csg;
  }
  /**
   * Inverses the CSG in place
   */
  inverseInPlace() {
    this._polygons.map((p) => {
      p.flip();
    });
  }
  /**
   * This is used to keep meshes transformations so they can be restored
   * when we build back a Babylon Mesh
   * NB : All CSG operations are performed in world coordinates
   * @param csg The CSG to copy the transform attributes from
   * @returns This CSG
   */
  copyTransformAttributes(csg) {
    this.matrix = csg.matrix;
    this.position = csg.position;
    this.rotation = csg.rotation;
    this.scaling = csg.scaling;
    this.rotationQuaternion = csg.rotationQuaternion;
    return this;
  }
  /**
   * Build vertex data from CSG
   * Coordinates here are in world space
   * @returns the final vertex data
   */
  toVertexData(onBeforePolygonProcessing = null, onAfterPolygonProcessing = null) {
    const matrix = this.matrix.clone();
    matrix.invert();
    const polygons = this._polygons;
    const vertices = [];
    const indices = [];
    const normals = [];
    let uvs = null;
    let vertColors = null;
    const vertex = Vector3.Zero();
    const normal = Vector3.Zero();
    const uv = Vector2.Zero();
    const vertColor = new Color4(0, 0, 0, 0);
    const polygonIndices = [0, 0, 0];
    const vertice_dict = {};
    let vertex_idx;
    for (let i = 0, il = polygons.length; i < il; i++) {
      const polygon = polygons[i];
      if (onBeforePolygonProcessing) {
        onBeforePolygonProcessing(polygon);
      }
      for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {
        polygonIndices[0] = 0;
        polygonIndices[1] = j - 1;
        polygonIndices[2] = j;
        for (let k = 0; k < 3; k++) {
          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);
          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);
          if (polygon.vertices[polygonIndices[k]].uv) {
            if (!uvs) {
              uvs = [];
            }
            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);
          }
          if (polygon.vertices[polygonIndices[k]].vertColor) {
            if (!vertColors) {
              vertColors = [];
            }
            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);
          }
          const localVertex = Vector3.TransformCoordinates(vertex, matrix);
          const localNormal = Vector3.TransformNormal(normal, matrix);
          vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z];
          let areUvsDifferent = false;
          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {
            areUvsDifferent = true;
          }
          let areColorsDifferent = false;
          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {
            areColorsDifferent = true;
          }
          if (!(typeof vertex_idx !== "undefined" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {
            vertices.push(localVertex.x, localVertex.y, localVertex.z);
            if (uvs) {
              uvs.push(uv.x, uv.y);
            }
            normals.push(normal.x, normal.y, normal.z);
            if (vertColors) {
              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);
            }
            vertex_idx = vertice_dict[localVertex.x + "," + localVertex.y + "," + localVertex.z] = vertices.length / 3 - 1;
          }
          indices.push(vertex_idx);
          if (onAfterPolygonProcessing) {
            onAfterPolygonProcessing();
          }
        }
      }
    }
    const result = new VertexData();
    result.positions = vertices;
    result.normals = normals;
    if (uvs) {
      result.uvs = uvs;
    }
    if (vertColors) {
      result.colors = vertColors;
    }
    result.indices = indices;
    return result;
  }
  /**
   * Build Raw mesh from CSG
   * Coordinates here are in world space
   * @param name The name of the mesh geometry
   * @param scene The Scene
   * @param keepSubMeshes Specifies if the submeshes should be kept
   * @returns A new Mesh
   */
  buildMeshGeometry(name52, scene, keepSubMeshes) {
    const mesh = new Mesh(name52, scene);
    const polygons = this._polygons;
    let currentIndex = 0;
    const subMeshDict = {};
    let subMeshObj;
    if (keepSubMeshes) {
      polygons.sort((a, b) => {
        if (a.shared.meshId === b.shared.meshId) {
          return a.shared.subMeshId - b.shared.subMeshId;
        } else {
          return a.shared.meshId - b.shared.meshId;
        }
      });
    }
    const vertexData = this.toVertexData((polygon) => {
      if (!subMeshDict[polygon.shared.meshId]) {
        subMeshDict[polygon.shared.meshId] = {};
      }
      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {
        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {
          indexStart: Infinity,
          indexEnd: -Infinity,
          materialIndex: polygon.shared.materialIndex
        };
      }
      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];
    }, () => {
      subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);
      subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);
      currentIndex++;
    });
    vertexData.applyToMesh(mesh);
    if (keepSubMeshes) {
      let materialIndexOffset = 0, materialMaxIndex;
      mesh.subMeshes = [];
      for (const m in subMeshDict) {
        materialMaxIndex = -1;
        for (const sm in subMeshDict[m]) {
          subMeshObj = subMeshDict[m][sm];
          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);
          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);
        }
        materialIndexOffset += ++materialMaxIndex;
      }
    }
    return mesh;
  }
  /**
   * Build Mesh from CSG taking material and transforms into account
   * @param name The name of the Mesh
   * @param material The material of the Mesh
   * @param scene The Scene
   * @param keepSubMeshes Specifies if submeshes should be kept
   * @returns The new Mesh
   */
  toMesh(name52, material = null, scene, keepSubMeshes) {
    const mesh = this.buildMeshGeometry(name52, scene, keepSubMeshes);
    mesh.material = material;
    mesh.position.copyFrom(this.position);
    mesh.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      mesh.rotationQuaternion = this.rotationQuaternion.clone();
    }
    mesh.scaling.copyFrom(this.scaling);
    mesh.computeWorldMatrix(true);
    return mesh;
  }
};

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var ShaderMaterial = class _ShaderMaterial extends PushMaterial {
  /**
   * Instantiate a new shader material.
   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
   * This returned material effects how the mesh will look based on the code in the shaders.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial
   * @param name Define the name of the material in the scene
   * @param scene Define the scene the material belongs to
   * @param shaderPath Defines  the route to the shader code in one of three ways:
   *  * object: \{ vertex: "custom", fragment: "custom" \}, used with Effect.ShadersStore["customVertexShader"] and Effect.ShadersStore["customFragmentShader"]
   *  * object: \{ vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ vertexSource: "vertex shader code string", fragmentSource: "fragment shader code string" \} using with strings containing the shaders code
   *  * string: "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.
   * @param options Define the options used to create the shader
   * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.
   */
  constructor(name52, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
    super(name52, scene, storeEffectOnSubMeshes);
    this._textures = {};
    this._textureArrays = {};
    this._externalTextures = {};
    this._floats = {};
    this._ints = {};
    this._uints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors3Arrays = {};
    this._colors4 = {};
    this._colors4Arrays = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._quaternions = {};
    this._quaternionsArrays = {};
    this._matrices = {};
    this._matrixArrays = {};
    this._matrices3x3 = {};
    this._matrices2x2 = {};
    this._vectors2Arrays = {};
    this._vectors3Arrays = {};
    this._vectors4Arrays = {};
    this._uniformBuffers = {};
    this._textureSamplers = {};
    this._storageBuffers = {};
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._multiview = false;
    this._materialHelperNeedsPreviousMatrices = false;
    this._shaderPath = shaderPath;
    this._options = Object.assign({ needAlphaBlending: false, needAlphaTesting: false, attributes: ["position", "normal", "uv"], uniforms: ["worldViewProjection"], uniformBuffers: [], samplers: [], externalTextures: [], samplerObjects: [], storageBuffers: [], defines: [], useClipPlane: false }, options);
  }
  /**
   * Gets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  get shaderPath() {
    return this._shaderPath;
  }
  /**
   * Sets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  set shaderPath(shaderPath) {
    this._shaderPath = shaderPath;
  }
  /**
   * Gets the options used to compile the shader.
   * They can be modified to trigger a new compilation
   */
  get options() {
    return this._options;
  }
  /**
   * is multiview set to true?
   */
  get isMultiview() {
    return this._multiview;
  }
  /**
   * Gets the current class name of the material e.g. "ShaderMaterial"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "ShaderMaterial";
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    return this.alpha < 1 || this._options.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._options.needAlphaTesting;
  }
  _checkUniform(uniformName) {
    if (this._options.uniforms.indexOf(uniformName) === -1) {
      this._options.uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTexture(name52, texture) {
    if (this._options.samplers.indexOf(name52) === -1) {
      this._options.samplers.push(name52);
    }
    this._textures[name52] = texture;
    return this;
  }
  /**
   * Set a texture array in the shader.
   * @param name Define the name of the uniform sampler array as defined in the shader
   * @param textures Define the list of textures to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureArray(name52, textures) {
    if (this._options.samplers.indexOf(name52) === -1) {
      this._options.samplers.push(name52);
    }
    this._checkUniform(name52);
    this._textureArrays[name52] = textures;
    return this;
  }
  /**
   * Set an internal texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setExternalTexture(name52, texture) {
    if (this._options.externalTextures.indexOf(name52) === -1) {
      this._options.externalTextures.push(name52);
    }
    this._externalTextures[name52] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloat(name52, value) {
    this._checkUniform(name52);
    this._floats[name52] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setInt(name52, value) {
    this._checkUniform(name52);
    this._ints[name52] = value;
    return this;
  }
  /**
   * Set a unsigned int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUInt(name52, value) {
    this._checkUniform(name52);
    this._uints[name52] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloats(name52, value) {
    this._checkUniform(name52);
    this._floatsArrays[name52] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3(name52, value) {
    this._checkUniform(name52);
    this._colors3[name52] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a Color3 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3Array(name52, value) {
    this._checkUniform(name52);
    this._colors3Arrays[name52] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4(name52, value) {
    this._checkUniform(name52);
    this._colors4[name52] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Color4 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4Array(name52, value) {
    this._checkUniform(name52);
    this._colors4Arrays[name52] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector2(name52, value) {
    this._checkUniform(name52);
    this._vectors2[name52] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector3(name52, value) {
    this._checkUniform(name52);
    this._vectors3[name52] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector4(name52, value) {
    this._checkUniform(name52);
    this._vectors4[name52] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Quaternion.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternion(name52, value) {
    this._checkUniform(name52);
    this._quaternions[name52] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Quaternion array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternionArray(name52, value) {
    this._checkUniform(name52);
    this._quaternionsArrays[name52] = value.reduce((arr, quaternion) => {
      quaternion.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a mat4 in the shader from a Matrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix(name52, value) {
    this._checkUniform(name52);
    this._matrices[name52] = value;
    return this;
  }
  /**
   * Set a float32Array in the shader from a matrix array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrices(name52, value) {
    this._checkUniform(name52);
    const float32Array = new Float32Array(value.length * 16);
    for (let index = 0; index < value.length; index++) {
      const matrix = value[index];
      matrix.copyToArray(float32Array, index * 16);
    }
    this._matrixArrays[name52] = float32Array;
    return this;
  }
  /**
   * Set a mat3 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix3x3(name52, value) {
    this._checkUniform(name52);
    this._matrices3x3[name52] = value;
    return this;
  }
  /**
   * Set a mat2 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix2x2(name52, value) {
    this._checkUniform(name52);
    this._matrices2x2[name52] = value;
    return this;
  }
  /**
   * Set a vec2 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray2(name52, value) {
    this._checkUniform(name52);
    this._vectors2Arrays[name52] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray3(name52, value) {
    this._checkUniform(name52);
    this._vectors3Arrays[name52] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray4(name52, value) {
    this._checkUniform(name52);
    this._vectors4Arrays[name52] = value;
    return this;
  }
  /**
   * Set a uniform buffer in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUniformBuffer(name52, buffer) {
    if (this._options.uniformBuffers.indexOf(name52) === -1) {
      this._options.uniformBuffers.push(name52);
    }
    this._uniformBuffers[name52] = buffer;
    return this;
  }
  /**
   * Set a texture sampler in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param sampler Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureSampler(name52, sampler) {
    if (this._options.samplerObjects.indexOf(name52) === -1) {
      this._options.samplerObjects.push(name52);
    }
    this._textureSamplers[name52] = sampler;
    return this;
  }
  /**
   * Set a storage buffer in the shader
   * @param name Define the name of the storage buffer as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setStorageBuffer(name52, buffer) {
    if (this._options.storageBuffers.indexOf(name52) === -1) {
      this._options.storageBuffers.push(name52);
    }
    this._storageBuffers[name52] = buffer;
    return this;
  }
  /**
   * Adds, removes, or replaces the specified shader define and value.
   * * setDefine("MY_DEFINE", true); // enables a boolean define
   * * setDefine("MY_DEFINE", "0.5"); // adds "#define MY_DEFINE 0.5" to the shader (or sets and replaces the value of any existing define with that name)
   * * setDefine("MY_DEFINE", false); // disables and removes the define
   * Note if the active defines do change, the shader will be recompiled and this can be expensive.
   * @param define the define name e.g., "OUTPUT_TO_SRGB" or "#define OUTPUT_TO_SRGB". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.
   * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setDefine(define, value) {
    const defineName = define.trimEnd() + " ";
    const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));
    if (existingDefineIdx >= 0) {
      this.options.defines.splice(existingDefineIdx, 1);
    }
    if (typeof value !== "boolean" || value) {
      this.options.defines.push(defineName + value);
    }
    return this;
  }
  /**
   * Specifies that the submesh is ready to be used
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    return this.isReady(mesh, useInstances, subMesh);
  }
  /**
   * Checks if the material is ready to render the requested mesh
   * @param mesh Define the mesh to render
   * @param useInstances Define whether or not the material is used with instances
   * @param subMesh defines which submesh to render
   * @returns true if ready, otherwise false
   */
  isReady(mesh, useInstances, subMesh) {
    var _a, _b, _c, _d;
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    if (this.isFrozen) {
      if (storeEffectOnSubMeshes) {
        if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
          return true;
        }
      } else {
        const effect2 = this._drawWrapper.effect;
        if (effect2 && effect2._wasPreviouslyReady && effect2._wasPreviouslyUsingInstances === useInstances) {
          return true;
        }
      }
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    const defines = [];
    const attribs = [];
    const fallbacks = new EffectFallbacks();
    let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
      this._multiview = true;
      defines.push("#define MULTIVIEW");
      if (this._options.uniforms.indexOf("viewProjection") !== -1 && this._options.uniforms.indexOf("viewProjectionR") === -1) {
        this._options.uniforms.push("viewProjectionR");
      }
    }
    for (let index = 0; index < this._options.defines.length; index++) {
      const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
      defines.push(defineToAdd);
    }
    for (let index = 0; index < this._options.attributes.length; index++) {
      attribs.push(this._options.attributes[index]);
    }
    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {
        attribs.push(VertexBuffer.ColorKind);
      }
      defines.push("#define VERTEXCOLOR");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);
      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
          attribs.push(VertexBuffer.ColorInstanceKind);
          defines.push("#define INSTANCESCOLOR");
        }
      }
    }
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      const skeleton = mesh.skeleton;
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      fallbacks.addCPUSkinningFallback(0, mesh);
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
        if (this._options.uniforms.indexOf("boneTextureWidth") === -1) {
          this._options.uniforms.push("boneTextureWidth");
        }
        if (this._options.samplers.indexOf("boneSampler") === -1) {
          this._options.samplers.push("boneSampler");
        }
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        if (this._options.uniforms.indexOf("mBones") === -1) {
          this._options.uniforms.push("mBones");
        }
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    let numInfluencers = 0;
    const manager = mesh ? mesh.morphTargetManager : null;
    if (manager) {
      const uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
      const tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
      const normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
      numInfluencers = manager.numInfluencers;
      if (uv) {
        defines.push("#define MORPHTARGETS_UV");
      }
      if (tangent) {
        defines.push("#define MORPHTARGETS_TANGENT");
      }
      if (normal) {
        defines.push("#define MORPHTARGETS_NORMAL");
      }
      if (numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
      }
      if (manager.isUsingTextureForTargets) {
        defines.push("#define MORPHTARGETS_TEXTURE");
        if (this._options.uniforms.indexOf("morphTargetTextureIndices") === -1) {
          this._options.uniforms.push("morphTargetTextureIndices");
        }
        if (this._options.samplers.indexOf("morphTargets") === -1) {
          this._options.samplers.push("morphTargets");
        }
      }
      defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
      for (let index = 0; index < numInfluencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
      }
      if (numInfluencers > 0) {
        uniforms = uniforms.slice();
        uniforms.push("morphTargetInfluences");
        uniforms.push("morphTargetTextureInfo");
        uniforms.push("morphTargetTextureIndices");
      }
    } else {
      defines.push("#define NUM_MORPH_INFLUENCERS 0");
    }
    if (mesh) {
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (this._options.uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
          this._options.uniforms.push("bakedVertexAnimationSettings");
        }
        if (this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
          this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted");
        }
        if (this._options.uniforms.indexOf("bakedVertexAnimationTime") === -1) {
          this._options.uniforms.push("bakedVertexAnimationTime");
        }
        if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
          this._options.samplers.push("bakedVertexAnimationTexture");
        }
      }
      MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    }
    for (const name52 in this._textures) {
      if (!this._textures[name52].isReady()) {
        return false;
      }
    }
    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
      defines.push("#define ALPHATEST");
    }
    if (this._options.useClipPlane !== false) {
      addClipPlaneUniforms(uniforms);
      prepareStringDefinesForClipPlanes(this, scene, defines);
    }
    if (this._useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
      if (this._options.uniforms.indexOf("logarithmicDepthConstant") === -1) {
        this._options.uniforms.push("logarithmicDepthConstant");
      }
    }
    if (this.customShaderNameResolve) {
      uniforms = uniforms.slice();
      uniformBuffers = uniformBuffers.slice();
      samplers = samplers.slice();
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
    }
    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;
    const previousEffect = (_a = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _a !== void 0 ? _a : null;
    const previousDefines = (_b = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.defines) !== null && _b !== void 0 ? _b : null;
    const join = defines.join("\n");
    let effect = previousEffect;
    if (previousDefines !== join) {
      effect = engine.createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
        shaderLanguage: this._options.shaderLanguage
      }, engine);
      if (storeEffectOnSubMeshes) {
        subMesh.setEffect(effect, join, this._materialContext);
      } else if (drawWrapper) {
        drawWrapper.setEffect(effect, join);
      }
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = (_c = subMesh !== null && subMesh !== void 0 ? subMesh : mesh === null || mesh === void 0 ? void 0 : mesh.subMeshes[0]) !== null && _c !== void 0 ? _c : null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
    }
    effect._wasPreviouslyUsingInstances = !!useInstances;
    if ((_d = !(effect === null || effect === void 0 ? void 0 : effect.isReady())) !== null && _d !== void 0 ? _d : true) {
      return false;
    }
    if (previousEffect !== effect) {
      scene.resetCachedMaterial();
    }
    effect._wasPreviouslyReady = true;
    return true;
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   * @param effectOverride - If provided, use this effect instead of internal effect
   */
  bindOnlyWorldMatrix(world, effectOverride) {
    const scene = this.getScene();
    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this.getEffect();
    if (!effect) {
      return;
    }
    if (this._options.uniforms.indexOf("world") !== -1) {
      effect.setMatrix("world", world);
    }
    if (this._options.uniforms.indexOf("worldView") !== -1) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
      effect.setMatrix("worldView", this._cachedWorldViewMatrix);
    }
    if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
      effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) === null || _a === void 0 ? void 0 : _a.effect, subMesh);
  }
  /**
   * Binds the material to the mesh
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh to bind the material to
   * @param effectOverride - If provided, use this effect instead of internal effect
   * @param subMesh defines the submesh to bind the material to
   */
  bind(world, mesh, effectOverride, subMesh) {
    var _a;
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : storeEffectOnSubMeshes ? subMesh.effect : this.getEffect();
    if (!effect) {
      return;
    }
    const scene = this.getScene();
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world, effectOverride);
    const uniformBuffers = this._options.uniformBuffers;
    let useSceneUBO = false;
    if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {
      for (let i = 0; i < uniformBuffers.length; ++i) {
        const bufferName = uniformBuffers[i];
        switch (bufferName) {
          case "Mesh":
            if (mesh) {
              mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              mesh.transferToEffect(world);
            }
            break;
          case "Scene":
            MaterialHelper.BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
            scene.finalizeSceneUbo();
            useSceneUBO = true;
            break;
        }
      }
    }
    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, mesh.visibility) : scene.getCachedMaterial() !== this;
    if (effect && mustRebind) {
      if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
        effect.setMatrix("view", scene.getViewMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
        effect.setMatrix("projection", scene.getProjectionMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
        effect.setMatrix("viewProjection", scene.getTransformMatrix());
        if (this._multiview) {
          effect.setMatrix("viewProjectionR", scene._transformMatrixR);
        }
      }
      if (scene.activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
        effect.setVector3("cameraPosition", scene.activeCamera.globalPosition);
      }
      MaterialHelper.BindBonesParameters(mesh, effect);
      bindClipPlane(effect, this, scene);
      if (this._useLogarithmicDepth) {
        MaterialHelper.BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);
      }
      let name52;
      for (name52 in this._textures) {
        effect.setTexture(name52, this._textures[name52]);
      }
      for (name52 in this._textureArrays) {
        effect.setTextureArray(name52, this._textureArrays[name52]);
      }
      for (name52 in this._externalTextures) {
        effect.setExternalTexture(name52, this._externalTextures[name52]);
      }
      for (name52 in this._ints) {
        effect.setInt(name52, this._ints[name52]);
      }
      for (name52 in this._uints) {
        effect.setUInt(name52, this._uints[name52]);
      }
      for (name52 in this._floats) {
        effect.setFloat(name52, this._floats[name52]);
      }
      for (name52 in this._floatsArrays) {
        effect.setArray(name52, this._floatsArrays[name52]);
      }
      for (name52 in this._colors3) {
        effect.setColor3(name52, this._colors3[name52]);
      }
      for (name52 in this._colors3Arrays) {
        effect.setArray3(name52, this._colors3Arrays[name52]);
      }
      for (name52 in this._colors4) {
        const color = this._colors4[name52];
        effect.setFloat4(name52, color.r, color.g, color.b, color.a);
      }
      for (name52 in this._colors4Arrays) {
        effect.setArray4(name52, this._colors4Arrays[name52]);
      }
      for (name52 in this._vectors2) {
        effect.setVector2(name52, this._vectors2[name52]);
      }
      for (name52 in this._vectors3) {
        effect.setVector3(name52, this._vectors3[name52]);
      }
      for (name52 in this._vectors4) {
        effect.setVector4(name52, this._vectors4[name52]);
      }
      for (name52 in this._quaternions) {
        effect.setQuaternion(name52, this._quaternions[name52]);
      }
      for (name52 in this._matrices) {
        effect.setMatrix(name52, this._matrices[name52]);
      }
      for (name52 in this._matrixArrays) {
        effect.setMatrices(name52, this._matrixArrays[name52]);
      }
      for (name52 in this._matrices3x3) {
        effect.setMatrix3x3(name52, this._matrices3x3[name52]);
      }
      for (name52 in this._matrices2x2) {
        effect.setMatrix2x2(name52, this._matrices2x2[name52]);
      }
      for (name52 in this._vectors2Arrays) {
        effect.setArray2(name52, this._vectors2Arrays[name52]);
      }
      for (name52 in this._vectors3Arrays) {
        effect.setArray3(name52, this._vectors3Arrays[name52]);
      }
      for (name52 in this._vectors4Arrays) {
        effect.setArray4(name52, this._vectors4Arrays[name52]);
      }
      for (name52 in this._quaternionsArrays) {
        effect.setArray4(name52, this._quaternionsArrays[name52]);
      }
      for (name52 in this._uniformBuffers) {
        const buffer = this._uniformBuffers[name52].getBuffer();
        if (buffer) {
          effect.bindUniformBuffer(buffer, name52);
        }
      }
      for (name52 in this._textureSamplers) {
        effect.setTextureSampler(name52, this._textureSamplers[name52]);
      }
      for (name52 in this._storageBuffers) {
        effect.setStorageBuffer(name52, this._storageBuffers[name52]);
      }
    }
    if (effect && mesh && (mustRebind || !this.isFrozen)) {
      const manager = mesh.morphTargetManager;
      if (manager && manager.numInfluencers > 0) {
        MaterialHelper.BindMorphTargetParameters(mesh, effect);
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, !!effect._wasPreviouslyUsingInstances);
      }
    }
    this._afterBind(mesh, effect);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    for (const name52 in this._textures) {
      activeTextures.push(this._textures[name52]);
    }
    for (const name52 in this._textureArrays) {
      const array = this._textureArrays[name52];
      for (let index = 0; index < array.length; index++) {
        activeTextures.push(array[index]);
      }
    }
    return activeTextures;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    for (const name52 in this._textures) {
      if (this._textures[name52] === texture) {
        return true;
      }
    }
    for (const name52 in this._textureArrays) {
      const array = this._textureArrays[name52];
      for (let index = 0; index < array.length; index++) {
        if (array[index] === texture) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @returns the cloned material
   */
  clone(name52) {
    const result = SerializationHelper.Clone(() => new _ShaderMaterial(name52, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
    result.name = name52;
    result.id = name52;
    if (typeof result._shaderPath === "object") {
      result._shaderPath = Object.assign({}, result._shaderPath);
    }
    this._options = Object.assign({}, this._options);
    Object.keys(this._options).forEach((propName) => {
      const propValue = this._options[propName];
      if (Array.isArray(propValue)) {
        this._options[propName] = propValue.slice(0);
      }
    });
    this.stencil.copyTo(result.stencil);
    for (const key in this._textures) {
      result.setTexture(key, this._textures[key]);
    }
    for (const key in this._textureArrays) {
      result.setTextureArray(key, this._textureArrays[key]);
    }
    for (const key in this._externalTextures) {
      result.setExternalTexture(key, this._externalTextures[key]);
    }
    for (const key in this._ints) {
      result.setInt(key, this._ints[key]);
    }
    for (const key in this._uints) {
      result.setUInt(key, this._uints[key]);
    }
    for (const key in this._floats) {
      result.setFloat(key, this._floats[key]);
    }
    for (const key in this._floatsArrays) {
      result.setFloats(key, this._floatsArrays[key]);
    }
    for (const key in this._colors3) {
      result.setColor3(key, this._colors3[key]);
    }
    for (const key in this._colors3Arrays) {
      result._colors3Arrays[key] = this._colors3Arrays[key];
    }
    for (const key in this._colors4) {
      result.setColor4(key, this._colors4[key]);
    }
    for (const key in this._colors4Arrays) {
      result._colors4Arrays[key] = this._colors4Arrays[key];
    }
    for (const key in this._vectors2) {
      result.setVector2(key, this._vectors2[key]);
    }
    for (const key in this._vectors3) {
      result.setVector3(key, this._vectors3[key]);
    }
    for (const key in this._vectors4) {
      result.setVector4(key, this._vectors4[key]);
    }
    for (const key in this._quaternions) {
      result.setQuaternion(key, this._quaternions[key]);
    }
    for (const key in this._quaternionsArrays) {
      result._quaternionsArrays[key] = this._quaternionsArrays[key];
    }
    for (const key in this._matrices) {
      result.setMatrix(key, this._matrices[key]);
    }
    for (const key in this._matrixArrays) {
      result._matrixArrays[key] = this._matrixArrays[key].slice();
    }
    for (const key in this._matrices3x3) {
      result.setMatrix3x3(key, this._matrices3x3[key]);
    }
    for (const key in this._matrices2x2) {
      result.setMatrix2x2(key, this._matrices2x2[key]);
    }
    for (const key in this._vectors2Arrays) {
      result.setArray2(key, this._vectors2Arrays[key]);
    }
    for (const key in this._vectors3Arrays) {
      result.setArray3(key, this._vectors3Arrays[key]);
    }
    for (const key in this._vectors4Arrays) {
      result.setArray4(key, this._vectors4Arrays[key]);
    }
    for (const key in this._uniformBuffers) {
      result.setUniformBuffer(key, this._uniformBuffers[key]);
    }
    for (const key in this._textureSamplers) {
      result.setTextureSampler(key, this._textureSamplers[key]);
    }
    for (const key in this._storageBuffers) {
      result.setStorageBuffer(key, this._storageBuffers[key]);
    }
    return result;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      let name52;
      for (name52 in this._textures) {
        this._textures[name52].dispose();
      }
      for (name52 in this._textureArrays) {
        const array = this._textureArrays[name52];
        for (let index = 0; index < array.length; index++) {
          array[index].dispose();
        }
      }
    }
    this._textures = {};
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /**
   * Serializes this material in a JSON representation
   * @returns the serialized material object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.ShaderMaterial";
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
    let name52;
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.textures = {};
    for (name52 in this._textures) {
      serializationObject.textures[name52] = this._textures[name52].serialize();
    }
    serializationObject.textureArrays = {};
    for (name52 in this._textureArrays) {
      serializationObject.textureArrays[name52] = [];
      const array = this._textureArrays[name52];
      for (let index = 0; index < array.length; index++) {
        serializationObject.textureArrays[name52].push(array[index].serialize());
      }
    }
    serializationObject.ints = {};
    for (name52 in this._ints) {
      serializationObject.ints[name52] = this._ints[name52];
    }
    serializationObject.uints = {};
    for (name52 in this._uints) {
      serializationObject.uints[name52] = this._uints[name52];
    }
    serializationObject.floats = {};
    for (name52 in this._floats) {
      serializationObject.floats[name52] = this._floats[name52];
    }
    serializationObject.FloatArrays = {};
    for (name52 in this._floatsArrays) {
      serializationObject.FloatArrays[name52] = this._floatsArrays[name52];
    }
    serializationObject.colors3 = {};
    for (name52 in this._colors3) {
      serializationObject.colors3[name52] = this._colors3[name52].asArray();
    }
    serializationObject.colors3Arrays = {};
    for (name52 in this._colors3Arrays) {
      serializationObject.colors3Arrays[name52] = this._colors3Arrays[name52];
    }
    serializationObject.colors4 = {};
    for (name52 in this._colors4) {
      serializationObject.colors4[name52] = this._colors4[name52].asArray();
    }
    serializationObject.colors4Arrays = {};
    for (name52 in this._colors4Arrays) {
      serializationObject.colors4Arrays[name52] = this._colors4Arrays[name52];
    }
    serializationObject.vectors2 = {};
    for (name52 in this._vectors2) {
      serializationObject.vectors2[name52] = this._vectors2[name52].asArray();
    }
    serializationObject.vectors3 = {};
    for (name52 in this._vectors3) {
      serializationObject.vectors3[name52] = this._vectors3[name52].asArray();
    }
    serializationObject.vectors4 = {};
    for (name52 in this._vectors4) {
      serializationObject.vectors4[name52] = this._vectors4[name52].asArray();
    }
    serializationObject.quaternions = {};
    for (name52 in this._quaternions) {
      serializationObject.quaternions[name52] = this._quaternions[name52].asArray();
    }
    serializationObject.matrices = {};
    for (name52 in this._matrices) {
      serializationObject.matrices[name52] = this._matrices[name52].asArray();
    }
    serializationObject.matrixArray = {};
    for (name52 in this._matrixArrays) {
      serializationObject.matrixArray[name52] = this._matrixArrays[name52];
    }
    serializationObject.matrices3x3 = {};
    for (name52 in this._matrices3x3) {
      serializationObject.matrices3x3[name52] = this._matrices3x3[name52];
    }
    serializationObject.matrices2x2 = {};
    for (name52 in this._matrices2x2) {
      serializationObject.matrices2x2[name52] = this._matrices2x2[name52];
    }
    serializationObject.vectors2Arrays = {};
    for (name52 in this._vectors2Arrays) {
      serializationObject.vectors2Arrays[name52] = this._vectors2Arrays[name52];
    }
    serializationObject.vectors3Arrays = {};
    for (name52 in this._vectors3Arrays) {
      serializationObject.vectors3Arrays[name52] = this._vectors3Arrays[name52];
    }
    serializationObject.vectors4Arrays = {};
    for (name52 in this._vectors4Arrays) {
      serializationObject.vectors4Arrays[name52] = this._vectors4Arrays[name52];
    }
    serializationObject.quaternionsArrays = {};
    for (name52 in this._quaternionsArrays) {
      serializationObject.quaternionsArrays[name52] = this._quaternionsArrays[name52];
    }
    return serializationObject;
  }
  /**
   * Creates a shader material from parsed shader material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new material
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
    let name52;
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    for (name52 in source.textures) {
      material.setTexture(name52, Texture.Parse(source.textures[name52], scene, rootUrl));
    }
    for (name52 in source.textureArrays) {
      const array = source.textureArrays[name52];
      const textureArray = [];
      for (let index = 0; index < array.length; index++) {
        textureArray.push(Texture.Parse(array[index], scene, rootUrl));
      }
      material.setTextureArray(name52, textureArray);
    }
    for (name52 in source.ints) {
      material.setInt(name52, source.ints[name52]);
    }
    for (name52 in source.uints) {
      material.setUInt(name52, source.uints[name52]);
    }
    for (name52 in source.floats) {
      material.setFloat(name52, source.floats[name52]);
    }
    for (name52 in source.floatsArrays) {
      material.setFloats(name52, source.floatsArrays[name52]);
    }
    for (name52 in source.colors3) {
      material.setColor3(name52, Color3.FromArray(source.colors3[name52]));
    }
    for (name52 in source.colors3Arrays) {
      const colors = source.colors3Arrays[name52].reduce((arr, num, i) => {
        if (i % 3 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color3.FromArray(color));
      material.setColor3Array(name52, colors);
    }
    for (name52 in source.colors4) {
      material.setColor4(name52, Color4.FromArray(source.colors4[name52]));
    }
    for (name52 in source.colors4Arrays) {
      const colors = source.colors4Arrays[name52].reduce((arr, num, i) => {
        if (i % 4 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color4.FromArray(color));
      material.setColor4Array(name52, colors);
    }
    for (name52 in source.vectors2) {
      material.setVector2(name52, Vector2.FromArray(source.vectors2[name52]));
    }
    for (name52 in source.vectors3) {
      material.setVector3(name52, Vector3.FromArray(source.vectors3[name52]));
    }
    for (name52 in source.vectors4) {
      material.setVector4(name52, Vector4.FromArray(source.vectors4[name52]));
    }
    for (name52 in source.quaternions) {
      material.setQuaternion(name52, Quaternion.FromArray(source.quaternions[name52]));
    }
    for (name52 in source.matrices) {
      material.setMatrix(name52, Matrix.FromArray(source.matrices[name52]));
    }
    for (name52 in source.matrixArray) {
      material._matrixArrays[name52] = new Float32Array(source.matrixArray[name52]);
    }
    for (name52 in source.matrices3x3) {
      material.setMatrix3x3(name52, source.matrices3x3[name52]);
    }
    for (name52 in source.matrices2x2) {
      material.setMatrix2x2(name52, source.matrices2x2[name52]);
    }
    for (name52 in source.vectors2Arrays) {
      material.setArray2(name52, source.vectors2Arrays[name52]);
    }
    for (name52 in source.vectors3Arrays) {
      material.setArray3(name52, source.vectors3Arrays[name52]);
    }
    for (name52 in source.vectors4Arrays) {
      material.setArray4(name52, source.vectors4Arrays[name52]);
    }
    for (name52 in source.quaternionsArrays) {
      material.setArray4(name52, source.quaternionsArrays[name52]);
    }
    return material;
  }
  /**
   * Creates a new ShaderMaterial from a snippet saved in a remote file
   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromFileAsync(name52, url, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            if (name52) {
              output.name = name52;
            }
            resolve(output);
          } else {
            reject("Unable to load the ShaderMaterial");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  /**
   * Creates a ShaderMaterial from a snippet saved by the Inspector
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.shaderMaterial);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.vertex.js
var name = "meshUVSpaceRendererVertexShader";
var shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 projMatrix;varying vec2 vDecalTC;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
void main(void) {vec3 positionUpdated=position;vec3 normalUpdated=normal;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);mat3 normWorldSM=mat3(finalWorld);vec3 vNormalW;
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vNormalW=normalize(normWorldSM*normalUpdated);
#endif
vec3 normalView=normalize((projMatrix*vec4(vNormalW,0.0)).xyz);vec3 decalTC=(projMatrix*worldPos).xyz;vDecalTC=decalTC.xy;gl_Position=vec4(uv*2.0-1.0,normalView.z>0.0 ? 2. : decalTC.z,1.0);}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.fragment.js
var name2 = "meshUVSpaceRendererPixelShader";
var shader2 = `precision highp float;varying vec2 vDecalTC;uniform sampler2D textureSampler;void main(void) {if (vDecalTC.x<0. || vDecalTC.x>1. || vDecalTC.y<0. || vDecalTC.y>1.) {discard;}
gl_FragColor=texture2D(textureSampler,vDecalTC);}
`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.vertex.js
var name3 = "meshUVSpaceRendererMaskerVertexShader";
var shader3 = `attribute vec2 uv;varying vec2 vUV;void main(void) {gl_Position=vec4(vec2(uv.x,uv.y)*2.0-1.0,0.,1.0);vUV=uv;}`;
ShaderStore.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.fragment.js
var name4 = "meshUVSpaceRendererMaskerPixelShader";
var shader4 = `varying vec2 vUV;void main(void) {gl_FragColor=vec4(1.0,1.0,1.0,1.0);}
`;
ShaderStore.ShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.fragment.js
var name5 = "meshUVSpaceRendererFinaliserPixelShader";
var shader5 = `precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D maskTextureSampler;uniform vec2 textureSize;void main() {vec4 mask=texture2D(maskTextureSampler,vUV).rgba;if (mask.r>0.5) {gl_FragColor=texture2D(textureSampler,vUV);} else {vec2 texelSize=4.0/textureSize;vec2 uv_p01=vUV+vec2(-1.0,0.0)*texelSize;vec2 uv_p21=vUV+vec2(1.0,0.0)*texelSize;vec2 uv_p10=vUV+vec2(0.0,-1.0)*texelSize;vec2 uv_p12=vUV+vec2(0.0,1.0)*texelSize;float mask_p01=texture2D(maskTextureSampler,uv_p01).r;float mask_p21=texture2D(maskTextureSampler,uv_p21).r;float mask_p10=texture2D(maskTextureSampler,uv_p10).r;float mask_p12=texture2D(maskTextureSampler,uv_p12).r;vec4 col=vec4(0.0,0.0,0.0,0.0);float total_weight=0.0;if (mask_p01>0.5) {col+=texture2D(textureSampler,uv_p01);total_weight+=1.0;}
if (mask_p21>0.5) {col+=texture2D(textureSampler,uv_p21);total_weight+=1.0;}
if (mask_p10>0.5) {col+=texture2D(textureSampler,uv_p10);total_weight+=1.0;}
if (mask_p12>0.5) {col+=texture2D(textureSampler,uv_p12);total_weight+=1.0;}
if (total_weight>0.0) {gl_FragColor=col/total_weight;} else {gl_FragColor=col;}}}
`;
ShaderStore.ShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.vertex.js
var name6 = "meshUVSpaceRendererFinaliserVertexShader";
var shader6 = `precision highp float;attribute vec3 position;attribute vec2 uv;uniform mat4 worldViewProjection;varying vec2 vUV;void main() {gl_Position=worldViewProjection*vec4(position,1.0);vUV=uv;}
`;
ShaderStore.ShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Meshes/meshUVSpaceRenderer.js
var MeshUVSpaceRenderer = class _MeshUVSpaceRenderer {
  static _GetShader(scene) {
    if (!scene._meshUVSpaceRendererShader) {
      const shader52 = new ShaderMaterial("meshUVSpaceRendererShader", scene, {
        vertex: "meshUVSpaceRenderer",
        fragment: "meshUVSpaceRenderer"
      }, {
        attributes: ["position", "normal", "uv"],
        uniforms: ["world", "projMatrix"],
        samplers: ["textureSampler"],
        needAlphaBlending: true
      });
      shader52.backFaceCulling = false;
      shader52.alphaMode = 2;
      scene.onDisposeObservable.add(() => {
        var _a;
        (_a = scene._meshUVSpaceRendererShader) === null || _a === void 0 ? void 0 : _a.dispose();
        scene._meshUVSpaceRendererShader = null;
      });
      scene._meshUVSpaceRendererShader = shader52;
    }
    return scene._meshUVSpaceRendererShader;
  }
  static _GetMaskShader(scene) {
    if (!scene._meshUVSpaceRendererMaskShader) {
      const shader52 = new ShaderMaterial("meshUVSpaceRendererMaskShader", scene, {
        vertex: "meshUVSpaceRendererMasker",
        fragment: "meshUVSpaceRendererMasker"
      }, {
        attributes: ["position", "uv"],
        uniforms: ["worldViewProjection"]
      });
      shader52.backFaceCulling = false;
      shader52.alphaMode = 2;
      scene.onDisposeObservable.add(() => {
        var _a;
        (_a = scene._meshUVSpaceRendererMaskShader) === null || _a === void 0 ? void 0 : _a.dispose();
        scene._meshUVSpaceRendererMaskShader = null;
      });
      scene._meshUVSpaceRendererMaskShader = shader52;
    }
    return scene._meshUVSpaceRendererMaskShader;
  }
  static _IsRenderTargetTexture(texture) {
    return texture.renderList !== void 0;
  }
  /**
   * Creates a new MeshUVSpaceRenderer
   * @param mesh The mesh used for the source UV space
   * @param scene The scene the mesh belongs to
   * @param options The options to use when creating the texture
   */
  constructor(mesh, scene, options) {
    this._textureCreatedInternally = false;
    this._configureUserCreatedTexture = true;
    this._maskTexture = null;
    this._finalPostProcess = null;
    this.clearColor = new Color4(0, 0, 0, 0);
    this._mesh = mesh;
    this._scene = scene;
    this._options = Object.assign({ width: 1024, height: 1024, textureType: 0, generateMipMaps: true, optimizeUVAllocation: true, uvEdgeBlending: false }, options);
  }
  /**
   * Checks if the texture is ready to be used
   * @returns true if the texture is ready to be used
   */
  isReady() {
    var _a, _b, _c, _d;
    if (!this.texture) {
      this._createDiffuseRTT();
    }
    const textureIsReady = _MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) ? this.texture.isReadyForRendering() : this.texture.isReady();
    const maskIsReady = (_b = (_a = this._maskTexture) === null || _a === void 0 ? void 0 : _a.isReadyForRendering()) !== null && _b !== void 0 ? _b : true;
    const postProcessIsReady = (_d = (_c = this._finalPostProcess) === null || _c === void 0 ? void 0 : _c.isReady()) !== null && _d !== void 0 ? _d : true;
    return textureIsReady && maskIsReady && postProcessIsReady;
  }
  /**
   * Projects and renders a texture in the mesh UV space
   * @param texture The texture
   * @param position The position of the center of projection (world space coordinates)
   * @param normal The direction of the projection (world space coordinates)
   * @param size The size of the projection
   * @param angle The rotation angle around the direction of the projection
   */
  renderTexture(texture, position, normal, size, angle = 0) {
    if (!this.texture) {
      this._createDiffuseRTT();
    } else if (this._configureUserCreatedTexture) {
      this._configureUserCreatedRTT();
    }
    if (_MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {
      const matrix = this._createProjectionMatrix(position, normal, size, angle);
      const shader52 = _MeshUVSpaceRenderer._GetShader(this._scene);
      shader52.setTexture("textureSampler", texture);
      shader52.setMatrix("projMatrix", matrix);
      this.texture.render();
    }
  }
  /**
   * Clears the texture map
   */
  clear() {
    var _a, _b, _c;
    if (_MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) && this.texture.renderTarget) {
      const engine = this._scene.getEngine();
      engine.bindFramebuffer(this.texture.renderTarget);
      engine.clear(this.clearColor, true, true, true);
      engine.unBindFramebuffer(this.texture.renderTarget);
    }
    if ((_a = this._finalPostProcess) === null || _a === void 0 ? void 0 : _a.inputTexture) {
      const engine = this._scene.getEngine();
      engine.bindFramebuffer((_b = this._finalPostProcess) === null || _b === void 0 ? void 0 : _b.inputTexture);
      engine.clear(this.clearColor, true, true, true);
      engine.unBindFramebuffer((_c = this._finalPostProcess) === null || _c === void 0 ? void 0 : _c.inputTexture);
    }
  }
  /**
   * Disposes of the resources
   */
  dispose() {
    var _a, _b;
    if (this._textureCreatedInternally) {
      this.texture.dispose();
      this._textureCreatedInternally = false;
    }
    this._configureUserCreatedTexture = true;
    (_a = this._maskTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    this._maskTexture = null;
    (_b = this._finalPostProcess) === null || _b === void 0 ? void 0 : _b.dispose();
    this._finalPostProcess = null;
  }
  _configureUserCreatedRTT() {
    this._configureUserCreatedTexture = false;
    if (_MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {
      this.texture.setMaterialForRendering(this._mesh, _MeshUVSpaceRenderer._GetShader(this._scene));
      this.texture.onClearObservable.add(() => {
      });
      this.texture.renderList = [this._mesh];
      if (this._options.uvEdgeBlending) {
        this._createMaskTexture();
        this._createPostProcess();
        this.texture.addPostProcess(this._finalPostProcess);
      }
    }
  }
  _createDiffuseRTT() {
    this._textureCreatedInternally = true;
    const texture = this._createRenderTargetTexture(this._options.width, this._options.height);
    texture.setMaterialForRendering(this._mesh, _MeshUVSpaceRenderer._GetShader(this._scene));
    this.texture = texture;
    this._configureUserCreatedTexture = false;
    if (this._options.uvEdgeBlending) {
      this._createMaskTexture();
      this._createPostProcess();
      texture.addPostProcess(this._finalPostProcess);
    }
  }
  _createMaskTexture() {
    if (this._maskTexture) {
      return;
    }
    this._maskTexture = new RenderTargetTexture(
      this._mesh.name + "_maskTexture",
      { width: this._options.width, height: this._options.height },
      this._scene,
      false,
      // No mipmaps for the mask texture
      true,
      0,
      false,
      2,
      void 0,
      void 0,
      void 0,
      6
    );
    this._maskTexture.clearColor = new Color4(0, 0, 0, 0);
    this._maskTexture.renderList.push(this._mesh);
    this._maskTexture.setMaterialForRendering(this._mesh, _MeshUVSpaceRenderer._GetMaskShader(this._scene));
    this._maskTexture.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    this._scene.customRenderTargets.push(this._maskTexture);
  }
  _createPostProcess() {
    if (this._finalPostProcess) {
      return;
    }
    this._finalPostProcess = new PostProcess(this._mesh.name + "_fixSeamsPostProcess", "meshUVSpaceRendererFinaliser", ["textureSize"], ["textureSampler", "maskTextureSampler"], 1, null, 1, this._scene.getEngine(), false, null, this._options.textureType);
    this._finalPostProcess.onApplyObservable.add((effect) => {
      effect.setTexture("maskTextureSampler", this._maskTexture);
      effect.setFloat2("textureSize", this._options.width, this._options.height);
    });
  }
  _createRenderTargetTexture(width, height) {
    const rtt = new RenderTargetTexture(this._mesh.name + "_uvspaceTexture", { width, height }, this._scene, this._options.generateMipMaps, true, this._options.textureType, false, this._options.generateMipMaps ? 3 : 2, false, false, false, 5);
    rtt.renderParticles = false;
    rtt.optimizeUVAllocation = !!this._options.optimizeUVAllocation;
    rtt.onClearObservable.addOnce(() => {
      this._scene.getEngine().clear(this.clearColor, true, true, true);
      rtt.onClearObservable.add(() => {
      });
    });
    rtt.renderList = [this._mesh];
    return rtt;
  }
  _createProjectionMatrix(position, normal, size, angle = 0) {
    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
    const pitch = Math.atan2(normal.y, len);
    const p = position.add(normal.scale(size.z * 0.5));
    const projWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(p.x, p.y, p.z));
    const inverseProjWorldMatrix = Matrix.Invert(projWorldMatrix);
    const projMatrix = Matrix.FromArray([2 / size.x, 0, 0, 0, 0, 2 / size.y, 0, 0, 0, 0, 1 / size.z, 0, 0, 0, 0, 1]);
    const screenMatrix = Matrix.FromArray([0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 1, 0, 0.5, 0.5, 0, 1]);
    return inverseProjWorldMatrix.multiply(projMatrix).multiply(screenMatrix);
  }
};

// node_modules/@babylonjs/core/Meshes/goldbergMesh.js
Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
  return GoldbergMesh.Parse(parsedMesh, scene);
};
var GoldbergMesh = class _GoldbergMesh extends Mesh {
  constructor() {
    super(...arguments);
    this.goldbergData = {
      faceColors: [],
      faceCenters: [],
      faceZaxis: [],
      faceXaxis: [],
      faceYaxis: [],
      nbSharedFaces: 0,
      nbUnsharedFaces: 0,
      nbFaces: 0,
      nbFacesAtPole: 0,
      adjacentFaces: []
    };
  }
  /**
   * Gets the related Goldberg face from pole infos
   * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in
   * @param fromPole Defines an optional pole index to find the related info from
   * @returns the goldberg face number
   */
  relatedGoldbergFace(poleOrShared, fromPole) {
    if (fromPole === void 0) {
      if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {
        Logger.Warn("Maximum number of unshared faces used");
        poleOrShared = this.goldbergData.nbUnsharedFaces - 1;
      }
      return this.goldbergData.nbUnsharedFaces + poleOrShared;
    }
    if (poleOrShared > 11) {
      Logger.Warn("Last pole used");
      poleOrShared = 11;
    }
    if (fromPole > this.goldbergData.nbFacesAtPole - 1) {
      Logger.Warn("Maximum number of faces at a pole used");
      fromPole = this.goldbergData.nbFacesAtPole - 1;
    }
    return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;
  }
  _changeGoldbergFaceColors(colorRange) {
    for (let i = 0; i < colorRange.length; i++) {
      const min = colorRange[i][0];
      const max = colorRange[i][1];
      const col = colorRange[i][2];
      for (let f = min; f < max + 1; f++) {
        this.goldbergData.faceColors[f] = col;
      }
    }
    const newCols = [];
    for (let f = 0; f < 12; f++) {
      for (let i = 0; i < 5; i++) {
        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
      }
    }
    for (let f = 12; f < this.goldbergData.faceColors.length; f++) {
      for (let i = 0; i < 6; i++) {
        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
      }
    }
    return newCols;
  }
  /**
   * Set new goldberg face colors
   * @param colorRange the new color to apply to the mesh
   */
  setGoldbergFaceColors(colorRange) {
    const newCols = this._changeGoldbergFaceColors(colorRange);
    this.setVerticesData(VertexBuffer.ColorKind, newCols);
  }
  /**
   * Updates new goldberg face colors
   * @param colorRange the new color to apply to the mesh
   */
  updateGoldbergFaceColors(colorRange) {
    const newCols = this._changeGoldbergFaceColors(colorRange);
    this.updateVerticesData(VertexBuffer.ColorKind, newCols);
  }
  _changeGoldbergFaceUVs(uvRange) {
    const uvs = this.getVerticesData(VertexBuffer.UVKind);
    for (let i = 0; i < uvRange.length; i++) {
      const min = uvRange[i][0];
      const max = uvRange[i][1];
      const center = uvRange[i][2];
      const radius = uvRange[i][3];
      const angle = uvRange[i][4];
      const points5 = [];
      const points6 = [];
      let u;
      let v;
      for (let p = 0; p < 5; p++) {
        u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);
        v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);
        if (u < 0) {
          u = 0;
        }
        if (u > 1) {
          u = 1;
        }
        points5.push(u, v);
      }
      for (let p = 0; p < 6; p++) {
        u = center.x + radius * Math.cos(angle + p * Math.PI / 3);
        v = center.y + radius * Math.sin(angle + p * Math.PI / 3);
        if (u < 0) {
          u = 0;
        }
        if (u > 1) {
          u = 1;
        }
        points6.push(u, v);
      }
      for (let f = min; f < Math.min(12, max + 1); f++) {
        for (let p = 0; p < 5; p++) {
          uvs[10 * f + 2 * p] = points5[2 * p];
          uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];
        }
      }
      for (let f = Math.max(12, min); f < max + 1; f++) {
        for (let p = 0; p < 6; p++) {
          uvs[12 * f - 24 + 2 * p] = points6[2 * p];
          uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];
        }
      }
    }
    return uvs;
  }
  /**
   * set new goldberg face UVs
   * @param uvRange the new UVs to apply to the mesh
   */
  setGoldbergFaceUVs(uvRange) {
    const newUVs = this._changeGoldbergFaceUVs(uvRange);
    this.setVerticesData(VertexBuffer.UVKind, newUVs);
  }
  /**
   * Updates new goldberg face UVs
   * @param uvRange the new UVs to apply to the mesh
   */
  updateGoldbergFaceUVs(uvRange) {
    const newUVs = this._changeGoldbergFaceUVs(uvRange);
    this.updateVerticesData(VertexBuffer.UVKind, newUVs);
  }
  /**
   * Places a mesh on a particular face of the goldberg polygon
   * @param mesh Defines the mesh to position
   * @param face Defines the face to position onto
   * @param position Defines the position relative to the face we are positioning the mesh onto
   */
  placeOnGoldbergFaceAt(mesh, face, position) {
    const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);
    mesh.rotation = orientation;
    mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));
  }
  /**
   * Serialize current mesh
   * @param serializationObject defines the object which will receive the serialization data
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = "GoldbergMesh";
    const goldbergData = {};
    goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;
    goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;
    goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;
    goldbergData.nbFaces = this.goldbergData.nbFaces;
    goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;
    if (this.goldbergData.faceColors) {
      goldbergData.faceColors = [];
      for (const color of this.goldbergData.faceColors) {
        goldbergData.faceColors.push(color.asArray());
      }
    }
    if (this.goldbergData.faceCenters) {
      goldbergData.faceCenters = [];
      for (const vector of this.goldbergData.faceCenters) {
        goldbergData.faceCenters.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceZaxis) {
      goldbergData.faceZaxis = [];
      for (const vector of this.goldbergData.faceZaxis) {
        goldbergData.faceZaxis.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceYaxis) {
      goldbergData.faceYaxis = [];
      for (const vector of this.goldbergData.faceYaxis) {
        goldbergData.faceYaxis.push(vector.asArray());
      }
    }
    if (this.goldbergData.faceXaxis) {
      goldbergData.faceXaxis = [];
      for (const vector of this.goldbergData.faceXaxis) {
        goldbergData.faceXaxis.push(vector.asArray());
      }
    }
    serializationObject.goldbergData = goldbergData;
  }
  /**
   * Parses a serialized goldberg mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the goldberg mesh in
   * @returns the created goldberg mesh
   */
  static Parse(parsedMesh, scene) {
    const goldbergData = parsedMesh.goldbergData;
    goldbergData.faceColors = goldbergData.faceColors.map((el) => Color4.FromArray(el));
    goldbergData.faceCenters = goldbergData.faceCenters.map((el) => Vector3.FromArray(el));
    goldbergData.faceZaxis = goldbergData.faceZaxis.map((el) => Vector3.FromArray(el));
    goldbergData.faceXaxis = goldbergData.faceXaxis.map((el) => Vector3.FromArray(el));
    goldbergData.faceYaxis = goldbergData.faceYaxis.map((el) => Vector3.FromArray(el));
    const goldberg = new _GoldbergMesh(parsedMesh.name, scene);
    goldberg.goldbergData = goldbergData;
    return goldberg;
  }
};

// node_modules/@babylonjs/core/Meshes/trailMesh.js
Mesh._TrailMeshParser = (parsedMesh, scene) => {
  return TrailMesh.Parse(parsedMesh, scene);
};
var TrailMesh = class _TrailMesh extends Mesh {
  /**
   * Creates a new TrailMesh.
   * @param name The value used by scene.getMeshByName() to do a lookup.
   * @param generator The mesh or transform node to generate a trail.
   * @param scene The scene to add this mesh to.
   * @param diameter Diameter of trailing mesh. Default is 1.
   * @param length Length of trailing mesh. Default is 60.
   * @param autoStart Automatically start trailing mesh. Default true.
   */
  constructor(name52, generator, scene, diameter = 1, length = 60, autoStart = true) {
    super(name52, scene);
    this._sectionPolygonPointsCount = 4;
    this._running = false;
    this._autoStart = autoStart;
    this._generator = generator;
    this.diameter = diameter;
    this._length = length;
    this._sectionVectors = [];
    this._sectionNormalVectors = [];
    for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
      this._sectionVectors[i] = Vector3.Zero();
      this._sectionNormalVectors[i] = Vector3.Zero();
    }
    this._createMesh();
  }
  /**
   * "TrailMesh"
   * @returns "TrailMesh"
   */
  getClassName() {
    return "TrailMesh";
  }
  _createMesh() {
    const data = new VertexData();
    const positions = [];
    const normals = [];
    const indices = [];
    let meshCenter = Vector3.Zero();
    if (this._generator instanceof AbstractMesh && this._generator.hasBoundingInfo) {
      meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;
    } else {
      meshCenter = this._generator.position;
    }
    const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
    for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
      positions.push(meshCenter.x + Math.cos(i * alpha) * this.diameter, meshCenter.y + Math.sin(i * alpha) * this.diameter, meshCenter.z);
    }
    for (let i = 1; i <= this._length; i++) {
      for (let j = 0; j < this._sectionPolygonPointsCount; j++) {
        positions.push(meshCenter.x + Math.cos(j * alpha) * this.diameter, meshCenter.y + Math.sin(j * alpha) * this.diameter, meshCenter.z);
      }
      const l = positions.length / 3 - 2 * this._sectionPolygonPointsCount;
      for (let j = 0; j < this._sectionPolygonPointsCount - 1; j++) {
        indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);
        indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);
      }
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);
      indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);
    }
    VertexData.ComputeNormals(positions, indices, normals);
    data.positions = positions;
    data.normals = normals;
    data.indices = indices;
    data.applyToMesh(this, true);
    if (this._autoStart) {
      this.start();
    }
  }
  /**
   * Start trailing mesh.
   */
  start() {
    if (!this._running) {
      this._running = true;
      this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(() => {
        this.update();
      });
    }
  }
  /**
   * Stop trailing mesh.
   */
  stop() {
    if (this._beforeRenderObserver && this._running) {
      this._running = false;
      this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  }
  /**
   * Update trailing mesh geometry.
   */
  update() {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const wm = this._generator.getWorldMatrix();
    if (positions && normals) {
      for (let i = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {
        positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - normals[i] / this._length * this.diameter;
      }
      for (let i = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {
        normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];
      }
      const l = positions.length - 3 * this._sectionPolygonPointsCount;
      const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
      for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
        this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this.diameter, Math.sin(i * alpha) * this.diameter, 0);
        this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);
        Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);
        Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);
      }
      for (let i = 0; i < this._sectionPolygonPointsCount; i++) {
        positions[l + 3 * i] = this._sectionVectors[i].x;
        positions[l + 3 * i + 1] = this._sectionVectors[i].y;
        positions[l + 3 * i + 2] = this._sectionVectors[i].z;
        normals[l + 3 * i] = this._sectionNormalVectors[i].x;
        normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;
        normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;
      }
      this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);
    }
  }
  /**
   * Returns a new TrailMesh object.
   * @param name is a string, the name given to the new mesh
   * @param newGenerator use new generator object for cloned trail mesh
   * @returns a new mesh
   */
  clone(name52 = "", newGenerator) {
    return new _TrailMesh(name52, newGenerator === void 0 ? this._generator : newGenerator, this.getScene(), this.diameter, this._length, this._autoStart);
  }
  /**
   * Serializes this trail mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.generatorId = this._generator.id;
  }
  /**
   * Parses a serialized trail mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the trail mesh in
   * @returns the created trail mesh
   */
  static Parse(parsedMesh, scene) {
    var _a, _b;
    const generator = (_a = scene.getLastMeshById(parsedMesh.generatorId)) !== null && _a !== void 0 ? _a : scene.getLastTransformNodeById(parsedMesh.generatorId);
    if (!generator) {
      throw new Error("TrailMesh: generator not found with ID " + parsedMesh.generatorId);
    }
    return new _TrailMesh(parsedMesh.name, generator, scene, (_b = parsedMesh.diameter) !== null && _b !== void 0 ? _b : parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);
  }
};

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
Mesh._instancedMeshFactory = (name52, mesh) => {
  const instance = new InstancedMesh(name52, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (const key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = class extends AbstractMesh {
  /**
   * Creates a new InstancedMesh object from the mesh source.
   * @param name defines the name of the instance
   * @param source the mesh to create the instance from
   */
  constructor(name52, source) {
    super(name52, source.getScene());
    this._indexInSourceMeshInstanceArray = -1;
    this._distanceToCamera = 0;
    source.addInstance(this);
    this._sourceMesh = source;
    this._unIndexed = source._unIndexed;
    this.position.copyFrom(source.position);
    this.rotation.copyFrom(source.rotation);
    this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    this.animations = source.animations.slice();
    for (const range of source.getAnimationRanges()) {
      if (range != null) {
        this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    this.infiniteDistance = source.infiniteDistance;
    this.setPivotMatrix(source.getPivotMatrix());
    this.refreshBoundingInfo(true, true);
    this._syncSubMeshes();
  }
  /**
   * Returns the string "InstancedMesh".
   */
  getClassName() {
    return "InstancedMesh";
  }
  /** Gets the list of lights affecting that mesh */
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  // Methods
  /**
   * If the source mesh receives shadows
   */
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  set receiveShadows(_value) {
    var _a;
    if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.receiveShadows) !== _value) {
      Tools.Warn("Setting receiveShadows on an instanced mesh has no effect");
    }
  }
  /**
   * The material of the source mesh
   */
  get material() {
    return this._sourceMesh.material;
  }
  set material(_value) {
    var _a;
    if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.material) !== _value) {
      Tools.Warn("Setting material on an instanced mesh has no effect");
    }
  }
  /**
   * Visibility of the source mesh
   */
  get visibility() {
    return this._sourceMesh.visibility;
  }
  set visibility(_value) {
    var _a;
    if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.visibility) !== _value) {
      Tools.Warn("Setting visibility on an instanced mesh has no effect");
    }
  }
  /**
   * Skeleton of the source mesh
   */
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  set skeleton(_value) {
    var _a;
    if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.skeleton) !== _value) {
      Tools.Warn("Setting skeleton on an instanced mesh has no effect");
    }
  }
  /**
   * Rendering ground id of the source mesh
   */
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(value) {
    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
      return;
    }
    Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  /**
   * Returns the total number of vertices (integer).
   */
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  /**
   * Returns a positive integer : the total number of indices in this mesh geometry.
   * @returns the number of indices or zero if the mesh has no geometry.
   */
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  /**
   * The source mesh of the instance
   */
  get sourceMesh() {
    return this._sourceMesh;
  }
  /**
   * Creates a new InstancedMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedMesh
   */
  createInstance(name52) {
    return this._sourceMesh.createInstance(name52);
  }
  /**
   * Is this node ready to be used/rendered
   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
   * @returns {boolean} is it ready
   */
  isReady(completeCheck = false) {
    return this._sourceMesh.isReady(completeCheck, true);
  }
  /**
   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)
   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.
   */
  getVerticesData(kind, copyWhenShared, forceCopy) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
  }
  /**
   * Sets the vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
   * The `data` are either a numeric array either a Float32Array.
   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.
   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
   * Note that a new underlying VertexBuffer object is created each call.
   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind
   * @param data
   * @param updatable
   * @param stride
   */
  setVerticesData(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  }
  /**
   * Updates the existing vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, it is simply returned as it is.
   * The `data` are either a numeric array either a Float32Array.
   * No new underlying VertexBuffer object is created.
   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind
   * @param data
   * @param updateExtends
   * @param makeItUnique
   */
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  }
  /**
   * Sets the mesh indices.
   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
   * This method creates a new index buffer each call.
   * Returns the Mesh.
   * @param indices
   * @param totalVertices
   */
  setIndices(indices, totalVertices = null) {
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  }
  /**
   * Boolean : True if the mesh owns the requested kind of data.
   * @param kind
   */
  isVerticesDataPresent(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  }
  /**
   * Returns an array of indices (IndicesArray).
   */
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  /**
   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
   * This means the mesh underlying bounding box and sphere are recomputed.
   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
   * @param applyMorph  defines whether to apply the morph target before computing the bounding info
   * @returns the current mesh
   */
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  }
  /** @internal */
  _preActivate() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  }
  /**
   * @internal
   */
  _activate(renderId, intermediateRendering) {
    super._activate(renderId, intermediateRendering);
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  }
  /** @internal */
  _postActivate() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      if (!this._billboardWorldMatrix) {
        this._billboardWorldMatrix = new Matrix();
      }
      const tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return true;
  }
  /**
   * Returns the current associated LOD AbstractMesh.
   * @param camera
   */
  getLOD(camera) {
    if (!camera) {
      return this;
    }
    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
      this._currentLOD = this.sourceMesh;
    } else {
      const boundingInfo = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    }
    return this._currentLOD;
  }
  /**
   * @internal
   */
  _preActivateForIntermediateRendering(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  }
  /** @internal */
  _syncSubMeshes() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  }
  /** @internal */
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  /** @internal */
  _updateBoundingInfo() {
    if (this.hasBoundingInfo) {
      this.getBoundingInfo().update(this.worldMatrixFromCache);
    } else {
      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  /**
   * Creates a new InstancedMesh from the current mesh.
   *
   * Returns the clone.
   * @param name the cloned mesh name
   * @param newParent the optional Node to parent the clone to.
   * @param doNotCloneChildren if `true` the model children aren't cloned.
   * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one
   * @returns the clone
   */
  clone(name52, newParent = null, doNotCloneChildren, newSourceMesh) {
    const result = (newSourceMesh || this._sourceMesh).createInstance(name52);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (let index = 0; index < this.getScene().meshes.length; index++) {
        const mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    this.onClonedObservable.notifyObservers(result);
    return result;
  }
  /**
   * Disposes the InstancedMesh.
   * Returns nothing.
   * @param doNotRecurse
   * @param disposeMaterialAndTextures
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._sourceMesh.removeInstance(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * @internal
   */
  _serializeAsParent(serializationObject) {
    super._serializeAsParent(serializationObject);
    serializationObject.parentId = this._sourceMesh.uniqueId;
    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  /**
   * Instantiate (when possible) or clone that node with its hierarchy
   * @param newParent defines the new parent to use for the instance (or clone)
   * @param options defines options to configure how copy is done
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)
   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
   * @returns an instance (or a clone) of the current node with its hierarchy
   */
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
};
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  var _a, _b;
  (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const instance of this.instances) {
      instance.instancedBuffers = {};
    }
  }
  if (!this._userInstancedBuffersStorage) {
    this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    };
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  for (const instance of this.instances) {
    instance.instancedBuffers[kind] = null;
  }
  this._invalidateInstanceVertexArrayObject();
  this._markSubMeshesAsAttributesDirty();
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  const instanceCount = visibleInstances ? visibleInstances.length : 0;
  for (const kind in this.instancedBuffers) {
    let size = this._userInstancedBuffersStorage.sizes[kind];
    const stride = this._userInstancedBuffersStorage.strides[kind];
    const expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    const data = this._userInstancedBuffersStorage.data[kind];
    let offset = 0;
    if (renderSelf) {
      const value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      const instance = visibleInstances[instanceIndex];
      const value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this._invalidateInstanceVertexArrayObject();
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
    return;
  }
  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
  }
  this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (const kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this._invalidateInstanceVertexArrayObject();
  this.instancedBuffers = {};
};

// node_modules/@babylonjs/core/Shaders/color.fragment.js
var name7 = "colorPixelShader";
var shader7 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vec4 vColor;
#else
uniform vec4 color;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
gl_FragColor=vColor;
#else
gl_FragColor=color;
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/color.vertex.js
var name8 = "colorVertexShader";
var shader8 = `attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#include<clipPlaneVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Meshes/linesMesh.js
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  return LinesMesh.Parse(parsedMesh, scene);
};
var LinesMesh = class _LinesMesh extends Mesh {
  _isShaderMaterial(shader52) {
    return shader52.getClassName() === "ShaderMaterial";
  }
  /**
   * Creates a new LinesMesh
   * @param name defines the name
   * @param scene defines the hosting scene
   * @param parent defines the parent mesh if any
   * @param source defines the optional source LinesMesh used to clone data from
   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
   * When false, achieved by calling a clone(), also passing False.
   * This will make creation of children, recursive.
   * @param useVertexColor defines if this LinesMesh supports vertex color
   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
   * @param material material to use to draw the line. If not provided, will create a new one
   */
  constructor(name52, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
    super(name52, scene, parent, source, doNotCloneChildren);
    this.useVertexColor = useVertexColor;
    this.useVertexAlpha = useVertexAlpha;
    this.color = new Color3(1, 1, 1);
    this.alpha = 1;
    if (source) {
      this.color = source.color.clone();
      this.alpha = source.alpha;
      this.useVertexColor = source.useVertexColor;
      this.useVertexAlpha = source.useVertexAlpha;
    }
    this.intersectionThreshold = 0.1;
    const defines = [];
    const options = {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection"],
      needAlphaBlending: true,
      defines,
      useClipPlane: null
    };
    if (useVertexAlpha === false) {
      options.needAlphaBlending = false;
    } else {
      options.defines.push("#define VERTEXALPHA");
    }
    if (!useVertexColor) {
      options.uniforms.push("color");
      this._color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    if (material) {
      this.material = material;
    } else {
      this.material = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
      this.material.doNotSerialize = true;
    }
  }
  isReady() {
    if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {
      return false;
    }
    return super.isReady();
  }
  /**
   * Returns the string "LineMesh"
   */
  getClassName() {
    return "LinesMesh";
  }
  /**
   * @internal
   */
  get material() {
    return this._lineMaterial;
  }
  /**
   * @internal
   */
  set material(value) {
    this._lineMaterial = value;
    this._lineMaterial.fillMode = Material.LineListDrawMode;
  }
  /**
   * @internal
   */
  get checkCollisions() {
    return false;
  }
  set checkCollisions(value) {
  }
  /**
   * @internal
   */
  _bind(_subMesh, colorEffect) {
    if (!this._geometry) {
      return this;
    }
    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(colorEffect, indexToBind);
    } else {
      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {
      const { r, g, b } = this.color;
      this._color4.set(r, g, b, this.alpha);
      this._lineMaterial.setColor4("color", this._color4);
    }
    return this;
  }
  /**
   * @internal
   */
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  }
  /**
   * Disposes of the line mesh
   * @param doNotRecurse If children should be disposed
   * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class
   * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
    if (!doNotDisposeMaterial) {
      this._lineMaterial.dispose(false, false, true);
    }
    super.dispose(doNotRecurse);
  }
  /**
   * Returns a new LineMesh object cloned from the current one.
   * @param name
   * @param newParent
   * @param doNotCloneChildren
   */
  clone(name52, newParent = null, doNotCloneChildren) {
    return new _LinesMesh(name52, this.getScene(), newParent, this, doNotCloneChildren);
  }
  /**
   * Creates a new InstancedLinesMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedLinesMesh
   */
  createInstance(name52) {
    const instance = new InstancedLinesMesh(name52, this);
    if (this.instancedBuffers) {
      instance.instancedBuffers = {};
      for (const key in this.instancedBuffers) {
        instance.instancedBuffers[key] = this.instancedBuffers[key];
      }
    }
    return instance;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.color = this.color.asArray();
    serializationObject.alpha = this.alpha;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _LinesMesh(parsedMesh.name, scene);
    result.color = Color3.FromArray(parsedMesh.color);
    result.alpha = parsedMesh.alpha;
    return result;
  }
};
var InstancedLinesMesh = class extends InstancedMesh {
  constructor(name52, source) {
    super(name52, source);
    this.intersectionThreshold = source.intersectionThreshold;
  }
  /**
   * Returns the string "InstancedLinesMesh".
   */
  getClassName() {
    return "InstancedLinesMesh";
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js
function CreateRibbonVertexData(options) {
  let pathArray = options.pathArray;
  const closeArray = options.closeArray || false;
  const closePath = options.closePath || false;
  const invertUV = options.invertUV || false;
  const defaultOffset = Math.floor(pathArray[0].length / 2);
  let offset = options.offset || defaultOffset;
  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const customUV = options.uvs;
  const customColors = options.colors;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const us = [];
  const vs = [];
  const uTotalDistance = [];
  const vTotalDistance = [];
  let minlg;
  const lg = [];
  const idx = [];
  let p;
  let i;
  let j;
  if (pathArray.length < 2) {
    const ar1 = [];
    const ar2 = [];
    for (i = 0; i < pathArray[0].length - offset; i++) {
      ar1.push(pathArray[0][i]);
      ar2.push(pathArray[0][i + offset]);
    }
    pathArray = [ar1, ar2];
  }
  let idc = 0;
  const closePathCorr = closePath ? 1 : 0;
  let path;
  let l;
  minlg = pathArray[0].length;
  let vectlg;
  let dist;
  for (p = 0; p < pathArray.length; p++) {
    uTotalDistance[p] = 0;
    us[p] = [0];
    path = pathArray[p];
    l = path.length;
    minlg = minlg < l ? minlg : l;
    j = 0;
    while (j < l) {
      positions.push(path[j].x, path[j].y, path[j].z);
      if (j > 0) {
        vectlg = path[j].subtract(path[j - 1]).length();
        dist = vectlg + uTotalDistance[p];
        us[p].push(dist);
        uTotalDistance[p] = dist;
      }
      j++;
    }
    if (closePath) {
      j--;
      positions.push(path[0].x, path[0].y, path[0].z);
      vectlg = path[j].subtract(path[0]).length();
      dist = vectlg + uTotalDistance[p];
      us[p].push(dist);
      uTotalDistance[p] = dist;
    }
    lg[p] = l + closePathCorr;
    idx[p] = idc;
    idc += l + closePathCorr;
  }
  let path1;
  let path2;
  let vertex1 = null;
  let vertex2 = null;
  for (i = 0; i < minlg + closePathCorr; i++) {
    vTotalDistance[i] = 0;
    vs[i] = [0];
    for (p = 0; p < pathArray.length - 1; p++) {
      path1 = pathArray[p];
      path2 = pathArray[p + 1];
      if (i === minlg) {
        vertex1 = path1[0];
        vertex2 = path2[0];
      } else {
        vertex1 = path1[i];
        vertex2 = path2[i];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vs[i].push(dist);
      vTotalDistance[i] = dist;
    }
    if (closeArray && vertex2 && vertex1) {
      path1 = pathArray[p];
      path2 = pathArray[0];
      if (i === minlg) {
        vertex2 = path2[0];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vTotalDistance[i] = dist;
    }
  }
  let u;
  let v;
  if (customUV) {
    for (p = 0; p < customUV.length; p++) {
      uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - customUV[p].y : customUV[p].y);
    }
  } else {
    for (p = 0; p < pathArray.length; p++) {
      for (i = 0; i < minlg + closePathCorr; i++) {
        u = uTotalDistance[p] != 0 ? us[p][i] / uTotalDistance[p] : 0;
        v = vTotalDistance[i] != 0 ? vs[i][p] / vTotalDistance[i] : 0;
        if (invertUV) {
          uvs.push(v, u);
        } else {
          uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        }
      }
    }
  }
  p = 0;
  let pi = 0;
  let l1 = lg[p] - 1;
  let l2 = lg[p + 1] - 1;
  let min = l1 < l2 ? l1 : l2;
  let shft = idx[1] - idx[0];
  const path1nb = closeArray ? lg.length : lg.length - 1;
  while (pi <= min && p < path1nb) {
    indices.push(pi, pi + shft, pi + 1);
    indices.push(pi + shft + 1, pi + 1, pi + shft);
    pi += 1;
    if (pi === min) {
      p++;
      if (p === lg.length - 1) {
        shft = idx[0] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[0] - 1;
      } else {
        shft = idx[p + 1] - idx[p];
        l1 = lg[p] - 1;
        l2 = lg[p + 1] - 1;
      }
      pi = idx[p];
      min = l1 < l2 ? l1 + pi : l2 + pi;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  if (closePath) {
    let indexFirst = 0;
    let indexLast = 0;
    for (p = 0; p < pathArray.length; p++) {
      indexFirst = idx[p] * 3;
      if (p + 1 < pathArray.length) {
        indexLast = (idx[p + 1] - 1) * 3;
      } else {
        indexLast = normals.length - 3;
      }
      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
      normals[indexLast] = normals[indexFirst];
      normals[indexLast + 1] = normals[indexFirst + 1];
      normals[indexLast + 2] = normals[indexFirst + 2];
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  let colors = null;
  if (customColors) {
    colors = new Float32Array(customColors.length * 4);
    for (let c = 0; c < customColors.length; c++) {
      colors[c * 4] = customColors[c].r;
      colors[c * 4 + 1] = customColors[c].g;
      colors[c * 4 + 2] = customColors[c].b;
      colors[c * 4 + 3] = customColors[c].a;
    }
  }
  const vertexData = new VertexData();
  const positions32 = new Float32Array(positions);
  const normals32 = new Float32Array(normals);
  const uvs32 = new Float32Array(uvs);
  vertexData.indices = indices;
  vertexData.positions = positions32;
  vertexData.normals = normals32;
  vertexData.uvs = uvs32;
  if (colors) {
    vertexData.set(colors, VertexBuffer.ColorKind);
  }
  if (closePath) {
    vertexData._idx = idx;
  }
  return vertexData;
}
function CreateRibbon(name52, options, scene = null) {
  const pathArray = options.pathArray;
  const closeArray = options.closeArray;
  const closePath = options.closePath;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const updatable = options.updatable;
  if (instance) {
    const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);
    const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);
    const positionFunction = (positions2) => {
      let minlg = pathArray[0].length;
      const mesh = instance;
      let i = 0;
      const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;
      for (let si = 1; si <= ns; ++si) {
        for (let p = 0; p < pathArray.length; ++p) {
          const path = pathArray[p];
          const l = path.length;
          minlg = minlg < l ? minlg : l;
          for (let j = 0; j < minlg; ++j) {
            const pathPoint = path[j];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            i += 3;
          }
          if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {
            const pathPoint = path[0];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            i += 3;
          }
        }
      }
    };
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    positionFunction(positions);
    if (instance.hasBoundingInfo) {
      instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);
    } else {
      instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (options.colors) {
      const colors = instance.getVerticesData(VertexBuffer.ColorKind);
      for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {
        const color = options.colors[c];
        colors[colorIndex] = color.r;
        colors[colorIndex + 1] = color.g;
        colors[colorIndex + 2] = color.b;
        colors[colorIndex + 3] = color.a;
      }
      instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
    }
    if (options.uvs) {
      const uvs = instance.getVerticesData(VertexBuffer.UVKind);
      for (let i = 0; i < options.uvs.length; i++) {
        uvs[i * 2] = options.uvs[i].x;
        uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - options.uvs[i].y : options.uvs[i].y;
      }
      instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
    }
    if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {
      const indices = instance.getIndices();
      const normals = instance.getVerticesData(VertexBuffer.NormalKind);
      const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;
      VertexData.ComputeNormals(positions, indices, normals, params);
      if (instance._creationDataStorage && instance._creationDataStorage.closePath) {
        let indexFirst = 0;
        let indexLast = 0;
        for (let p = 0; p < pathArray.length; p++) {
          indexFirst = instance._creationDataStorage.idx[p] * 3;
          if (p + 1 < pathArray.length) {
            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;
          } else {
            indexLast = normals.length - 3;
          }
          normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
          normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
          normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
          normals[indexLast] = normals[indexFirst];
          normals[indexLast + 1] = normals[indexFirst + 1];
          normals[indexLast + 2] = normals[indexFirst + 2];
        }
      }
      if (!instance.areNormalsFrozen) {
        instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
      }
    }
    return instance;
  } else {
    const ribbon = new Mesh(name52, scene);
    ribbon._originalBuilderSideOrientation = sideOrientation;
    ribbon._creationDataStorage = new _CreationDataStorage();
    const vertexData = CreateRibbonVertexData(options);
    if (closePath) {
      ribbon._creationDataStorage.idx = vertexData._idx;
    }
    ribbon._creationDataStorage.closePath = closePath;
    ribbon._creationDataStorage.closeArray = closeArray;
    vertexData.applyToMesh(ribbon, updatable);
    return ribbon;
  }
}
var RibbonBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateRibbon
};
VertexData.CreateRibbon = CreateRibbonVertexData;
Mesh.CreateRibbon = (name52, pathArray, closeArray = false, closePath, offset, scene, updatable = false, sideOrientation, instance) => {
  return CreateRibbon(name52, {
    pathArray,
    closeArray,
    closePath,
    offset,
    updatable,
    sideOrientation,
    instance
  }, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js
function CreateDiscVertexData(options) {
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const radius = options.radius || 0.5;
  const tessellation = options.tessellation || 64;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  positions.push(0, 0, 0);
  uvs.push(0.5, 0.5);
  const theta = Math.PI * 2 * arc;
  const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);
  let a = 0;
  for (let t = 0; t < tessellation; t++) {
    const x = Math.cos(a);
    const y = Math.sin(a);
    const u = (x + 1) / 2;
    const v = (1 - y) / 2;
    positions.push(radius * x, radius * y, 0);
    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
    a += step;
  }
  if (arc === 1) {
    positions.push(positions[3], positions[4], positions[5]);
    uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);
  }
  const vertexNb = positions.length / 3;
  for (let i = 1; i < vertexNb - 1; i++) {
    indices.push(i + 1, 0, i);
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateDisc(name52, options = {}, scene = null) {
  const disc = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  disc._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateDiscVertexData(options);
  vertexData.applyToMesh(disc, options.updatable);
  return disc;
}
var DiscBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateDisc
};
VertexData.CreateDisc = CreateDiscVertexData;
Mesh.CreateDisc = (name52, radius, tessellation, scene = null, updatable, sideOrientation) => {
  const options = {
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateDisc(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateSegmentedBoxVertexData(options) {
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const widthSegments = (options.widthSegments || options.segments || 1) | 0;
  const heightSegments = (options.heightSegments || options.segments || 1) | 0;
  const depthSegments = (options.depthSegments || options.segments || 1) | 0;
  const rotationMatrix = new Matrix();
  const translationMatrix = new Matrix();
  const transformMatrix = new Matrix();
  const bottomPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  bottomPlane.transform(transformMatrix);
  const topPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);
  topPlane.transform(transformMatrix);
  const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negXPlane.transform(transformMatrix);
  const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posXPlane.transform(transformMatrix);
  const negZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);
  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negZPlane.transform(transformMatrix);
  const posZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);
  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posZPlane.transform(transformMatrix);
  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);
  return bottomPlane;
}
function CreateBox(name52, options = {}, scene = null) {
  const box = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var BoxBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateBox
};
VertexData.CreateBox = CreateBoxVertexData;
Mesh.CreateBox = (name52, size, scene = null, updatable, sideOrientation) => {
  const options = {
    size,
    sideOrientation,
    updatable
  };
  return CreateBox(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js
function CreateTiledPlaneVertexData(options) {
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const width = options.width || options.size || 1;
  const tilesX = Math.floor(width / tileWidth);
  let offsetX = width - tilesX * tileWidth;
  const height = options.height || options.size || 1;
  const tilesY = Math.floor(height / tileHeight);
  let offsetY = height - tilesY * tileHeight;
  const halfWidth = tileWidth * tilesX / 2;
  const halfHeight = tileHeight * tilesY / 2;
  let adjustX = 0;
  let adjustY = 0;
  let startX = 0;
  let startY = 0;
  let endX = 0;
  let endY = 0;
  if (offsetX > 0 || offsetY > 0) {
    startX = -halfWidth;
    startY = -halfHeight;
    endX = halfWidth;
    endY = halfHeight;
    switch (alignH) {
      case Mesh.CENTER:
        offsetX /= 2;
        startX -= offsetX;
        endX += offsetX;
        break;
      case Mesh.LEFT:
        endX += offsetX;
        adjustX = -offsetX / 2;
        break;
      case Mesh.RIGHT:
        startX -= offsetX;
        adjustX = offsetX / 2;
        break;
    }
    switch (alignV) {
      case Mesh.CENTER:
        offsetY /= 2;
        startY -= offsetY;
        endY += offsetY;
        break;
      case Mesh.BOTTOM:
        endY += offsetY;
        adjustY = -offsetY / 2;
        break;
      case Mesh.TOP:
        startY -= offsetY;
        adjustY = offsetY / 2;
        break;
    }
  }
  const positions = [];
  const normals = [];
  const uvBase = [];
  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];
  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];
  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];
  }
  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];
  }
  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];
  }
  let uvs = [];
  const colors = [];
  const indices = [];
  let index = 0;
  for (let y = 0; y < tilesY; y++) {
    for (let x = 0; x < tilesX; x++) {
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);
      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvs = uvs.concat(uvBase[y % 2]);
      } else {
        uvs = uvs.concat(uvBase[0]);
      }
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      index += 4;
    }
  }
  if (offsetX > 0 || offsetY > 0) {
    const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);
    const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);
    const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);
    const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);
    let uvPart = [];
    let a, b, c, d;
    if (partialBottomRow && partialLeftCol) {
      positions.push(startX + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);
      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow && partialRightCol) {
      positions.push(halfWidth + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);
      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = offsetX / tileWidth;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialLeftCol) {
      positions.push(startX + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, endY + adjustY, 0);
      positions.push(startX + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialRightCol) {
      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, endY + adjustY, 0);
      positions.push(halfWidth + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 0;
      c = offsetX / tileWidth;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow) {
      const uvBaseBR = [];
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvBaseBR[0] = [a, b, c, b, c, d, a, d];
      uvBaseBR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseBR[1]);
        } else {
          uvs = uvs.concat(uvBaseBR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialTopRow) {
      const uvBaseTR = [];
      a = 0;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvBaseTR[0] = [a, b, c, b, c, d, a, d];
      uvBaseTR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseTR[tilesY % 2]);
        } else {
          uvs = uvs.concat(uvBaseTR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialLeftCol) {
      const uvBaseLC = [];
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = 1;
      uvBaseLC[0] = [a, b, c, b, c, d, a, d];
      uvBaseLC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseLC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseLC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialRightCol) {
      const uvBaseRC = [];
      a = 0;
      b = 0;
      c = offsetX / tileHeight;
      d = 1;
      uvBaseRC[0] = [a, b, c, b, c, d, a, d];
      uvBaseRC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseRC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseRC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
  }
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
  vertexData.colors = totalColors;
  return vertexData;
}
function CreateTiledPlane(name52, options, scene = null) {
  const plane = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledPlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  return plane;
}
var TiledPlaneBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateTiledPlane
};
VertexData.CreateTiledPlane = CreateTiledPlaneVertexData;

// node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js
function CreateTiledBoxVertexData(options) {
  const nbFaces = 6;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  for (let f = 0; f < nbFaces; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const halfDepth = depth / 2;
  const faceVertexData = [];
  for (let f = 0; f < 2; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  for (let f = 2; f < 4; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width: depth,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  let baseAlignV = alignV;
  if (alignV === Mesh.BOTTOM) {
    baseAlignV = Mesh.TOP;
  } else if (alignV === Mesh.TOP) {
    baseAlignV = Mesh.BOTTOM;
  }
  for (let f = 4; f < 6; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height: depth,
      alignVertical: baseAlignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  let positions = [];
  let normals = [];
  let uvs = [];
  let indices = [];
  const colors = [];
  const facePositions = [];
  const faceNormals = [];
  const newFaceUV = [];
  let lu = 0;
  let li = 0;
  for (let f = 0; f < nbFaces; f++) {
    const len = faceVertexData[f].positions.length;
    facePositions[f] = [];
    faceNormals[f] = [];
    for (let p = 0; p < len / 3; p++) {
      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));
      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));
    }
    lu = faceVertexData[f].uvs.length;
    newFaceUV[f] = [];
    for (let i = 0; i < lu; i += 2) {
      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];
      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];
      if (CompatibilityOptions.UseOpenGLOrientationForUV) {
        newFaceUV[f][i + 1] = 1 - newFaceUV[f][i + 1];
      }
    }
    uvs = uvs.concat(newFaceUV[f]);
    indices = indices.concat(faceVertexData[f].indices.map((x) => x + li));
    li += facePositions[f].length;
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
      }
    }
  }
  const vec0 = new Vector3(0, 0, halfDepth);
  const mtrx0 = Matrix.RotationY(Math.PI);
  positions = facePositions[0].map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
  normals = faceNormals[0].map((entry) => Vector3.TransformNormal(entry, mtrx0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
  positions = positions.concat(facePositions[1].map((entry) => entry.subtract(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const vec2 = new Vector3(halfWidth, 0, 0);
  const mtrx2 = Matrix.RotationY(-Math.PI / 2);
  positions = positions.concat(facePositions[2].map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[2].map((entry) => Vector3.TransformNormal(entry, mtrx2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const mtrx3 = Matrix.RotationY(Math.PI / 2);
  positions = positions.concat(facePositions[3].map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[3].map((entry) => Vector3.TransformNormal(entry, mtrx3)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const vec4 = new Vector3(0, halfHeight, 0);
  const mtrx4 = Matrix.RotationX(Math.PI / 2);
  positions = positions.concat(facePositions[4].map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[4].map((entry) => Vector3.TransformNormal(entry, mtrx4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  const mtrx5 = Matrix.RotationX(-Math.PI / 2);
  positions = positions.concat(facePositions[5].map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  normals = normals.concat(faceNormals[5].map((entry) => Vector3.TransformNormal(entry, mtrx5)).map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateTiledBox(name52, options, scene = null) {
  const box = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var TiledBoxBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateTiledBox
};
VertexData.CreateTiledBox = CreateTiledBoxVertexData;

// node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js
function CreateSphereVertexData(options) {
  const segments = (options.segments || 32) | 0;
  const diameterX = options.diameterX || options.diameter || 1;
  const diameterY = options.diameterY || options.diameter || 1;
  const diameterZ = options.diameterZ || options.diameter || 1;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const slice = options.slice && options.slice <= 0 ? 1 : options.slice || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;
  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
  const totalZRotationSteps = 2 + segments;
  const totalYRotationSteps = 2 * totalZRotationSteps;
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    const normalizedZ = zRotationStep / totalZRotationSteps;
    const angleZ = normalizedZ * Math.PI * slice;
    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      const normalizedY = yRotationStep / totalYRotationSteps;
      const angleY = normalizedY * Math.PI * 2 * arc;
      const rotationZ = Matrix.RotationZ(-angleZ);
      const rotationY = Matrix.RotationY(angleY);
      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
      const vertex = complete.multiply(radius);
      const normal = complete.divide(radius).normalize();
      positions.push(vertex.x, vertex.y, vertex.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - normalizedZ : normalizedZ);
    }
    if (zRotationStep > 0) {
      const verticesCount = positions.length / 3;
      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        if (dedupTopBottomIndices) {
          if (zRotationStep > 1) {
            indices.push(firstIndex);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 1);
          }
          if (zRotationStep < totalZRotationSteps || slice < 1) {
            indices.push(firstIndex + totalYRotationSteps + 1);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 2);
          }
        } else {
          indices.push(firstIndex);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 2);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateSphere(name52, options = {}, scene = null) {
  const sphere = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var SphereBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateSphere
};
VertexData.CreateSphere = CreateSphereVertexData;
Mesh.CreateSphere = (name52, segments, diameter, scene, updatable, sideOrientation) => {
  const options = {
    segments,
    diameterX: diameter,
    diameterY: diameter,
    diameterZ: diameter,
    sideOrientation,
    updatable
  };
  return CreateSphere(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js
function CreateCylinderVertexData(options) {
  const height = options.height || 2;
  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;
  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;
  diameterTop = diameterTop || 1e-5;
  diameterBottom = diameterBottom || 1e-5;
  const tessellation = (options.tessellation || 24) | 0;
  const subdivisions = (options.subdivisions || 1) | 0;
  const hasRings = options.hasRings ? true : false;
  const enclose = options.enclose ? true : false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(3);
  const faceColors = options.faceColors;
  const quadNb = arc !== 1 && enclose ? 2 : 0;
  const ringNb = hasRings ? subdivisions : 1;
  const surfaceNb = 2 + (1 + quadNb) * ringNb;
  let f;
  for (f = 0; f < surfaceNb; f++) {
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (f = 0; f < surfaceNb; f++) {
    if (faceUV && faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
  }
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const colors = [];
  const angleStep = Math.PI * 2 * arc / tessellation;
  let angle;
  let h;
  let radius;
  const tan = (diameterBottom - diameterTop) / 2 / height;
  const ringVertex = Vector3.Zero();
  const ringNormal = Vector3.Zero();
  const ringFirstVertex = Vector3.Zero();
  const ringFirstNormal = Vector3.Zero();
  const quadNormal = Vector3.Zero();
  const Y = Axis.Y;
  let i;
  let j;
  let r;
  let ringIdx = 1;
  let s = 1;
  let cs = 0;
  let v = 0;
  for (i = 0; i <= subdivisions; i++) {
    h = i / subdivisions;
    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;
    for (r = 0; r < ringIdx; r++) {
      if (hasRings) {
        s += r;
      }
      if (enclose) {
        s += 2 * r;
      }
      for (j = 0; j <= tessellation; j++) {
        angle = j * angleStep;
        ringVertex.x = Math.cos(-angle) * radius;
        ringVertex.y = -height / 2 + h * height;
        ringVertex.z = Math.sin(-angle) * radius;
        if (diameterTop === 0 && i === subdivisions) {
          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
        } else {
          ringNormal.x = ringVertex.x;
          ringNormal.z = ringVertex.z;
          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
          ringNormal.normalize();
        }
        if (j === 0) {
          ringFirstVertex.copyFrom(ringVertex);
          ringFirstNormal.copyFrom(ringNormal);
        }
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s].y : faceUV[s].w;
        } else {
          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
        }
        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
        }
      }
      if (arc !== 1 && enclose) {
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        positions.push(0, ringVertex.y, 0);
        positions.push(0, ringVertex.y, 0);
        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
        Vector3.CrossToRef(Y, ringNormal, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;
        } else {
          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
        }
        uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;
        } else {
          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
        }
        uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
        }
      }
      if (cs !== s) {
        cs = s;
      }
    }
  }
  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation;
  i = 0;
  for (s = 0; s < subdivisions; s++) {
    let i0 = 0;
    let i1 = 0;
    let i2 = 0;
    let i3 = 0;
    for (j = 0; j < tessellation; j++) {
      i0 = i * (e + 1) + j;
      i1 = (i + 1) * (e + 1) + j;
      i2 = i * (e + 1) + (j + 1);
      i3 = (i + 1) * (e + 1) + (j + 1);
      indices.push(i0, i1, i2);
      indices.push(i3, i2, i1);
    }
    if (arc !== 1 && enclose) {
      indices.push(i0 + 2, i1 + 2, i2 + 2);
      indices.push(i3 + 2, i2 + 2, i1 + 2);
      indices.push(i0 + 4, i1 + 4, i2 + 4);
      indices.push(i3 + 4, i2 + 4, i1 + 4);
    }
    i = hasRings ? i + 2 : i + 1;
  }
  const createCylinderCap = (isTop) => {
    const radius2 = isTop ? diameterTop / 2 : diameterBottom / 2;
    if (radius2 === 0) {
      return;
    }
    let angle2;
    let circleVector;
    let i2;
    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];
    let c = null;
    if (faceColors) {
      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];
    }
    const vbase = positions.length / 3;
    const offset = isTop ? height / 2 : -height / 2;
    const center = new Vector3(0, offset, 0);
    positions.push(center.x, center.y, center.z);
    normals.push(0, isTop ? 1 : -1, 0);
    const v2 = u.y + (u.w - u.y) * 0.5;
    uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v2 : v2);
    if (c) {
      colors.push(c.r, c.g, c.b, c.a);
    }
    const textureScale = new Vector2(0.5, 0.5);
    for (i2 = 0; i2 <= tessellation; i2++) {
      angle2 = Math.PI * 2 * i2 * arc / tessellation;
      const cos = Math.cos(-angle2);
      const sin = Math.sin(-angle2);
      circleVector = new Vector3(cos * radius2, offset, sin * radius2);
      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
      positions.push(circleVector.x, circleVector.y, circleVector.z);
      normals.push(0, isTop ? 1 : -1, 0);
      const v3 = u.y + (u.w - u.y) * textureCoordinate.y;
      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v3 : v3);
      if (c) {
        colors.push(c.r, c.g, c.b, c.a);
      }
    }
    for (i2 = 0; i2 < tessellation; i2++) {
      if (!isTop) {
        indices.push(vbase);
        indices.push(vbase + (i2 + 1));
        indices.push(vbase + (i2 + 2));
      } else {
        indices.push(vbase);
        indices.push(vbase + (i2 + 2));
        indices.push(vbase + (i2 + 1));
      }
    }
  };
  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {
    createCylinderCap(false);
  }
  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {
    createCylinderCap(true);
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreateCylinder(name52, options = {}, scene) {
  const cylinder = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  cylinder._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateCylinderVertexData(options);
  vertexData.applyToMesh(cylinder, options.updatable);
  return cylinder;
}
var CylinderBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateCylinder
};
VertexData.CreateCylinder = CreateCylinderVertexData;
Mesh.CreateCylinder = (name52, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {
  if (scene === void 0 || !(scene instanceof Scene)) {
    if (scene !== void 0) {
      sideOrientation = updatable || Mesh.DEFAULTSIDE;
      updatable = scene;
    }
    scene = subdivisions;
    subdivisions = 1;
  }
  const options = {
    height,
    diameterTop,
    diameterBottom,
    tessellation,
    subdivisions,
    sideOrientation,
    updatable
  };
  return CreateCylinder(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js
function CreateTorusKnotVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const radius = options.radius || 2;
  const tube = options.tube || 0.5;
  const radialSegments = options.radialSegments || 32;
  const tubularSegments = options.tubularSegments || 32;
  const p = options.p || 2;
  const q = options.q || 3;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const getPos = (angle) => {
    const cu = Math.cos(angle);
    const su = Math.sin(angle);
    const quOverP = q / p * angle;
    const cs = Math.cos(quOverP);
    const tx = radius * (2 + cs) * 0.5 * cu;
    const ty = radius * (2 + cs) * su * 0.5;
    const tz = radius * Math.sin(quOverP) * 0.5;
    return new Vector3(tx, ty, tz);
  };
  let i;
  let j;
  for (i = 0; i <= radialSegments; i++) {
    const modI = i % radialSegments;
    const u = modI / radialSegments * 2 * p * Math.PI;
    const p1 = getPos(u);
    const p2 = getPos(u + 0.01);
    const tang = p2.subtract(p1);
    let n = p2.add(p1);
    const bitan = Vector3.Cross(tang, n);
    n = Vector3.Cross(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (j = 0; j < tubularSegments; j++) {
      const modJ = j % tubularSegments;
      const v = modJ / tubularSegments * 2 * Math.PI;
      const cx = -tube * Math.cos(v);
      const cy = tube * Math.sin(v);
      positions.push(p1.x + cx * n.x + cy * bitan.x);
      positions.push(p1.y + cx * n.y + cy * bitan.y);
      positions.push(p1.z + cx * n.z + cy * bitan.z);
      uvs.push(i / radialSegments);
      uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - j / tubularSegments : j / tubularSegments);
    }
  }
  for (i = 0; i < radialSegments; i++) {
    for (j = 0; j < tubularSegments; j++) {
      const jNext = (j + 1) % tubularSegments;
      const a = i * tubularSegments + j;
      const b = (i + 1) * tubularSegments + j;
      const c = (i + 1) * tubularSegments + jNext;
      const d = i * tubularSegments + jNext;
      indices.push(d);
      indices.push(b);
      indices.push(a);
      indices.push(d);
      indices.push(c);
      indices.push(b);
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorusKnot(name52, options = {}, scene) {
  const torusKnot = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torusKnot._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusKnotVertexData(options);
  vertexData.applyToMesh(torusKnot, options.updatable);
  return torusKnot;
}
var TorusKnotBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateTorusKnot
};
VertexData.CreateTorusKnot = CreateTorusKnotVertexData;
Mesh.CreateTorusKnot = (name52, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {
  const options = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    p,
    q,
    sideOrientation,
    updatable
  };
  return CreateTorusKnot(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
function CreateLineSystemVertexData(options) {
  const indices = [];
  const positions = [];
  const lines = options.lines;
  const colors = options.colors;
  const vertexColors = [];
  let idx = 0;
  for (let l = 0; l < lines.length; l++) {
    const points = lines[l];
    for (let index = 0; index < points.length; index++) {
      const { x, y, z } = points[index];
      positions.push(x, y, z);
      if (colors) {
        const color = colors[l];
        const { r, g, b, a } = color[index];
        vertexColors.push(r, g, b, a);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
}
function CreateDashedLinesVertexData(options) {
  const dashSize = options.dashSize || 3;
  const gapSize = options.gapSize || 1;
  const dashNb = options.dashNb || 200;
  const points = options.points;
  const positions = [];
  const indices = [];
  const curvect = Vector3.Zero();
  let lg = 0;
  let nb = 0;
  let shft = 0;
  let dashshft = 0;
  let curshft = 0;
  let idx = 0;
  let i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (let j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
}
function CreateLineSystem(name52, options, scene = null) {
  const instance = options.instance;
  const lines = options.lines;
  const colors = options.colors;
  if (instance) {
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    let vertexColor;
    let lineColors;
    if (colors) {
      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
    }
    let i = 0;
    let c = 0;
    for (let l = 0; l < lines.length; l++) {
      const points = lines[l];
      for (let p = 0; p < points.length; p++) {
        positions[i] = points[p].x;
        positions[i + 1] = points[p].y;
        positions[i + 2] = points[p].z;
        if (colors && vertexColor) {
          lineColors = colors[l];
          vertexColor[c] = lineColors[p].r;
          vertexColor[c + 1] = lineColors[p].g;
          vertexColor[c + 2] = lineColors[p].b;
          vertexColor[c + 3] = lineColors[p].a;
          c += 4;
        }
        i += 3;
      }
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (colors && vertexColor) {
      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
    }
    return instance;
  }
  const useVertexColor = colors ? true : false;
  const lineSystem = new LinesMesh(name52, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha, options.material);
  const vertexData = CreateLineSystemVertexData(options);
  vertexData.applyToMesh(lineSystem, options.updatable);
  return lineSystem;
}
function CreateLines(name52, options, scene = null) {
  const colors = options.colors ? [options.colors] : null;
  const lines = CreateLineSystem(name52, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);
  return lines;
}
function CreateDashedLines(name52, options, scene = null) {
  const points = options.points;
  const instance = options.instance;
  const gapSize = options.gapSize || 1;
  const dashSize = options.dashSize || 3;
  if (instance) {
    const positionFunction = (positions) => {
      const curvect = Vector3.Zero();
      const nbSeg = positions.length / 6;
      let lg = 0;
      let nb = 0;
      let shft = 0;
      let dashshft = 0;
      let curshft = 0;
      let p = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
      }
      shft = lg / nbSeg;
      const dashSize2 = instance._creationDataStorage.dashSize;
      const gapSize2 = instance._creationDataStorage.gapSize;
      dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        j = 0;
        while (j < nb && p < positions.length) {
          curshft = shft * j;
          positions[p] = points[i].x + curshft * curvect.x;
          positions[p + 1] = points[i].y + curshft * curvect.y;
          positions[p + 2] = points[i].z + curshft * curvect.z;
          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
          p += 6;
          j++;
        }
      }
      while (p < positions.length) {
        positions[p] = points[i].x;
        positions[p + 1] = points[i].y;
        positions[p + 2] = points[i].z;
        p += 3;
      }
    };
    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {
      Logger.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored.");
    }
    instance.updateMeshPositions(positionFunction, false);
    return instance;
  }
  const dashedLines = new LinesMesh(name52, scene, null, void 0, void 0, void 0, options.useVertexAlpha, options.material);
  const vertexData = CreateDashedLinesVertexData(options);
  vertexData.applyToMesh(dashedLines, options.updatable);
  dashedLines._creationDataStorage = new _CreationDataStorage();
  dashedLines._creationDataStorage.dashSize = dashSize;
  dashedLines._creationDataStorage.gapSize = gapSize;
  return dashedLines;
}
var LinesBuilder = {
  CreateDashedLines,
  CreateLineSystem,
  CreateLines
};
VertexData.CreateLineSystem = CreateLineSystemVertexData;
VertexData.CreateDashedLines = CreateDashedLinesVertexData;
Mesh.CreateLines = (name52, points, scene = null, updatable = false, instance = null) => {
  const options = {
    points,
    updatable,
    instance
  };
  return CreateLines(name52, options, scene);
};
Mesh.CreateDashedLines = (name52, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {
  const options = {
    points,
    dashSize,
    gapSize,
    dashNb,
    updatable,
    instance
  };
  return CreateDashedLines(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/polygonMesh.js
var IndexedVector2 = class extends Vector2 {
  constructor(original, index) {
    super(original.x, original.y);
    this.index = index;
  }
};
var PolygonPoints = class {
  constructor() {
    this.elements = [];
  }
  add(originalPoints) {
    const result = [];
    originalPoints.forEach((point) => {
      const newPoint = new IndexedVector2(point, this.elements.length);
      result.push(newPoint);
      this.elements.push(newPoint);
    });
    return result;
  }
  computeBounds() {
    const lmin = new Vector2(this.elements[0].x, this.elements[0].y);
    const lmax = new Vector2(this.elements[0].x, this.elements[0].y);
    this.elements.forEach((point) => {
      if (point.x < lmin.x) {
        lmin.x = point.x;
      } else if (point.x > lmax.x) {
        lmax.x = point.x;
      }
      if (point.y < lmin.y) {
        lmin.y = point.y;
      } else if (point.y > lmax.y) {
        lmax.y = point.y;
      }
    });
    return {
      min: lmin,
      max: lmax,
      width: lmax.x - lmin.x,
      height: lmax.y - lmin.y
    };
  }
};
var Polygon = class {
  /**
   * Creates a rectangle
   * @param xmin bottom X coord
   * @param ymin bottom Y coord
   * @param xmax top X coord
   * @param ymax top Y coord
   * @returns points that make the resulting rectangle
   */
  static Rectangle(xmin, ymin, xmax, ymax) {
    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];
  }
  /**
   * Creates a circle
   * @param radius radius of circle
   * @param cx scale in x
   * @param cy scale in y
   * @param numberOfSides number of sides that make up the circle
   * @returns points that make the resulting circle
   */
  static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {
    const result = [];
    let angle = 0;
    const increment = Math.PI * 2 / numberOfSides;
    for (let i = 0; i < numberOfSides; i++) {
      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
      angle -= increment;
    }
    return result;
  }
  /**
   * Creates a polygon from input string
   * @param input Input polygon data
   * @returns the parsed points
   */
  static Parse(input) {
    const floats = input.split(/[^-+eE.\d]+/).map(parseFloat).filter((val) => !isNaN(val));
    let i;
    const result = [];
    for (i = 0; i < (floats.length & 2147483646); i += 2) {
      result.push(new Vector2(floats[i], floats[i + 1]));
    }
    return result;
  }
  /**
   * Starts building a polygon from x and y coordinates
   * @param x x coordinate
   * @param y y coordinate
   * @returns the started path2
   */
  static StartingAt(x, y) {
    return Path2.StartingAt(x, y);
  }
};
var PolygonMeshBuilder = class {
  _addToepoint(points) {
    for (const p of points) {
      this._epoints.push(p.x, p.y);
    }
  }
  /**
   * Creates a PolygonMeshBuilder
   * @param name name of the builder
   * @param contours Path of the polygon
   * @param scene scene to add to when creating the mesh
   * @param earcutInjection can be used to inject your own earcut reference
   */
  constructor(name52, contours, scene, earcutInjection = earcut) {
    this._points = new PolygonPoints();
    this._outlinepoints = new PolygonPoints();
    this._holes = new Array();
    this._epoints = new Array();
    this._eholes = new Array();
    this.bjsEarcut = earcutInjection;
    this._name = name52;
    this._scene = scene || EngineStore.LastCreatedScene;
    let points;
    if (contours instanceof Path2) {
      points = contours.getPoints();
    } else {
      points = contours;
    }
    this._addToepoint(points);
    this._points.add(points);
    this._outlinepoints.add(points);
    if (typeof this.bjsEarcut === "undefined") {
      Logger.Warn("Earcut was not found, the polygon will not be built.");
    }
  }
  /**
   * Adds a hole within the polygon
   * @param hole Array of points defining the hole
   * @returns this
   */
  addHole(hole) {
    this._points.add(hole);
    const holepoints = new PolygonPoints();
    holepoints.add(hole);
    this._holes.push(holepoints);
    this._eholes.push(this._epoints.length / 2);
    this._addToepoint(hole);
    return this;
  }
  /**
   * Creates the polygon
   * @param updatable If the mesh should be updatable
   * @param depth The depth of the mesh created
   * @param smoothingThreshold Dot product threshold for smoothed normals
   * @returns the created mesh
   */
  build(updatable = false, depth = 0, smoothingThreshold = 2) {
    const result = new Mesh(this._name, this._scene);
    const vertexData = this.buildVertexData(depth, smoothingThreshold);
    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);
    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);
    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);
    result.setIndices(vertexData.indices);
    return result;
  }
  /**
   * Creates the polygon
   * @param depth The depth of the mesh created
   * @param smoothingThreshold Dot product threshold for smoothed normals
   * @returns the created VertexData
   */
  buildVertexData(depth = 0, smoothingThreshold = 2) {
    const result = new VertexData();
    const normals = [];
    const positions = [];
    const uvs = [];
    const bounds = this._points.computeBounds();
    this._points.elements.forEach((p) => {
      normals.push(0, 1, 0);
      positions.push(p.x, 0, p.y);
      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
    });
    const indices = [];
    const res = this.bjsEarcut(this._epoints, this._eholes, 2);
    for (let i = 0; i < res.length; i++) {
      indices.push(res[i]);
    }
    if (depth > 0) {
      const positionscount = positions.length / 3;
      this._points.elements.forEach((p) => {
        normals.push(0, -1, 0);
        positions.push(p.x, -depth, p.y);
        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
      });
      const totalCount = indices.length;
      for (let i = 0; i < totalCount; i += 3) {
        const i0 = indices[i + 0];
        const i1 = indices[i + 1];
        const i2 = indices[i + 2];
        indices.push(i2 + positionscount);
        indices.push(i1 + positionscount);
        indices.push(i0 + positionscount);
      }
      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);
      this._holes.forEach((hole) => {
        this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);
      });
    }
    result.indices = indices;
    result.positions = positions;
    result.normals = normals;
    result.uvs = uvs;
    return result;
  }
  /**
   * Adds a side to the polygon
   * @param positions points that make the polygon
   * @param normals normals of the polygon
   * @param uvs uvs of the polygon
   * @param indices indices of the polygon
   * @param bounds bounds of the polygon
   * @param points points of the polygon
   * @param depth depth of the polygon
   * @param flip flip of the polygon
   * @param smoothingThreshold
   */
  _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {
    let startIndex = positions.length / 3;
    let ulength = 0;
    for (let i = 0; i < points.elements.length; i++) {
      const p = points.elements[i];
      const p1 = points.elements[(i + 1) % points.elements.length];
      positions.push(p.x, 0, p.y);
      positions.push(p.x, -depth, p.y);
      positions.push(p1.x, 0, p1.y);
      positions.push(p1.x, -depth, p1.y);
      const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];
      const p2 = points.elements[(i + 2) % points.elements.length];
      let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);
      let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);
      let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);
      if (!flip) {
        vc = vc.scale(-1);
        vp = vp.scale(-1);
        vn = vn.scale(-1);
      }
      const vc_norm = vc.normalizeToNew();
      let vp_norm = vp.normalizeToNew();
      let vn_norm = vn.normalizeToNew();
      const dotp = Vector3.Dot(vp_norm, vc_norm);
      if (dotp > smoothingThreshold) {
        if (dotp < Epsilon - 1) {
          vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();
        } else {
          vp_norm = vp.add(vc).normalize();
        }
      } else {
        vp_norm = vc_norm;
      }
      const dotn = Vector3.Dot(vn, vc);
      if (dotn > smoothingThreshold) {
        if (dotn < Epsilon - 1) {
          vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();
        } else {
          vn_norm = vn.add(vc).normalize();
        }
      } else {
        vn_norm = vc_norm;
      }
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      ulength += vc.length();
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);
      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);
      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);
      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);
      if (!flip) {
        indices.push(startIndex);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 3);
        indices.push(startIndex + 2);
      } else {
        indices.push(startIndex);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 3);
      }
      startIndex += 4;
    }
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js
function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {
  const faceUV = fUV || new Array(3);
  const faceColors = fColors;
  const colors = [];
  const wrap = wrp || false;
  for (let f = 0; f < 3; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const positions = polygon.getVerticesData(VertexBuffer.PositionKind);
  const normals = polygon.getVerticesData(VertexBuffer.NormalKind);
  const uvs = polygon.getVerticesData(VertexBuffer.UVKind);
  const indices = polygon.getIndices();
  const startIndex = positions.length / 9;
  let disp = 0;
  let distX = 0;
  let distZ = 0;
  let dist = 0;
  let totalLen = 0;
  const cumulate = [0];
  if (wrap) {
    for (let idx2 = startIndex; idx2 < positions.length / 3; idx2 += 4) {
      distX = positions[3 * (idx2 + 2)] - positions[3 * idx2];
      distZ = positions[3 * (idx2 + 2) + 2] - positions[3 * idx2 + 2];
      dist = Math.sqrt(distX * distX + distZ * distZ);
      totalLen += dist;
      cumulate.push(totalLen);
    }
  }
  let idx = 0;
  let face = 0;
  for (let index = 0; index < normals.length; index += 3) {
    if (Math.abs(normals[index + 1]) < 1e-3) {
      face = 1;
    }
    if (Math.abs(normals[index + 1] - 1) < 1e-3) {
      face = 0;
    }
    if (Math.abs(normals[index + 1] + 1) < 1e-3) {
      face = 2;
    }
    idx = index / 3;
    if (face === 1) {
      disp = idx - startIndex;
      if (disp % 4 < 1.5) {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].x;
        }
      } else {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].z;
        }
      }
      if (disp % 2 === 0) {
        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[face].w : faceUV[face].w;
      } else {
        uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[face].y : faceUV[face].y;
      }
    } else {
      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
      if (CompatibilityOptions.UseOpenGLOrientationForUV) {
        uvs[2 * idx + 1] = 1 - uvs[2 * idx + 1];
      }
    }
    if (faceColors) {
      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreatePolygon(name52, options, scene = null, earcutInjection = earcut) {
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const shape = options.shape;
  const holes = options.holes || [];
  const depth = options.depth || 0;
  const smoothingThreshold = options.smoothingThreshold || 2;
  const contours = [];
  let hole = [];
  for (let i = 0; i < shape.length; i++) {
    contours[i] = new Vector2(shape[i].x, shape[i].z);
  }
  const epsilon = 1e-8;
  if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
    contours.pop();
  }
  const polygonTriangulation = new PolygonMeshBuilder(name52, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
  for (let hNb = 0; hNb < holes.length; hNb++) {
    hole = [];
    for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
      hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
    }
    polygonTriangulation.addHole(hole);
  }
  const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);
  polygon._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);
  vertexData.applyToMesh(polygon, options.updatable);
  return polygon;
}
function ExtrudePolygon(name52, options, scene = null, earcutInjection = earcut) {
  return CreatePolygon(name52, options, scene, earcutInjection);
}
var PolygonBuilder = {
  ExtrudePolygon,
  CreatePolygon
};
VertexData.CreatePolygon = CreatePolygonVertexData;
Mesh.CreatePolygon = (name52, shape, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    updatable,
    sideOrientation
  };
  return CreatePolygon(name52, options, scene, earcutInjection);
};
Mesh.ExtrudePolygon = (name52, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    depth,
    updatable,
    sideOrientation
  };
  return ExtrudePolygon(name52, options, scene, earcutInjection);
};

// node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js
function ExtrudeShape(name52, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const scale = options.scale || 1;
  const rotation = options.rotation || 0;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance || null;
  const invertUV = options.invertUV || false;
  const closeShape = options.closeShape || false;
  const closePath = options.closePath || false;
  return _ExtrudeShapeGeneric(name52, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null, options.firstNormal || null, options.adjustFrame ? true : false);
}
function ExtrudeShapeCustom(name52, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const scaleFunction = options.scaleFunction || (() => {
    return 1;
  });
  const rotationFunction = options.rotationFunction || (() => {
    return 0;
  });
  const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;
  const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const firstNormal = options.firstNormal || null;
  const adjustFrame = options.adjustFrame || false;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const invertUV = options.invertUV || false;
  return _ExtrudeShapeGeneric(name52, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null, firstNormal, adjustFrame);
}
function _ExtrudeShapeGeneric(name52, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs, firstNormal, adjustFrame) {
  const extrusionPathArray = (shape2, curve2, path3D2, shapePaths, scale2, rotation2, scaleFunction2, rotateFunction2, cap2, custom2, adjustFrame2) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const binormals = path3D2.getBinormals();
    const distances = path3D2.getDistances();
    if (adjustFrame2) {
      for (let i = 0; i < tangents.length; i++) {
        if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {
          tangents[i].copyFrom(tangents[i - 1]);
        }
        if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {
          normals[i].copyFrom(normals[i - 1]);
        }
        if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {
          binormals[i].copyFrom(binormals[i - 1]);
        }
        if (i > 0) {
          let v = tangents[i - 1];
          if (Vector3.Dot(v, tangents[i]) < 0) {
            tangents[i].scaleInPlace(-1);
          }
          v = normals[i - 1];
          if (Vector3.Dot(v, normals[i]) < 0) {
            normals[i].scaleInPlace(-1);
          }
          v = binormals[i - 1];
          if (Vector3.Dot(v, binormals[i]) < 0) {
            binormals[i].scaleInPlace(-1);
          }
        }
      }
    }
    let angle = 0;
    const returnScale = () => {
      return scale2 !== null ? scale2 : 1;
    };
    const returnRotation = () => {
      return rotation2 !== null ? rotation2 : 0;
    };
    const rotate = custom2 && rotateFunction2 ? rotateFunction2 : returnRotation;
    const scl = custom2 && scaleFunction2 ? scaleFunction2 : returnScale;
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    const rotationMatrix = TmpVectors.Matrix[0];
    for (let i = 0; i < curve2.length; i++) {
      const shapePath = [];
      const angleStep = rotate(i, distances[i]);
      const scaleRatio = scl(i, distances[i]);
      Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);
      for (let p = 0; p < shape2.length; p++) {
        const planed = tangents[i].scale(shape2[p].z).add(normals[i].scale(shape2[p].x)).add(binormals[i].scale(shape2[p].y));
        const rotated = Vector3.Zero();
        Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);
        rotated.scaleInPlace(scaleRatio).addInPlace(curve2[i]);
        shapePath[p] = rotated;
      }
      shapePaths[index] = shapePath;
      angle += angleStep;
      index++;
    }
    const capPath = (shapePath) => {
      const pointCap = Array();
      const barycenter = Vector3.Zero();
      let i;
      for (i = 0; i < shapePath.length; i++) {
        barycenter.addInPlace(shapePath[i]);
      }
      barycenter.scaleInPlace(1 / shapePath.length);
      for (i = 0; i < shapePath.length; i++) {
        pointCap.push(barycenter);
      }
      return pointCap;
    };
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        break;
      case Mesh.CAP_END:
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      case Mesh.CAP_ALL:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      default:
        break;
    }
    return shapePaths;
  };
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);
    pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);
    instance = CreateRibbon("", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || void 0);
    return instance;
  }
  path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);
  const newShapePaths = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);
  const extrudedGeneric = CreateRibbon(name52, {
    pathArray,
    closeArray: rbCA,
    closePath: rbCP,
    updatable: updtbl,
    sideOrientation: side,
    invertUV,
    frontUVs: frontUVs || void 0,
    backUVs: backUVs || void 0
  }, scene);
  extrudedGeneric._creationDataStorage.pathArray = pathArray;
  extrudedGeneric._creationDataStorage.path3D = path3D;
  extrudedGeneric._creationDataStorage.cap = cap;
  return extrudedGeneric;
}
var ShapeBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  ExtrudeShape,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  ExtrudeShapeCustom
};
Mesh.ExtrudeShape = (name52, shape, path, scale, rotation, cap, scene = null, updatable, sideOrientation, instance) => {
  const options = {
    shape,
    path,
    scale,
    rotation,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ExtrudeShape(name52, options, scene);
};
Mesh.ExtrudeShapeCustom = (name52, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) => {
  const options = {
    shape,
    path,
    scaleFunction,
    rotationFunction,
    ribbonCloseArray,
    ribbonClosePath,
    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
    sideOrientation,
    instance,
    updatable
  };
  return ExtrudeShapeCustom(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js
function CreateLathe(name52, options, scene = null) {
  const arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1 : options.arc : 1;
  const closed = options.closed === void 0 ? true : options.closed;
  const shape = options.shape;
  const radius = options.radius || 1;
  const tessellation = options.tessellation || 64;
  const clip = options.clip || 0;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const cap = options.cap || Mesh.NO_CAP;
  const pi2 = Math.PI * 2;
  const paths = [];
  const invertUV = options.invertUV || false;
  let i = 0;
  let p = 0;
  const step = pi2 / tessellation * arc;
  let rotated;
  let path;
  for (i = 0; i <= tessellation - clip; i++) {
    path = [];
    if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(0, shape[0].y, 0));
      path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));
    }
    for (p = 0; p < shape.length; p++) {
      rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);
      path.push(rotated);
    }
    if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));
      path.push(new Vector3(0, shape[shape.length - 1].y, 0));
    }
    paths.push(path);
  }
  const lathe = CreateRibbon(name52, { pathArray: paths, closeArray: closed, sideOrientation, updatable, invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
  return lathe;
}
var LatheBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateLathe
};
Mesh.CreateLathe = (name52, shape, radius, tessellation, scene, updatable, sideOrientation) => {
  const options = {
    shape,
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateLathe(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name52, options = {}, scene = null) {
  const plane = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
var PlaneBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreatePlane
};
VertexData.CreatePlane = CreatePlaneVertexData;
Mesh.CreatePlane = (name52, size, scene, updatable, sideOrientation) => {
  const options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return CreatePlane(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js
function CreateTube(name52, options, scene = null) {
  const path = options.path;
  let instance = options.instance;
  let radius = 1;
  if (options.radius !== void 0) {
    radius = options.radius;
  } else if (instance) {
    radius = instance._creationDataStorage.radius;
  }
  const tessellation = options.tessellation || 64 | 0;
  const radiusFunction = options.radiusFunction || null;
  let cap = options.cap || Mesh.NO_CAP;
  const invertUV = options.invertUV || false;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  options.arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const tubePathArray = (path2, path3D2, circlePaths, radius2, tessellation2, radiusFunction2, cap2, arc) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const distances = path3D2.getDistances();
    const pi2 = Math.PI * 2;
    const step = pi2 / tessellation2 * arc;
    const returnRadius = () => radius2;
    const radiusFunctionFinal = radiusFunction2 || returnRadius;
    let circlePath;
    let rad;
    let normal;
    let rotated;
    const rotationMatrix = TmpVectors.Matrix[0];
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    for (let i = 0; i < path2.length; i++) {
      rad = radiusFunctionFinal(i, distances[i]);
      circlePath = Array();
      normal = normals[i];
      for (let t = 0; t < tessellation2; t++) {
        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
        rotated.scaleInPlace(rad).addInPlace(path2[i]);
        circlePath[t] = rotated;
      }
      circlePaths[index] = circlePath;
      index++;
    }
    const capPath = (nbPoints, pathIndex) => {
      const pointCap = Array();
      for (let i = 0; i < nbPoints; i++) {
        pointCap.push(path2[pathIndex]);
      }
      return pointCap;
    };
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        break;
      case Mesh.CAP_END:
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      case Mesh.CAP_ALL:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      default:
        break;
    }
    return circlePaths;
  };
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    const arc = options.arc || storage.arc;
    path3D = storage.path3D.update(path);
    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);
    instance = CreateRibbon("", { pathArray, instance });
    storage.path3D = path3D;
    storage.pathArray = pathArray;
    storage.arc = arc;
    storage.radius = radius;
    return instance;
  }
  path3D = new Path3D(path);
  const newPathArray = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);
  const tube = CreateRibbon(name52, {
    pathArray,
    closePath: true,
    closeArray: false,
    updatable,
    sideOrientation,
    invertUV,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  }, scene);
  tube._creationDataStorage.pathArray = pathArray;
  tube._creationDataStorage.path3D = path3D;
  tube._creationDataStorage.tessellation = tessellation;
  tube._creationDataStorage.cap = cap;
  tube._creationDataStorage.arc = options.arc;
  tube._creationDataStorage.radius = radius;
  return tube;
}
var TubeBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateTube
};
Mesh.CreateTube = (name52, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {
  const options = {
    path,
    radius,
    tessellation,
    radiusFunction,
    arc: 1,
    cap,
    updatable,
    sideOrientation,
    instance
  };
  return CreateTube(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js
function CreatePolyhedronVertexData(options) {
  const polyhedra = [];
  polyhedra[0] = {
    vertex: [
      [0, 0, 1.732051],
      [1.632993, 0, -0.5773503],
      [-0.8164966, 1.414214, -0.5773503],
      [-0.8164966, -1.414214, -0.5773503]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 1],
      [1, 3, 2]
    ]
  };
  polyhedra[1] = {
    vertex: [
      [0, 0, 1.414214],
      [1.414214, 0, 0],
      [0, 1.414214, 0],
      [-1.414214, 0, 0],
      [0, -1.414214, 0],
      [0, 0, -1.414214]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 1],
      [1, 4, 5],
      [1, 5, 2],
      [2, 5, 3],
      [3, 5, 4]
    ]
  };
  polyhedra[2] = {
    vertex: [
      [0, 0, 1.070466],
      [0.7136442, 0, 0.7978784],
      [-0.3568221, 0.618034, 0.7978784],
      [-0.3568221, -0.618034, 0.7978784],
      [0.7978784, 0.618034, 0.3568221],
      [0.7978784, -0.618034, 0.3568221],
      [-0.9341724, 0.381966, 0.3568221],
      [0.1362939, 1, 0.3568221],
      [0.1362939, -1, 0.3568221],
      [-0.9341724, -0.381966, 0.3568221],
      [0.9341724, 0.381966, -0.3568221],
      [0.9341724, -0.381966, -0.3568221],
      [-0.7978784, 0.618034, -0.3568221],
      [-0.1362939, 1, -0.3568221],
      [-0.1362939, -1, -0.3568221],
      [-0.7978784, -0.618034, -0.3568221],
      [0.3568221, 0.618034, -0.7978784],
      [0.3568221, -0.618034, -0.7978784],
      [-0.7136442, 0, -0.7978784],
      [0, 0, -1.070466]
    ],
    face: [
      [0, 1, 4, 7, 2],
      [0, 2, 6, 9, 3],
      [0, 3, 8, 5, 1],
      [1, 5, 11, 10, 4],
      [2, 7, 13, 12, 6],
      [3, 9, 15, 14, 8],
      [4, 10, 16, 13, 7],
      [5, 8, 14, 17, 11],
      [6, 12, 18, 15, 9],
      [10, 11, 17, 19, 16],
      [12, 13, 16, 19, 18],
      [14, 15, 18, 19, 17]
    ]
  };
  polyhedra[3] = {
    vertex: [
      [0, 0, 1.175571],
      [1.051462, 0, 0.5257311],
      [0.3249197, 1, 0.5257311],
      [-0.8506508, 0.618034, 0.5257311],
      [-0.8506508, -0.618034, 0.5257311],
      [0.3249197, -1, 0.5257311],
      [0.8506508, 0.618034, -0.5257311],
      [0.8506508, -0.618034, -0.5257311],
      [-0.3249197, 1, -0.5257311],
      [-1.051462, 0, -0.5257311],
      [-0.3249197, -1, -0.5257311],
      [0, 0, -1.175571]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 5],
      [0, 5, 1],
      [1, 5, 7],
      [1, 7, 6],
      [1, 6, 2],
      [2, 6, 8],
      [2, 8, 3],
      [3, 8, 9],
      [3, 9, 4],
      [4, 9, 10],
      [4, 10, 5],
      [5, 10, 7],
      [6, 7, 11],
      [6, 11, 8],
      [7, 10, 11],
      [8, 11, 9],
      [9, 11, 10]
    ]
  };
  polyhedra[4] = {
    vertex: [
      [0, 0, 1.070722],
      [0.7148135, 0, 0.7971752],
      [-0.104682, 0.7071068, 0.7971752],
      [-0.6841528, 0.2071068, 0.7971752],
      [-0.104682, -0.7071068, 0.7971752],
      [0.6101315, 0.7071068, 0.5236279],
      [1.04156, 0.2071068, 0.1367736],
      [0.6101315, -0.7071068, 0.5236279],
      [-0.3574067, 1, 0.1367736],
      [-0.7888348, -0.5, 0.5236279],
      [-0.9368776, 0.5, 0.1367736],
      [-0.3574067, -1, 0.1367736],
      [0.3574067, 1, -0.1367736],
      [0.9368776, -0.5, -0.1367736],
      [0.7888348, 0.5, -0.5236279],
      [0.3574067, -1, -0.1367736],
      [-0.6101315, 0.7071068, -0.5236279],
      [-1.04156, -0.2071068, -0.1367736],
      [-0.6101315, -0.7071068, -0.5236279],
      [0.104682, 0.7071068, -0.7971752],
      [0.6841528, -0.2071068, -0.7971752],
      [0.104682, -0.7071068, -0.7971752],
      [-0.7148135, 0, -0.7971752],
      [0, 0, -1.070722]
    ],
    face: [
      [0, 2, 3],
      [1, 6, 5],
      [4, 9, 11],
      [7, 15, 13],
      [8, 16, 10],
      [12, 14, 19],
      [17, 22, 18],
      [20, 21, 23],
      [0, 1, 5, 2],
      [0, 3, 9, 4],
      [0, 4, 7, 1],
      [1, 7, 13, 6],
      [2, 5, 12, 8],
      [2, 8, 10, 3],
      [3, 10, 17, 9],
      [4, 11, 15, 7],
      [5, 6, 14, 12],
      [6, 13, 20, 14],
      [8, 12, 19, 16],
      [9, 17, 18, 11],
      [10, 16, 22, 17],
      [11, 18, 21, 15],
      [13, 15, 21, 20],
      [14, 20, 23, 19],
      [16, 19, 23, 22],
      [18, 22, 23, 21]
    ]
  };
  polyhedra[5] = {
    vertex: [
      [0, 0, 1.322876],
      [1.309307, 0, 0.1889822],
      [-0.9819805, 0.8660254, 0.1889822],
      [0.1636634, -1.299038, 0.1889822],
      [0.3273268, 0.8660254, -0.9449112],
      [-0.8183171, -0.4330127, -0.9449112]
    ],
    face: [
      [0, 3, 1],
      [2, 4, 5],
      [0, 1, 4, 2],
      [0, 2, 5, 3],
      [1, 3, 5, 4]
    ]
  };
  polyhedra[6] = {
    vertex: [
      [0, 0, 1.159953],
      [1.013464, 0, 0.5642542],
      [-0.3501431, 0.9510565, 0.5642542],
      [-0.7715208, -0.6571639, 0.5642542],
      [0.6633206, 0.9510565, -0.03144481],
      [0.8682979, -0.6571639, -0.3996071],
      [-1.121664, 0.2938926, -0.03144481],
      [-0.2348831, -1.063314, -0.3996071],
      [0.5181548, 0.2938926, -0.9953061],
      [-0.5850262, -0.112257, -0.9953061]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 9, 7],
      [5, 7, 9, 8],
      [0, 3, 7, 5, 1],
      [2, 4, 8, 9, 6]
    ]
  };
  polyhedra[7] = {
    vertex: [
      [0, 0, 1.118034],
      [0.8944272, 0, 0.6708204],
      [-0.2236068, 0.8660254, 0.6708204],
      [-0.7826238, -0.4330127, 0.6708204],
      [0.6708204, 0.8660254, 0.2236068],
      [1.006231, -0.4330127, -0.2236068],
      [-1.006231, 0.4330127, 0.2236068],
      [-0.6708204, -0.8660254, -0.2236068],
      [0.7826238, 0.4330127, -0.6708204],
      [0.2236068, -0.8660254, -0.6708204],
      [-0.8944272, 0, -0.6708204],
      [0, 0, -1.118034]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 10, 7],
      [5, 9, 11, 8],
      [7, 10, 11, 9],
      [0, 3, 7, 9, 5, 1],
      [2, 4, 8, 11, 10, 6]
    ]
  };
  polyhedra[8] = {
    vertex: [
      [-0.729665, 0.670121, 0.319155],
      [-0.655235, -0.29213, -0.754096],
      [-0.093922, -0.607123, 0.537818],
      [0.702196, 0.595691, 0.485187],
      [0.776626, -0.36656, -0.588064]
    ],
    face: [
      [1, 4, 2],
      [0, 1, 2],
      [3, 0, 2],
      [4, 3, 2],
      [4, 1, 0, 3]
    ]
  };
  polyhedra[9] = {
    vertex: [
      [-0.868849, -0.100041, 0.61257],
      [-0.329458, 0.976099, 0.28078],
      [-0.26629, -0.013796, -0.477654],
      [-0.13392, -1.034115, 0.229829],
      [0.738834, 0.707117, -0.307018],
      [0.859683, -0.535264, -0.338508]
    ],
    face: [
      [3, 0, 2],
      [5, 3, 2],
      [4, 5, 2],
      [1, 4, 2],
      [0, 1, 2],
      [0, 3, 5, 4, 1]
    ]
  };
  polyhedra[10] = {
    vertex: [
      [-0.610389, 0.243975, 0.531213],
      [-0.187812, -0.48795, -0.664016],
      [-0.187812, 0.9759, -0.664016],
      [0.187812, -0.9759, 0.664016],
      [0.798201, 0.243975, 0.132803]
    ],
    face: [
      [1, 3, 0],
      [3, 4, 0],
      [3, 1, 4],
      [0, 2, 1],
      [0, 4, 2],
      [2, 4, 1]
    ]
  };
  polyhedra[11] = {
    vertex: [
      [-1.028778, 0.392027, -0.048786],
      [-0.640503, -0.646161, 0.621837],
      [-0.125162, -0.395663, -0.540059],
      [4683e-6, 0.888447, -0.651988],
      [0.125161, 0.395663, 0.540059],
      [0.632925, -0.791376, 0.433102],
      [1.031672, 0.157063, -0.354165]
    ],
    face: [
      [3, 2, 0],
      [2, 1, 0],
      [2, 5, 1],
      [0, 4, 3],
      [0, 1, 4],
      [4, 1, 5],
      [2, 3, 6],
      [3, 4, 6],
      [5, 2, 6],
      [4, 5, 6]
    ]
  };
  polyhedra[12] = {
    vertex: [
      [-0.669867, 0.334933, -0.529576],
      [-0.669867, 0.334933, 0.529577],
      [-0.4043, 1.212901, 0],
      [-0.334933, -0.669867, -0.529576],
      [-0.334933, -0.669867, 0.529577],
      [0.334933, 0.669867, -0.529576],
      [0.334933, 0.669867, 0.529577],
      [0.4043, -1.212901, 0],
      [0.669867, -0.334933, -0.529576],
      [0.669867, -0.334933, 0.529577]
    ],
    face: [
      [8, 9, 7],
      [6, 5, 2],
      [3, 8, 7],
      [5, 0, 2],
      [4, 3, 7],
      [0, 1, 2],
      [9, 4, 7],
      [1, 6, 2],
      [9, 8, 5, 6],
      [8, 3, 0, 5],
      [3, 4, 1, 0],
      [4, 9, 6, 1]
    ]
  };
  polyhedra[13] = {
    vertex: [
      [-0.931836, 0.219976, -0.264632],
      [-0.636706, 0.318353, 0.692816],
      [-0.613483, -0.735083, -0.264632],
      [-0.326545, 0.979634, 0],
      [-0.318353, -0.636706, 0.692816],
      [-0.159176, 0.477529, -0.856368],
      [0.159176, -0.477529, -0.856368],
      [0.318353, 0.636706, 0.692816],
      [0.326545, -0.979634, 0],
      [0.613482, 0.735082, -0.264632],
      [0.636706, -0.318353, 0.692816],
      [0.931835, -0.219977, -0.264632]
    ],
    face: [
      [11, 10, 8],
      [7, 9, 3],
      [6, 11, 8],
      [9, 5, 3],
      [2, 6, 8],
      [5, 0, 3],
      [4, 2, 8],
      [0, 1, 3],
      [10, 4, 8],
      [1, 7, 3],
      [10, 11, 9, 7],
      [11, 6, 5, 9],
      [6, 2, 0, 5],
      [2, 4, 1, 0],
      [4, 10, 7, 1]
    ]
  };
  polyhedra[14] = {
    vertex: [
      [-0.93465, 0.300459, -0.271185],
      [-0.838689, -0.260219, -0.516017],
      [-0.711319, 0.717591, 0.128359],
      [-0.710334, -0.156922, 0.080946],
      [-0.599799, 0.556003, -0.725148],
      [-0.503838, -4675e-6, -0.969981],
      [-0.487004, 0.26021, 0.48049],
      [-0.460089, -0.750282, -0.512622],
      [-0.376468, 0.973135, -0.325605],
      [-0.331735, -0.646985, 0.084342],
      [-0.254001, 0.831847, 0.530001],
      [-0.125239, -0.494738, -0.966586],
      [0.029622, 0.027949, 0.730817],
      [0.056536, -0.982543, -0.262295],
      [0.08085, 1.087391, 0.076037],
      [0.125583, -0.532729, 0.485984],
      [0.262625, 0.599586, 0.780328],
      [0.391387, -0.726999, -0.716259],
      [0.513854, -0.868287, 0.139347],
      [0.597475, 0.85513, 0.326364],
      [0.641224, 0.109523, 0.783723],
      [0.737185, -0.451155, 0.538891],
      [0.848705, -0.612742, -0.314616],
      [0.976075, 0.365067, 0.32976],
      [1.072036, -0.19561, 0.084927]
    ],
    face: [
      [15, 18, 21],
      [12, 20, 16],
      [6, 10, 2],
      [3, 0, 1],
      [9, 7, 13],
      [2, 8, 4, 0],
      [0, 4, 5, 1],
      [1, 5, 11, 7],
      [7, 11, 17, 13],
      [13, 17, 22, 18],
      [18, 22, 24, 21],
      [21, 24, 23, 20],
      [20, 23, 19, 16],
      [16, 19, 14, 10],
      [10, 14, 8, 2],
      [15, 9, 13, 18],
      [12, 15, 21, 20],
      [6, 12, 16, 10],
      [3, 6, 2, 0],
      [9, 3, 1, 7],
      [9, 15, 12, 6, 3],
      [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]
    ]
  };
  const type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const data = options.custom || polyhedra[type];
  const nbfaces = data.face.length;
  const faceUV = options.faceUV || new Array(nbfaces);
  const faceColors = options.faceColors;
  const flat = options.flat === void 0 ? true : options.flat;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const colors = [];
  let index = 0;
  let faceIdx = 0;
  const indexes = [];
  let i = 0;
  let f = 0;
  let u, v, ang, x, y, tmp;
  if (flat) {
    for (f = 0; f < nbfaces; f++) {
      if (faceColors && faceColors[f] === void 0) {
        faceColors[f] = new Color4(1, 1, 1, 1);
      }
      if (faceUV && faceUV[f] === void 0) {
        faceUV[f] = new Vector4(0, 0, 1, 1);
      }
    }
  }
  if (!flat) {
    for (i = 0; i < data.vertex.length; i++) {
      positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);
      uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
    }
    for (f = 0; f < nbfaces; f++) {
      for (i = 0; i < data.face[f].length - 2; i++) {
        indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);
      }
    }
  } else {
    for (f = 0; f < nbfaces; f++) {
      const fl = data.face[f].length;
      ang = 2 * Math.PI / fl;
      x = 0.5 * Math.tan(ang / 2);
      y = 0.5;
      for (i = 0; i < fl; i++) {
        positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);
        indexes.push(index);
        index++;
        u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);
        v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);
        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        tmp = x * Math.cos(ang) - y * Math.sin(ang);
        y = x * Math.sin(ang) + y * Math.cos(ang);
        x = tmp;
        if (faceColors) {
          colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
        }
      }
      for (i = 0; i < fl - 2; i++) {
        indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);
      }
      faceIdx += fl;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors && flat) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreatePolyhedron(name52, options = {}, scene = null) {
  const polyhedron = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  polyhedron._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolyhedronVertexData(options);
  vertexData.applyToMesh(polyhedron, options.updatable);
  return polyhedron;
}
var PolyhedronBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreatePolyhedron
};
VertexData.CreatePolyhedron = CreatePolyhedronVertexData;
Mesh.CreatePolyhedron = (name52, options, scene) => {
  return CreatePolyhedron(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
function CreateIcoSphereVertexData(options) {
  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  const radius = options.radius || 1;
  const flat = options.flat === void 0 ? true : options.flat;
  const subdivisions = (options.subdivisions || 4) | 0;
  const radiusX = options.radiusX || radius;
  const radiusY = options.radiusY || radius;
  const radiusZ = options.radiusZ || radius;
  const t = (1 + Math.sqrt(5)) / 2;
  const icoVertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
    // v8-11
  ];
  const ico_indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  const vertices_unalias_id = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    // vertex alias
    0,
    2,
    3,
    3,
    3,
    4,
    7,
    8,
    9,
    9,
    10,
    11
    // 23: B + 12
  ];
  const ico_vertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    // vertex alias (for same vertex on different faces)
    0,
    4,
    3,
    3,
    4,
    4,
    3,
    1,
    4,
    2,
    4,
    4,
    0,
    2,
    1,
    1,
    2,
    2,
    3,
    3,
    1,
    3,
    2,
    4
    // 23: B + 12
  ];
  const ustep = 138 / 1024;
  const vstep = 239 / 1024;
  const uoffset = 60 / 1024;
  const voffset = 26 / 1024;
  const island_u_offset = -40 / 1024;
  const island_v_offset = 20 / 1024;
  const island = [
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0
    //  15 - 19
  ];
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let current_indice = 0;
  const face_vertex_pos = new Array(3);
  const face_vertex_uv = new Array(3);
  let v012;
  for (v012 = 0; v012 < 3; v012++) {
    face_vertex_pos[v012] = Vector3.Zero();
    face_vertex_uv[v012] = Vector2.Zero();
  }
  for (let face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      const v_id = ico_indices[3 * face + v012];
      face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);
      face_vertex_pos[v012].normalize();
      face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);
    }
    const interp_vertex = (i1, i2, c1, c2) => {
      const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);
      const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);
      const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));
      pos_interp.normalize();
      let vertex_normal;
      if (flat) {
        const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);
        const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);
        vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));
      } else {
        vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);
      }
      vertex_normal.x /= radiusX;
      vertex_normal.y /= radiusY;
      vertex_normal.z /= radiusZ;
      vertex_normal.normalize();
      const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);
      const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);
      const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));
      positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);
      normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);
      uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uv_interp.y : uv_interp.y);
      indices.push(current_indice);
      current_indice++;
    };
    for (let i2 = 0; i2 < subdivisions; i2++) {
      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {
        interp_vertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interp_vertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateIcoSphere(name52, options = {}, scene = null) {
  const sphere = new Mesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateIcoSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var IcoSphereBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateIcoSphere
};
VertexData.CreateIcoSphere = CreateIcoSphereVertexData;
Mesh.CreateIcoSphere = (name52, options, scene) => {
  return CreateIcoSphere(name52, options, scene);
};

// node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js
var xpAxis = new Vector3(1, 0, 0);
var xnAxis = new Vector3(-1, 0, 0);
var ypAxis = new Vector3(0, 1, 0);
var ynAxis = new Vector3(0, -1, 0);
var zpAxis = new Vector3(0, 0, 1);
var znAxis = new Vector3(0, 0, -1);
var DecalVertex = class _DecalVertex {
  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {
    this.position = position;
    this.normal = normal;
    this.uv = uv;
    this.vertexIdx = vertexIdx;
    this.vertexIdxForBones = vertexIdxForBones;
    this.localPositionOverride = localPositionOverride;
    this.localNormalOverride = localNormalOverride;
    this.matrixIndicesOverride = matrixIndicesOverride;
    this.matrixWeightsOverride = matrixWeightsOverride;
  }
  clone() {
    var _a, _b, _c, _d;
    return new _DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, (_a = this.localPositionOverride) === null || _a === void 0 ? void 0 : _a.slice(), (_b = this.localNormalOverride) === null || _b === void 0 ? void 0 : _b.slice(), (_c = this.matrixIndicesOverride) === null || _c === void 0 ? void 0 : _c.slice(), (_d = this.matrixWeightsOverride) === null || _d === void 0 ? void 0 : _d.slice());
  }
};
function CreateDecal(name52, sourceMesh, options) {
  var _a, _b, _c, _d;
  const hasSkeleton = !!sourceMesh.skeleton;
  const useLocalComputation = options.localMode || hasSkeleton;
  const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== void 0;
  const indices = sourceMesh.getIndices();
  const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);
  const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);
  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;
  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;
  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);
  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;
  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;
  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
  const position = options.position || Vector3.Zero();
  let normal = options.normal || Vector3.Up();
  const size = options.size || Vector3.One();
  const angle = options.angle || 0;
  if (!normal) {
    const target = new Vector3(0, 0, 1);
    const camera = sourceMesh.getScene().activeCamera;
    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());
    normal = camera.globalPosition.subtract(cameraWorldTarget);
  }
  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
  const pitch = Math.atan2(normal.y, len);
  const vertexData = new VertexData();
  vertexData.indices = [];
  vertexData.positions = [];
  vertexData.normals = [];
  vertexData.uvs = [];
  vertexData.matricesIndices = hasSkeleton ? [] : null;
  vertexData.matricesWeights = hasSkeleton ? [] : null;
  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;
  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;
  let currentVertexDataIndex = 0;
  const extractDecalVector3 = (indexId, transformMatrix) => {
    const result = new DecalVertex();
    if (!indices || !positions || !normals) {
      return result;
    }
    const vertexId = indices[indexId];
    result.vertexIdx = vertexId * 3;
    result.vertexIdxForBones = vertexId * 4;
    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);
    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);
    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);
    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);
    if (options.captureUVS && uvs) {
      const v = uvs[vertexId * 2 + 1];
      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
    }
    return result;
  };
  const emptyArray = [0, 0, 0, 0];
  const clip = (vertices, axis) => {
    if (vertices.length === 0) {
      return vertices;
    }
    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));
    const indexOf = (arr, val, start, num) => {
      for (let i = 0; i < num; ++i) {
        if (arr[start + i] === val) {
          return start + i;
        }
      }
      return -1;
    };
    const clipVertices = (v0, v1) => {
      var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);
      let indices2 = emptyArray;
      let weights = emptyArray;
      if (matIndices && matWeights) {
        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;
        const v0Indices = (_a2 = v0.matrixIndicesOverride) !== null && _a2 !== void 0 ? _a2 : matIndices;
        const v0Weights = (_b2 = v0.matrixWeightsOverride) !== null && _b2 !== void 0 ? _b2 : matWeights;
        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;
        const v1Indices = (_c2 = v1.matrixIndicesOverride) !== null && _c2 !== void 0 ? _c2 : matIndices;
        const v1Weights = (_d2 = v1.matrixWeightsOverride) !== null && _d2 !== void 0 ? _d2 : matWeights;
        indices2 = [0, 0, 0, 0];
        weights = [0, 0, 0, 0];
        let index = 0;
        for (let i = 0; i < 4; ++i) {
          if (v0Weights[mat0Index + i] > 0) {
            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);
            indices2[index] = v0Indices[mat0Index + i];
            weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);
            index++;
          }
        }
        for (let i = 0; i < 4 && index < 4; ++i) {
          const ind = v1Indices[mat1Index + i];
          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1)
            continue;
          indices2[index] = ind;
          weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);
          index++;
        }
        const sumw = weights[0] + weights[1] + weights[2] + weights[3];
        weights[0] /= sumw;
        weights[1] /= sumw;
        weights[2] /= sumw;
        weights[3] /= sumw;
      }
      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (_e = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx]) !== null && _e !== void 0 ? _e : 0;
      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (_f = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 1]) !== null && _f !== void 0 ? _f : 0;
      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (_g = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 2]) !== null && _g !== void 0 ? _g : 0;
      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (_h = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx]) !== null && _h !== void 0 ? _h : 0;
      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (_j = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 1]) !== null && _j !== void 0 ? _j : 0;
      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (_k = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 2]) !== null && _k !== void 0 ? _k : 0;
      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (_l = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx]) !== null && _l !== void 0 ? _l : 0;
      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (_m = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 1]) !== null && _m !== void 0 ? _m : 0;
      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (_o = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 2]) !== null && _o !== void 0 ? _o : 0;
      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (_p = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx]) !== null && _p !== void 0 ? _p : 0;
      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (_q = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 1]) !== null && _q !== void 0 ? _q : 0;
      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (_r = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 2]) !== null && _r !== void 0 ? _r : 0;
      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;
      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;
      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;
      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);
      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [
        v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,
        v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,
        v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor
      ] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices2, weights);
    };
    let clipResult = null;
    if (vertices.length > 3) {
      clipResult = [];
    }
    for (let index = 0; index < vertices.length; index += 3) {
      let total = 0;
      let nV1 = null;
      let nV2 = null;
      let nV3 = null;
      let nV4 = null;
      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;
      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;
      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;
      const v1Out = d1 > 0;
      const v2Out = d2 > 0;
      const v3Out = d3 > 0;
      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
      switch (total) {
        case 0:
          if (vertices.length > 3) {
            clipResult.push(vertices[index]);
            clipResult.push(vertices[index + 1]);
            clipResult.push(vertices[index + 2]);
          } else {
            clipResult = vertices;
          }
          break;
        case 1:
          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();
          if (v1Out) {
            nV1 = vertices[index + 1];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index], nV1);
            nV4 = clipVertices(vertices[index], nV2);
          }
          if (v2Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index + 1], nV1);
            nV4 = clipVertices(vertices[index + 1], nV2);
            clipResult.push(nV3);
            clipResult.push(nV2.clone());
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3.clone());
            clipResult.push(nV4);
            break;
          }
          if (v3Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 1];
            nV3 = clipVertices(vertices[index + 2], nV1);
            nV4 = clipVertices(vertices[index + 2], nV2);
          }
          if (nV1 && nV2 && nV3 && nV4) {
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3);
            clipResult.push(nV4);
            clipResult.push(nV3.clone());
            clipResult.push(nV2.clone());
          }
          break;
        case 2:
          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();
          if (!v1Out) {
            nV1 = vertices[index].clone();
            nV2 = clipVertices(nV1, vertices[index + 1]);
            nV3 = clipVertices(nV1, vertices[index + 2]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v2Out) {
            nV1 = vertices[index + 1].clone();
            nV2 = clipVertices(nV1, vertices[index + 2]);
            nV3 = clipVertices(nV1, vertices[index]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v3Out) {
            nV1 = vertices[index + 2].clone();
            nV2 = clipVertices(nV1, vertices[index]);
            nV3 = clipVertices(nV1, vertices[index + 1]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          break;
        case 3:
          break;
      }
    }
    return clipResult;
  };
  const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;
  const matrixData = sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh._thinInstanceDataStorage.matrixData;
  const numMatrices = (sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh.thinInstanceCount) || 1;
  const thinInstanceMatrix = TmpVectors.Matrix[0];
  thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);
  for (let m = 0; m < numMatrices; ++m) {
    if ((sourceMeshAsMesh === null || sourceMeshAsMesh === void 0 ? void 0 : sourceMeshAsMesh.hasThinInstances) && matrixData) {
      const ofst = m * 16;
      thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);
      thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);
      thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);
      thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);
    }
    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));
    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);
    const meshWorldMatrix = sourceMesh.getWorldMatrix();
    const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);
    const oneFaceVertices = new Array(3);
    for (let index = 0; index < indices.length; index += 3) {
      let faceVertices = oneFaceVertices;
      faceVertices[0] = extractDecalVector3(index, transformMatrix);
      if (meshHasOverridenMaterial && useLocalComputation) {
        faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);
        faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);
      } else {
        faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);
        faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);
      }
      if (options.cullBackFaces) {
        if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {
          continue;
        }
      }
      faceVertices = clip(faceVertices, xpAxis);
      if (!faceVertices)
        continue;
      faceVertices = clip(faceVertices, xnAxis);
      if (!faceVertices)
        continue;
      faceVertices = clip(faceVertices, ypAxis);
      if (!faceVertices)
        continue;
      faceVertices = clip(faceVertices, ynAxis);
      if (!faceVertices)
        continue;
      faceVertices = clip(faceVertices, zpAxis);
      if (!faceVertices)
        continue;
      faceVertices = clip(faceVertices, znAxis);
      if (!faceVertices)
        continue;
      for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {
        const vertex = faceVertices[vIndex];
        vertexData.indices.push(currentVertexDataIndex);
        if (useLocalComputation) {
          if (vertex.localPositionOverride) {
            vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];
            vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];
            vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];
          } else if (localPositions) {
            vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];
            vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];
            vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];
          }
          if (vertex.localNormalOverride) {
            vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];
            vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];
            vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];
          } else if (localNormals) {
            vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];
            vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];
            vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];
          }
        } else {
          vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);
          vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);
        }
        if (vertexData.matricesIndices && vertexData.matricesWeights) {
          if (vertex.matrixIndicesOverride) {
            vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];
          } else {
            if (matIndices) {
              vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];
            }
            if (matIndicesExtra && vertexData.matricesIndicesExtra) {
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];
            }
          }
          if (vertex.matrixWeightsOverride) {
            vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];
          } else {
            if (matWeights) {
              vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];
            }
            if (matWeightsExtra && vertexData.matricesWeightsExtra) {
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];
            }
          }
        }
        if (!options.captureUVS) {
          vertexData.uvs.push(0.5 + vertex.position.x / size.x);
          const v = 0.5 + vertex.position.y / size.y;
          vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
        } else {
          vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);
        }
        currentVertexDataIndex++;
      }
    }
  }
  if (vertexData.indices.length === 0)
    vertexData.indices = null;
  if (vertexData.positions.length === 0)
    vertexData.positions = null;
  if (vertexData.normals.length === 0)
    vertexData.normals = null;
  if (vertexData.uvs.length === 0)
    vertexData.uvs = null;
  if (((_a = vertexData.matricesIndices) === null || _a === void 0 ? void 0 : _a.length) === 0)
    vertexData.matricesIndices = null;
  if (((_b = vertexData.matricesWeights) === null || _b === void 0 ? void 0 : _b.length) === 0)
    vertexData.matricesWeights = null;
  if (((_c = vertexData.matricesIndicesExtra) === null || _c === void 0 ? void 0 : _c.length) === 0)
    vertexData.matricesIndicesExtra = null;
  if (((_d = vertexData.matricesWeightsExtra) === null || _d === void 0 ? void 0 : _d.length) === 0)
    vertexData.matricesWeightsExtra = null;
  const decal = new Mesh(name52, sourceMesh.getScene());
  vertexData.applyToMesh(decal);
  if (useLocalComputation) {
    decal.skeleton = sourceMesh.skeleton;
    decal.parent = sourceMesh;
  } else {
    decal.position = position.clone();
    decal.rotation = new Vector3(pitch, yaw, angle);
  }
  decal.computeWorldMatrix(true);
  decal.refreshBoundingInfo(true, true);
  return decal;
}
var DecalBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateDecal
};
Mesh.CreateDecal = (name52, sourceMesh, position, normal, size, angle) => {
  const options = {
    position,
    normal,
    size,
    angle
  };
  return CreateDecal(name52, sourceMesh, options);
};

// node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js
function CreateCapsuleVertexData(options = {
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6
}) {
  const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1) | 0;
  const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3) | 0;
  const height = Math.max(options.height ? options.height : 1, 0);
  const radius = Math.max(options.radius ? options.radius : 0.25, 0);
  const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1) | 0;
  const radialSegments = tessellation;
  const heightSegments = subdivisions;
  const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);
  const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);
  const heightMinusCaps = height - (radiusTop + radiusBottom);
  const thetaStart = 0;
  const thetaLength = 2 * Math.PI;
  const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);
  const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);
  const alpha = Math.acos((radiusBottom - radiusTop) / height);
  let indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let index = 0;
  const indexArray = [], halfHeight = heightMinusCaps * 0.5;
  const pi2 = Math.PI * 0.5;
  let x, y;
  const normal = Vector3.Zero();
  const vertex = Vector3.Zero();
  const cosAlpha = Math.cos(alpha);
  const sinAlpha = Math.sin(alpha);
  const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();
  const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);
  let v = 0;
  for (y = 0; y <= capsTopSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha * (y / capsTopSegments);
    v += radiusTop * alpha / capsTopSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + sinA * radiusTop;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;
  const slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;
  for (y = 1; y <= heightSegments; y++) {
    const indexRow = [];
    v += coneLength / heightSegments;
    const _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(sinTheta, slope, cosTheta).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (y = 1; y <= capsBottomSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);
    v += radiusBottom * alpha / capsBottomSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusBottom;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = -halfHeight + sinA * radiusBottom;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (x = 0; x < radialSegments; x++) {
    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {
      const i1 = indexArray[y][x];
      const i2 = indexArray[y + 1][x];
      const i3 = indexArray[y + 1][x + 1];
      const i4 = indexArray[y][x + 1];
      indices.push(i1);
      indices.push(i2);
      indices.push(i4);
      indices.push(i2);
      indices.push(i3);
      indices.push(i4);
    }
  }
  indices = indices.reverse();
  if (options.orientation && !options.orientation.equals(Vector3.Up())) {
    const m = new Matrix();
    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);
    const v2 = Vector3.Zero();
    for (let i = 0; i < vertices.length; i += 3) {
      v2.set(vertices[i], vertices[i + 1], vertices[i + 2]);
      Vector3.TransformCoordinatesToRef(v2.clone(), m, v2);
      vertices[i] = v2.x;
      vertices[i + 1] = v2.y;
      vertices[i + 2] = v2.z;
    }
  }
  const vDat = new VertexData();
  vDat.positions = vertices;
  vDat.normals = normals;
  vDat.uvs = uvs;
  vDat.indices = indices;
  return vDat;
}
function CreateCapsule(name52, options = {
  orientation: Vector3.Up(),
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6,
  updatable: false
}, scene = null) {
  const capsule = new Mesh(name52, scene);
  const vertexData = CreateCapsuleVertexData(options);
  vertexData.applyToMesh(capsule, options.updatable);
  return capsule;
}
var CapsuleBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateCapsule
};
Mesh.CreateCapsule = (name52, options, scene) => {
  return CreateCapsule(name52, options, scene);
};
VertexData.CreateCapsule = CreateCapsuleVertexData;

// node_modules/@babylonjs/core/Maths/math.isovector.js
var _IsoVector = class __IsoVector {
  /**
   * Creates a new isovector from the given x and y coordinates
   * @param x defines the first coordinate, must be an integer
   * @param y defines the second coordinate, must be an integer
   */
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    if (x !== Math.floor(x)) {
      x === Math.floor(x);
      Logger.Warn("x is not an integer, floor(x) used");
    }
    if (y !== Math.floor(y)) {
      y === Math.floor(y);
      Logger.Warn("y is not an integer, floor(y) used");
    }
  }
  // Operators
  /**
   * Gets a new IsoVector copied from the IsoVector
   * @returns a new IsoVector
   */
  clone() {
    return new __IsoVector(this.x, this.y);
  }
  /**
   * Rotates one IsoVector 60 degrees counter clockwise about another
   * Please note that this is an in place operation
   * @param other an IsoVector a center of rotation
   * @returns the rotated IsoVector
   */
  rotate60About(other) {
    const x = this.x;
    this.x = other.x + other.y - this.y;
    this.y = x + this.y - other.x;
    return this;
  }
  /**
   * Rotates one IsoVector 60 degrees clockwise about another
   * Please note that this is an in place operation
   * @param other an IsoVector as center of rotation
   * @returns the rotated IsoVector
   */
  rotateNeg60About(other) {
    const x = this.x;
    this.x = x + this.y - other.y;
    this.y = other.x + other.y - x;
    return this;
  }
  /**
   * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)
   * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle
   * Please note that this is an in place operation
   * @param m integer a measure a Primary triangle of order (m, n) m > n
   * @param n >= 0 integer a measure for a Primary triangle of order (m, n)
   * @returns the rotated IsoVector
   */
  rotate120(m, n) {
    if (m !== Math.floor(m)) {
      m === Math.floor(m);
      Logger.Warn("m not an integer only floor(m) used");
    }
    if (n !== Math.floor(n)) {
      n === Math.floor(n);
      Logger.Warn("n not an integer only floor(n) used");
    }
    const x = this.x;
    this.x = m - x - this.y;
    this.y = n + x;
    return this;
  }
  /**
   * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)
   * Rotates one IsoVector 120 degrees clockwise about the center of the triangle
   * Please note that this is an in place operation
   * @param m integer a measure a Primary triangle of order (m, n) m > n
   * @param n >= 0 integer a measure for a Primary triangle of order (m, n)
   * @returns the rotated IsoVector
   */
  rotateNeg120(m, n) {
    if (m !== Math.floor(m)) {
      m === Math.floor(m);
      Logger.Warn("m is not an integer, floor(m) used");
    }
    if (n !== Math.floor(n)) {
      n === Math.floor(n);
      Logger.Warn("n is not an integer,   floor(n) used");
    }
    const x = this.x;
    this.x = this.y - n;
    this.y = m + n - x - this.y;
    return this;
  }
  /**
   * Transforms an IsoVector to one in Cartesian 3D space based on an isovector
   * @param origin an IsoVector
   * @param isoGridSize
   * @returns Point as a Vector3
   */
  toCartesianOrigin(origin, isoGridSize) {
    const point = Vector3.Zero();
    point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;
    point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;
    return point;
  }
  // Statics
  /**
   * Gets a new IsoVector(0, 0)
   * @returns a new IsoVector
   */
  static Zero() {
    return new __IsoVector(0, 0);
  }
};

// node_modules/@babylonjs/core/Meshes/geodesicMesh.js
var _PrimaryIsoTriangle = class {
  constructor() {
    this.cartesian = [];
    this.vertices = [];
    this.max = [];
    this.min = [];
    this.closestTo = [];
    this.innerFacets = [];
    this.isoVecsABOB = [];
    this.isoVecsOBOA = [];
    this.isoVecsBAOA = [];
    this.vertexTypes = [];
    this.IDATA = new PolyhedronData("icosahedron", "Regular", [
      [0, PHI, -1],
      [-PHI, 1, 0],
      [-1, 0, -PHI],
      [1, 0, -PHI],
      [PHI, 1, 0],
      [0, PHI, 1],
      [-1, 0, PHI],
      [-PHI, -1, 0],
      [0, -PHI, -1],
      [PHI, -1, 0],
      [1, 0, PHI],
      [0, -PHI, 1]
    ], [
      [0, 2, 1],
      [0, 3, 2],
      [0, 4, 3],
      [0, 5, 4],
      [0, 1, 5],
      [7, 6, 1],
      [8, 7, 2],
      [9, 8, 3],
      [10, 9, 4],
      [6, 10, 5],
      [2, 7, 1],
      [3, 8, 2],
      [4, 9, 3],
      [5, 10, 4],
      [1, 6, 5],
      [11, 6, 7],
      [11, 7, 8],
      [11, 8, 9],
      [11, 9, 10],
      [11, 10, 6]
    ]);
  }
  /**
   * Creates the PrimaryIsoTriangle Triangle OAB
   * @param m an integer
   * @param n an integer
   */
  //operators
  setIndices() {
    let indexCount = 12;
    const vecToidx = {};
    const m = this.m;
    const n = this.n;
    let g = m;
    let m1 = 1;
    let n1 = 0;
    if (n !== 0) {
      g = Scalar.HCF(m, n);
    }
    m1 = m / g;
    n1 = n / g;
    let fr;
    let rot;
    let O;
    let A;
    let B;
    const oVec = _IsoVector.Zero();
    const aVec = new _IsoVector(m, n);
    const bVec = new _IsoVector(-n, m + n);
    const oaVec = _IsoVector.Zero();
    const abVec = _IsoVector.Zero();
    const obVec = _IsoVector.Zero();
    let verts = [];
    let idx;
    let idxR;
    let isoId;
    let isoIdR;
    const closestTo = [];
    const vDist = this.vertByDist;
    const matchIdx = (f, fr2, isoId2, isoIdR2) => {
      idx = f + "|" + isoId2;
      idxR = fr2 + "|" + isoIdR2;
      if (!(idx in vecToidx || idxR in vecToidx)) {
        vecToidx[idx] = indexCount;
        vecToidx[idxR] = indexCount;
        indexCount++;
      } else if (idx in vecToidx && !(idxR in vecToidx)) {
        vecToidx[idxR] = vecToidx[idx];
      } else if (idxR in vecToidx && !(idx in vecToidx)) {
        vecToidx[idx] = vecToidx[idxR];
      }
      if (vDist[isoId2][0] > 2) {
        closestTo[vecToidx[idx]] = [-vDist[isoId2][0], vDist[isoId2][1], vecToidx[idx]];
      } else {
        closestTo[vecToidx[idx]] = [verts[vDist[isoId2][0]], vDist[isoId2][1], vecToidx[idx]];
      }
    };
    this.IDATA.edgematch = [
      [1, "B"],
      [2, "B"],
      [3, "B"],
      [4, "B"],
      [0, "B"],
      [10, "O", 14, "A"],
      [11, "O", 10, "A"],
      [12, "O", 11, "A"],
      [13, "O", 12, "A"],
      [14, "O", 13, "A"],
      [0, "O"],
      [1, "O"],
      [2, "O"],
      [3, "O"],
      [4, "O"],
      [19, "B", 5, "A"],
      [15, "B", 6, "A"],
      [16, "B", 7, "A"],
      [17, "B", 8, "A"],
      [18, "B", 9, "A"]
    ];
    for (let f = 0; f < 20; f++) {
      verts = this.IDATA.face[f];
      O = verts[2];
      A = verts[1];
      B = verts[0];
      isoId = oVec.x + "|" + oVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = O;
        closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      isoId = aVec.x + "|" + aVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = A;
        closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      isoId = bVec.x + "|" + bVec.y;
      idx = f + "|" + isoId;
      if (!(idx in vecToidx)) {
        vecToidx[idx] = B;
        closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];
      }
      fr = this.IDATA.edgematch[f][0];
      rot = this.IDATA.edgematch[f][1];
      if (rot === "B") {
        for (let i = 1; i < g; i++) {
          abVec.x = m - i * (m1 + n1);
          abVec.y = n + i * m1;
          obVec.x = -i * n1;
          obVec.y = i * (m1 + n1);
          isoId = abVec.x + "|" + abVec.y;
          isoIdR = obVec.x + "|" + obVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      if (rot === "O") {
        for (let i = 1; i < g; i++) {
          obVec.x = -i * n1;
          obVec.y = i * (m1 + n1);
          oaVec.x = i * m1;
          oaVec.y = i * n1;
          isoId = obVec.x + "|" + obVec.y;
          isoIdR = oaVec.x + "|" + oaVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      fr = this.IDATA.edgematch[f][2];
      rot = this.IDATA.edgematch[f][3];
      if (rot && rot === "A") {
        for (let i = 1; i < g; i++) {
          oaVec.x = i * m1;
          oaVec.y = i * n1;
          abVec.x = m - (g - i) * (m1 + n1);
          abVec.y = n + (g - i) * m1;
          isoId = oaVec.x + "|" + oaVec.y;
          isoIdR = abVec.x + "|" + abVec.y;
          matchIdx(f, fr, isoId, isoIdR);
        }
      }
      for (let i = 0; i < this.vertices.length; i++) {
        isoId = this.vertices[i].x + "|" + this.vertices[i].y;
        idx = f + "|" + isoId;
        if (!(idx in vecToidx)) {
          vecToidx[idx] = indexCount++;
          if (vDist[isoId][0] > 2) {
            closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];
          } else {
            closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];
          }
        }
      }
    }
    this.closestTo = closestTo;
    this.vecToidx = vecToidx;
  }
  calcCoeffs() {
    const m = this.m;
    const n = this.n;
    const thirdR3 = Math.sqrt(3) / 3;
    const LSQD = m * m + n * n + m * n;
    this.coau = (m + n) / LSQD;
    this.cobu = -n / LSQD;
    this.coav = -thirdR3 * (m - n) / LSQD;
    this.cobv = thirdR3 * (2 * m + n) / LSQD;
  }
  createInnerFacets() {
    const m = this.m;
    const n = this.n;
    for (let y = 0; y < n + m + 1; y++) {
      for (let x = this.min[y]; x < this.max[y] + 1; x++) {
        if (x < this.max[y] && x < this.max[y + 1] + 1) {
          this.innerFacets.push(["|" + x + "|" + y, "|" + x + "|" + (y + 1), "|" + (x + 1) + "|" + y]);
        }
        if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {
          this.innerFacets.push(["|" + x + "|" + y, "|" + (x + 1) + "|" + y, "|" + (x + 1) + "|" + (y - 1)]);
        }
      }
    }
  }
  edgeVecsABOB() {
    const m = this.m;
    const n = this.n;
    const B = new _IsoVector(-n, m + n);
    for (let y = 1; y < m + n; y++) {
      const point = new _IsoVector(this.min[y], y);
      const prev = new _IsoVector(this.min[y - 1], y - 1);
      const next = new _IsoVector(this.min[y + 1], y + 1);
      const pointR = point.clone();
      const prevR = prev.clone();
      const nextR = next.clone();
      pointR.rotate60About(B);
      prevR.rotate60About(B);
      nextR.rotate60About(B);
      const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);
      const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);
      const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);
      if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {
        if (pointR.x !== maxPrev.x) {
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);
        } else if (pointR.y === nextR.y) {
          this.vertexTypes.push([1, 1, 0]);
          this.isoVecsABOB.push([point, prev, maxPrev]);
          this.vertexTypes.push([1, 0, 1]);
          this.isoVecsABOB.push([point, maxPrev, next]);
        } else {
          this.vertexTypes.push([1, 1, 0]);
          this.isoVecsABOB.push([point, prev, maxPrev]);
          this.vertexTypes.push([1, 0, 0]);
          this.isoVecsABOB.push([point, maxPrev, maxPoint]);
        }
      }
    }
  }
  mapABOBtoOBOA() {
    const point = new _IsoVector(0, 0);
    for (let i = 0; i < this.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        point.x = this.isoVecsABOB[i][j].x;
        point.y = this.isoVecsABOB[i][j].y;
        if (this.vertexTypes[i][j] === 0) {
          point.rotateNeg120(this.m, this.n);
        }
        temp.push(point.clone());
      }
      this.isoVecsOBOA.push(temp);
    }
  }
  mapABOBtoBAOA() {
    const point = new _IsoVector(0, 0);
    for (let i = 0; i < this.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        point.x = this.isoVecsABOB[i][j].x;
        point.y = this.isoVecsABOB[i][j].y;
        if (this.vertexTypes[i][j] === 1) {
          point.rotate120(this.m, this.n);
        }
        temp.push(point.clone());
      }
      this.isoVecsBAOA.push(temp);
    }
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  MapToFace(faceNb, geodesicData) {
    const F = this.IDATA.face[faceNb];
    const oidx = F[2];
    const aidx = F[1];
    const bidx = F[0];
    const O = Vector3.FromArray(this.IDATA.vertex[oidx]);
    const A = Vector3.FromArray(this.IDATA.vertex[aidx]);
    const B = Vector3.FromArray(this.IDATA.vertex[bidx]);
    const OA = A.subtract(O);
    const OB = B.subtract(O);
    const x = OA.scale(this.coau).add(OB.scale(this.cobu));
    const y = OA.scale(this.coav).add(OB.scale(this.cobv));
    const mapped = [];
    let idx;
    let tempVec = TmpVectors.Vector3[0];
    for (let i = 0; i < this.cartesian.length; i++) {
      tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);
      mapped[i] = [tempVec.x, tempVec.y, tempVec.z];
      idx = faceNb + "|" + this.vertices[i].x + "|" + this.vertices[i].y;
      geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];
    }
  }
  //statics
  /**Creates a primary triangle
   * @internal
   */
  build(m, n) {
    const vertices = [];
    const O = _IsoVector.Zero();
    const A = new _IsoVector(m, n);
    const B = new _IsoVector(-n, m + n);
    vertices.push(O, A, B);
    for (let y2 = n; y2 < m + 1; y2++) {
      for (let x2 = 0; x2 < m + 1 - y2; x2++) {
        vertices.push(new _IsoVector(x2, y2));
      }
    }
    if (n > 0) {
      const g = Scalar.HCF(m, n);
      const m1 = m / g;
      const n1 = n / g;
      for (let i = 1; i < g; i++) {
        vertices.push(new _IsoVector(i * m1, i * n1));
        vertices.push(new _IsoVector(-i * n1, i * (m1 + n1)));
        vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1));
      }
      const ratio = m / n;
      for (let y2 = 1; y2 < n; y2++) {
        for (let x2 = 0; x2 < y2 * ratio; x2++) {
          vertices.push(new _IsoVector(x2, y2));
          vertices.push(new _IsoVector(x2, y2).rotate120(m, n));
          vertices.push(new _IsoVector(x2, y2).rotateNeg120(m, n));
        }
      }
    }
    vertices.sort((a, b) => {
      return a.x - b.x;
    });
    vertices.sort((a, b) => {
      return a.y - b.y;
    });
    const min = new Array(m + n + 1);
    const max = new Array(m + n + 1);
    for (let i = 0; i < min.length; i++) {
      min[i] = Infinity;
      max[i] = -Infinity;
    }
    let y = 0;
    let x = 0;
    const len = vertices.length;
    for (let i = 0; i < len; i++) {
      x = vertices[i].x;
      y = vertices[i].y;
      min[y] = Math.min(x, min[y]);
      max[y] = Math.max(x, max[y]);
    }
    const distFrom = (vert, primVert) => {
      const v = vert.clone();
      if (primVert === "A") {
        v.rotateNeg120(m, n);
      }
      if (primVert === "B") {
        v.rotate120(m, n);
      }
      if (v.x < 0) {
        return v.y;
      }
      return v.x + v.y;
    };
    const cartesian = [];
    const distFromO = [];
    const distFromA = [];
    const distFromB = [];
    const vertByDist = {};
    const vertData = [];
    let closest = -1;
    let dist = -1;
    for (let i = 0; i < len; i++) {
      cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);
      distFromO[i] = distFrom(vertices[i], "O");
      distFromA[i] = distFrom(vertices[i], "A");
      distFromB[i] = distFrom(vertices[i], "B");
      if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {
        closest = 3;
        dist = distFromO[i];
      } else if (distFromO[i] === distFromA[i]) {
        closest = 4;
        dist = distFromO[i];
      } else if (distFromA[i] === distFromB[i]) {
        closest = 5;
        dist = distFromA[i];
      } else if (distFromB[i] === distFromO[i]) {
        closest = 6;
        dist = distFromO[i];
      }
      if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {
        closest = 2;
        dist = distFromO[i];
      }
      if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {
        closest = 1;
        dist = distFromA[i];
      }
      if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {
        closest = 0;
        dist = distFromB[i];
      }
      vertData.push([closest, dist, vertices[i].x, vertices[i].y]);
    }
    vertData.sort((a, b) => {
      return a[2] - b[2];
    });
    vertData.sort((a, b) => {
      return a[3] - b[3];
    });
    vertData.sort((a, b) => {
      return a[1] - b[1];
    });
    vertData.sort((a, b) => {
      return a[0] - b[0];
    });
    for (let v = 0; v < vertData.length; v++) {
      vertByDist[vertData[v][2] + "|" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];
    }
    this.m = m;
    this.n = n;
    this.vertices = vertices;
    this.vertByDist = vertByDist;
    this.cartesian = cartesian;
    this.min = min;
    this.max = max;
    return this;
  }
};
var PolyhedronData = class {
  constructor(name52, category, vertex, face) {
    this.name = name52;
    this.category = category;
    this.vertex = vertex;
    this.face = face;
  }
};
var GeodesicData = class _GeodesicData extends PolyhedronData {
  /**
   * @internal
   */
  innerToData(face, primTri) {
    for (let i = 0; i < primTri.innerFacets.length; i++) {
      this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));
    }
  }
  /**
   * @internal
   */
  mapABOBtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][0];
    for (let i = 0; i < primTri.isoVecsABOB.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 0) {
          temp.push(faceNb + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  /**
   * @internal
   */
  mapOBOAtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][0];
    for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 1) {
          temp.push(faceNb + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  /**
   * @internal
   */
  mapBAOAtoDATA(faceNb, primTri) {
    const fr = primTri.IDATA.edgematch[faceNb][2];
    for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {
      const temp = [];
      for (let j = 0; j < 3; j++) {
        if (primTri.vertexTypes[i][j] === 1) {
          temp.push(faceNb + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
        } else {
          temp.push(fr + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
        }
      }
      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
    }
  }
  /**
   * @internal
   */
  orderData(primTri) {
    const nearTo = [];
    for (let i = 0; i < 13; i++) {
      nearTo[i] = [];
    }
    const close = primTri.closestTo;
    for (let i = 0; i < close.length; i++) {
      if (close[i][0] > -1) {
        if (close[i][1] > 0) {
          nearTo[close[i][0]].push([i, close[i][1]]);
        }
      } else {
        nearTo[12].push([i, close[i][0]]);
      }
    }
    const near = [];
    for (let i = 0; i < 12; i++) {
      near[i] = i;
    }
    let nearIndex = 12;
    for (let i = 0; i < 12; i++) {
      nearTo[i].sort((a, b) => {
        return a[1] - b[1];
      });
      for (let j = 0; j < nearTo[i].length; j++) {
        near[nearTo[i][j][0]] = nearIndex++;
      }
    }
    for (let j = 0; j < nearTo[12].length; j++) {
      near[nearTo[12][j][0]] = nearIndex++;
    }
    for (let i = 0; i < this.vertex.length; i++) {
      this.vertex[i].push(near[i]);
    }
    this.vertex.sort((a, b) => {
      return a[3] - b[3];
    });
    for (let i = 0; i < this.vertex.length; i++) {
      this.vertex[i].pop();
    }
    for (let i = 0; i < this.face.length; i++) {
      for (let j = 0; j < this.face[i].length; j++) {
        this.face[i][j] = near[this.face[i][j]];
      }
    }
    this.sharedNodes = nearTo[12].length;
    this.poleNodes = this.vertex.length - this.sharedNodes;
  }
  /**
   * @internal
   */
  setOrder(m, faces) {
    const adjVerts = [];
    const dualFaces = [];
    let face = faces.pop();
    dualFaces.push(face);
    let index = this.face[face].indexOf(m);
    index = (index + 2) % 3;
    let v = this.face[face][index];
    adjVerts.push(v);
    let f = 0;
    while (faces.length > 0) {
      face = faces[f];
      if (this.face[face].indexOf(v) > -1) {
        index = (this.face[face].indexOf(v) + 1) % 3;
        v = this.face[face][index];
        adjVerts.push(v);
        dualFaces.push(face);
        faces.splice(f, 1);
        f = 0;
      } else {
        f++;
      }
    }
    this.adjacentFaces.push(adjVerts);
    return dualFaces;
  }
  /**
   * @internal
   */
  toGoldbergPolyhedronData() {
    const goldbergPolyhedronData = new PolyhedronData("GeoDual", "Goldberg", [], []);
    goldbergPolyhedronData.name = "GD dual";
    const verticesNb = this.vertex.length;
    const map = new Array(verticesNb);
    for (let v = 0; v < verticesNb; v++) {
      map[v] = [];
    }
    for (let f = 0; f < this.face.length; f++) {
      for (let i = 0; i < 3; i++) {
        map[this.face[f][i]].push(f);
      }
    }
    let cx = 0;
    let cy = 0;
    let cz = 0;
    let face = [];
    let vertex = [];
    this.adjacentFaces = [];
    for (let m = 0; m < map.length; m++) {
      goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));
      map[m].forEach((el) => {
        cx = 0;
        cy = 0;
        cz = 0;
        face = this.face[el];
        for (let i = 0; i < 3; i++) {
          vertex = this.vertex[face[i]];
          cx += vertex[0];
          cy += vertex[1];
          cz += vertex[2];
        }
        goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];
      });
    }
    return goldbergPolyhedronData;
  }
  //statics
  /**Builds the data for a Geodesic Polyhedron from a primary triangle
   * @param primTri the primary triangle
   * @internal
   */
  static BuildGeodesicData(primTri) {
    const geodesicData = new _GeodesicData("Geodesic-m-n", "Geodesic", [
      [0, PHI, -1],
      [-PHI, 1, 0],
      [-1, 0, -PHI],
      [1, 0, -PHI],
      [PHI, 1, 0],
      [0, PHI, 1],
      [-1, 0, PHI],
      [-PHI, -1, 0],
      [0, -PHI, -1],
      [PHI, -1, 0],
      [1, 0, PHI],
      [0, -PHI, 1]
    ], []);
    primTri.setIndices();
    primTri.calcCoeffs();
    primTri.createInnerFacets();
    primTri.edgeVecsABOB();
    primTri.mapABOBtoOBOA();
    primTri.mapABOBtoBAOA();
    for (let f = 0; f < primTri.IDATA.face.length; f++) {
      primTri.MapToFace(f, geodesicData);
      geodesicData.innerToData(f, primTri);
      if (primTri.IDATA.edgematch[f][1] === "B") {
        geodesicData.mapABOBtoDATA(f, primTri);
      }
      if (primTri.IDATA.edgematch[f][1] === "O") {
        geodesicData.mapOBOAtoDATA(f, primTri);
      }
      if (primTri.IDATA.edgematch[f][3] === "A") {
        geodesicData.mapBAOAtoDATA(f, primTri);
      }
    }
    geodesicData.orderData(primTri);
    const radius = 1;
    geodesicData.vertex = geodesicData.vertex.map(function(el) {
      const a = el[0];
      const b = el[1];
      const c = el[2];
      const d = Math.sqrt(a * a + b * b + c * c);
      el[0] *= radius / d;
      el[1] *= radius / d;
      el[2] *= radius / d;
      return el;
    });
    return geodesicData;
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js
function CreateGeodesic(name52, options, scene = null) {
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m === Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n === Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const geoOptions = {
    custom: geodesicData,
    size: options.size,
    sizeX: options.sizeX,
    sizeY: options.sizeY,
    sizeZ: options.sizeZ,
    faceUV: options.faceUV,
    faceColors: options.faceColors,
    flat: options.flat,
    updatable: options.updatable,
    sideOrientation: options.sideOrientation,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  };
  const geodesic = CreatePolyhedron(name52, geoOptions, scene);
  return geodesic;
}

// node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js
function CreateGoldbergVertexData(options, goldbergData) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let v = 0; v < goldbergData.vertex.length; v++) {
    minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);
    maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);
    minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);
    maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);
  }
  let index = 0;
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    for (let v = 0; v < verts.length; v++) {
      normals.push(norm.x, norm.y, norm.z);
      const pdata = goldbergData.vertex[verts[v]];
      positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);
      const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);
      uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);
    }
    for (let v = 0; v < verts.length - 2; v++) {
      indices.push(index, index + v + 2, index + v + 1);
    }
    index += verts.length;
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGoldberg(name52, options, scene = null) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m === Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n === Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const goldbergData = geodesicData.toGoldbergPolyhedronData();
  const goldberg = new GoldbergMesh(name52, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  goldberg._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateGoldbergVertexData(options, goldbergData);
  vertexData.applyToMesh(goldberg, options.updatable);
  goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;
  goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;
  goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;
  goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;
  goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;
  for (let f = 0; f < geodesicData.vertex.length; f++) {
    goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));
    goldberg.goldbergData.faceCenters[f].x *= sizeX;
    goldberg.goldbergData.faceCenters[f].y *= sizeY;
    goldberg.goldbergData.faceCenters[f].z *= sizeZ;
    goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));
  }
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    const z = Vector3.Cross(ca, norm).normalize();
    goldberg.goldbergData.faceXaxis.push(ca.normalize());
    goldberg.goldbergData.faceYaxis.push(norm);
    goldberg.goldbergData.faceZaxis.push(z);
  }
  return goldberg;
}

// node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js
var ShapePath = class {
  /** Create the ShapePath used to support glyphs */
  constructor(resolution) {
    this._paths = [];
    this._tempPaths = [];
    this._holes = [];
    this._resolution = resolution;
  }
  /** Move the virtual cursor to a coordinate */
  moveTo(x, y) {
    this._currentPath = new Path2(x, y);
    this._tempPaths.push(this._currentPath);
  }
  /** Draw a line from the virtual cursor to a given coordinate */
  lineTo(x, y) {
    this._currentPath.addLineTo(x, y);
  }
  /** Create a quadratic curve from the virtual cursor to a given coordinate */
  quadraticCurveTo(cpx, cpy, x, y) {
    this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);
  }
  /** Create a bezier curve from the virtual cursor to a given coordinate */
  bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
    this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);
  }
  /** Extract holes based on CW / CCW */
  extractHoles() {
    for (const path of this._tempPaths) {
      if (path.area() > 0) {
        this._holes.push(path);
      } else {
        this._paths.push(path);
      }
    }
    if (!this._paths.length && this._holes.length) {
      const temp = this._holes;
      this._holes = this._paths;
      this._paths = temp;
    }
    this._tempPaths.length = 0;
  }
  /** Gets the list of paths */
  get paths() {
    return this._paths;
  }
  /** Gets the list of holes */
  get holes() {
    return this._holes;
  }
};
function CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData) {
  const glyph = fontData.glyphs[char] || fontData.glyphs["?"];
  if (!glyph) {
    return null;
  }
  const shapePath = new ShapePath(resolution);
  if (glyph.o) {
    const outline = glyph.o.split(" ");
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.moveTo(x, y);
          break;
        }
        case "l": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.lineTo(x, y);
          break;
        }
        case "q": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        }
        case "b": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          const cpx2 = parseInt(outline[i++]) * scale + offsetX;
          const cpy2 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
        }
      }
    }
  }
  shapePath.extractHoles();
  return { offsetX: glyph.ha * scale, shapePath };
}
function CreateTextShapePaths(text, size, resolution, fontData) {
  const chars = Array.from(text);
  const scale = size / fontData.resolution;
  const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;
  const shapePaths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);
      if (ret) {
        offsetX += ret.offsetX;
        shapePaths.push(ret.shapePath);
      }
    }
  }
  return shapePaths;
}
function CreateText(name52, text, fontData, options = {
  size: 50,
  resolution: 8,
  depth: 1
}, scene = null, earcutInjection = earcut) {
  var _a, _b;
  const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);
  const meshes = [];
  let letterIndex = 0;
  for (const shapePath of shapePaths) {
    if (!shapePath.paths.length) {
      continue;
    }
    const holes = shapePath.holes.slice();
    for (const path of shapePath.paths) {
      const holeVectors = [];
      const shapeVectors = [];
      const points = path.getPoints();
      for (const point of points) {
        shapeVectors.push(new Vector3(point.x, 0, point.y));
      }
      const localHolesCopy = holes.slice();
      for (const hole of localHolesCopy) {
        const points2 = hole.getPoints();
        let found = false;
        for (const point of points2) {
          if (path.isPointInside(point)) {
            found = true;
            break;
          }
        }
        if (!found) {
          continue;
        }
        const holePoints = [];
        for (const point of points2) {
          holePoints.push(new Vector3(point.x, 0, point.y));
        }
        holeVectors.push(holePoints);
        holes.splice(holes.indexOf(hole), 1);
      }
      if (!holeVectors.length && holes.length) {
        for (const hole of holes) {
          const points2 = hole.getPoints();
          const holePoints = [];
          for (const point of points2) {
            holePoints.push(new Vector3(point.x, 0, point.y));
          }
          holeVectors.push(holePoints);
        }
      }
      const mesh = ExtrudePolygon(name52, {
        shape: shapeVectors,
        holes: holeVectors.length ? holeVectors : void 0,
        depth: options.depth || 1,
        faceUV: options.faceUV || ((_a = options.perLetterFaceUV) === null || _a === void 0 ? void 0 : _a.call(options, letterIndex)),
        faceColors: options.faceColors || ((_b = options.perLetterFaceColors) === null || _b === void 0 ? void 0 : _b.call(options, letterIndex)),
        sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE)
      }, scene, earcutInjection);
      meshes.push(mesh);
      letterIndex++;
    }
  }
  const newMesh = Mesh.MergeMeshes(meshes, true, true);
  if (newMesh) {
    const bbox = newMesh.getBoundingInfo().boundingBox;
    newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2;
    newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2;
    newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z;
    newMesh.name = name52;
    const pivot = new TransformNode("pivot", scene);
    pivot.rotation.x = -Math.PI / 2;
    newMesh.parent = pivot;
    newMesh.bakeCurrentTransformIntoVertices();
    newMesh.parent = null;
    pivot.dispose();
  }
  return newMesh;
}

// node_modules/@babylonjs/core/Meshes/meshBuilder.js
var MeshBuilder = {
  CreateBox,
  CreateTiledBox,
  CreateSphere,
  CreateDisc,
  CreateIcoSphere,
  CreateRibbon,
  CreateCylinder,
  CreateTorus,
  CreateTorusKnot,
  CreateLineSystem,
  CreateLines,
  CreateDashedLines,
  ExtrudeShape,
  ExtrudeShapeCustom,
  CreateLathe,
  CreateTiledPlane,
  CreatePlane,
  CreateGround,
  CreateTiledGround,
  CreateGroundFromHeightMap,
  CreatePolygon,
  ExtrudePolygon,
  CreateTube,
  CreatePolyhedron,
  CreateGeodesic,
  CreateGoldberg,
  CreateDecal,
  CreateCapsule,
  CreateText
};

// node_modules/@babylonjs/core/Meshes/meshSimplification.js
var SimplificationSettings = class {
  /**
   * Creates a SimplificationSettings
   * @param quality expected quality
   * @param distance distance when this optimized version should be used
   * @param optimizeMesh already optimized mesh
   */
  constructor(quality, distance, optimizeMesh) {
    this.quality = quality;
    this.distance = distance;
    this.optimizeMesh = optimizeMesh;
  }
};
var SimplificationQueue = class {
  /**
   * Creates a new queue
   */
  constructor() {
    this.running = false;
    this._simplificationArray = [];
  }
  /**
   * Adds a new simplification task
   * @param task defines a task to add
   */
  addTask(task) {
    this._simplificationArray.push(task);
  }
  /**
   * Execute next task
   */
  executeNext() {
    const task = this._simplificationArray.pop();
    if (task) {
      this.running = true;
      this.runSimplification(task);
    } else {
      this.running = false;
    }
  }
  /**
   * Execute a simplification task
   * @param task defines the task to run
   */
  runSimplification(task) {
    if (task.parallelProcessing) {
      task.settings.forEach((setting) => {
        const simplifier = this._getSimplifier(task);
        simplifier.simplify(setting, (newMesh) => {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {
            task.successCallback();
          }
          this.executeNext();
        });
      });
    } else {
      const simplifier = this._getSimplifier(task);
      const runDecimation = (setting, callback) => {
        simplifier.simplify(setting, (newMesh) => {
          if (setting.distance !== void 0) {
            task.mesh.addLODLevel(setting.distance, newMesh);
          }
          newMesh.isVisible = true;
          callback();
        });
      };
      AsyncLoop.Run(task.settings.length, (loop) => {
        runDecimation(task.settings[loop.index], () => {
          loop.executeNext();
        });
      }, () => {
        if (task.successCallback) {
          task.successCallback();
        }
        this.executeNext();
      });
    }
  }
  _getSimplifier(task) {
    switch (task.simplificationType) {
      case SimplificationType.QUADRATIC:
      default:
        return new QuadraticErrorSimplification(task.mesh);
    }
  }
};
var SimplificationType;
(function(SimplificationType2) {
  SimplificationType2[SimplificationType2["QUADRATIC"] = 0] = "QUADRATIC";
})(SimplificationType || (SimplificationType = {}));
var DecimationTriangle = class {
  constructor(_vertices) {
    this._vertices = _vertices;
    this.error = new Array(4);
    this.deleted = false;
    this.isDirty = false;
    this.deletePending = false;
    this.borderFactor = 0;
  }
};
var DecimationVertex = class {
  constructor(position, id) {
    this.position = position;
    this.id = id;
    this.isBorder = true;
    this.q = new QuadraticMatrix();
    this.triangleCount = 0;
    this.triangleStart = 0;
    this.originalOffsets = [];
  }
  updatePosition(newPosition) {
    this.position.copyFrom(newPosition);
  }
};
var QuadraticMatrix = class _QuadraticMatrix {
  constructor(data) {
    this.data = new Array(10);
    for (let i = 0; i < 10; ++i) {
      if (data && data[i]) {
        this.data[i] = data[i];
      } else {
        this.data[i] = 0;
      }
    }
  }
  det(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
    const det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];
    return det;
  }
  addInPlace(matrix) {
    for (let i = 0; i < 10; ++i) {
      this.data[i] += matrix.data[i];
    }
  }
  addArrayInPlace(data) {
    for (let i = 0; i < 10; ++i) {
      this.data[i] += data[i];
    }
  }
  add(matrix) {
    const m = new _QuadraticMatrix();
    for (let i = 0; i < 10; ++i) {
      m.data[i] = this.data[i] + matrix.data[i];
    }
    return m;
  }
  static FromData(a, b, c, d) {
    return new _QuadraticMatrix(_QuadraticMatrix.DataFromNumbers(a, b, c, d));
  }
  //returning an array to avoid garbage collection
  static DataFromNumbers(a, b, c, d) {
    return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];
  }
};
var Reference = class {
  constructor(vertexId, triangleId) {
    this.vertexId = vertexId;
    this.triangleId = triangleId;
  }
};
var QuadraticErrorSimplification = class {
  /**
   * Creates a new QuadraticErrorSimplification
   * @param _mesh defines the target mesh
   */
  constructor(_mesh) {
    this._mesh = _mesh;
    this.syncIterations = 5e3;
    this.aggressiveness = 7;
    this.decimationIterations = 100;
    this.boundingBoxEpsilon = Epsilon;
  }
  /**
   * Simplification of a given mesh according to the given settings.
   * Since this requires computation, it is assumed that the function runs async.
   * @param settings The settings of the simplification, including quality and distance
   * @param successCallback A callback that will be called after the mesh was simplified.
   */
  simplify(settings, successCallback) {
    this._initDecimatedMesh();
    AsyncLoop.Run(this._mesh.subMeshes.length, (loop) => {
      this._initWithMesh(loop.index, () => {
        this._runDecimation(settings, loop.index, () => {
          loop.executeNext();
        });
      }, settings.optimizeMesh);
    }, () => {
      setTimeout(() => {
        successCallback(this._reconstructedMesh);
      }, 0);
    });
  }
  _runDecimation(settings, submeshIndex, successCallback) {
    const targetCount = ~~(this._triangles.length * settings.quality);
    let deletedTriangles = 0;
    const triangleCount = this._triangles.length;
    const iterationFunction = (iteration, callback) => {
      setTimeout(() => {
        if (iteration % 5 === 0) {
          this._updateMesh(iteration === 0);
        }
        for (let i = 0; i < this._triangles.length; ++i) {
          this._triangles[i].isDirty = false;
        }
        const threshold = 1e-9 * Math.pow(iteration + 3, this.aggressiveness);
        const trianglesIterator = (i) => {
          const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);
          const t = this._triangles[tIdx];
          if (!t) {
            return;
          }
          if (t.error[3] > threshold || t.deleted || t.isDirty) {
            return;
          }
          for (let j = 0; j < 3; ++j) {
            if (t.error[j] < threshold) {
              const deleted0 = [];
              const deleted1 = [];
              const v0 = t._vertices[j];
              const v1 = t._vertices[(j + 1) % 3];
              if (v0.isBorder || v1.isBorder) {
                continue;
              }
              const p = Vector3.Zero();
              this._calculateError(v0, v1, p);
              const delTr = [];
              if (this._isFlipped(v0, v1, p, deleted0, delTr)) {
                continue;
              }
              if (this._isFlipped(v1, v0, p, deleted1, delTr)) {
                continue;
              }
              if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {
                continue;
              }
              const uniqueArray = [];
              delTr.forEach((deletedT) => {
                if (uniqueArray.indexOf(deletedT) === -1) {
                  deletedT.deletePending = true;
                  uniqueArray.push(deletedT);
                }
              });
              if (uniqueArray.length % 2 !== 0) {
                continue;
              }
              v0.q = v1.q.add(v0.q);
              v0.updatePosition(p);
              const tStart = this._references.length;
              deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);
              deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);
              const tCount = this._references.length - tStart;
              if (tCount <= v0.triangleCount) {
                if (tCount) {
                  for (let c = 0; c < tCount; c++) {
                    this._references[v0.triangleStart + c] = this._references[tStart + c];
                  }
                }
              } else {
                v0.triangleStart = tStart;
              }
              v0.triangleCount = tCount;
              break;
            }
          }
        };
        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, () => {
          return triangleCount - deletedTriangles <= targetCount;
        });
      }, 0);
    };
    AsyncLoop.Run(this.decimationIterations, (loop) => {
      if (triangleCount - deletedTriangles <= targetCount) {
        loop.breakLoop();
      } else {
        iterationFunction(loop.index, () => {
          loop.executeNext();
        });
      }
    }, () => {
      setTimeout(() => {
        this._reconstructMesh(submeshIndex);
        successCallback();
      }, 0);
    });
  }
  _initWithMesh(submeshIndex, callback, optimizeMesh) {
    this._vertices = [];
    this._triangles = [];
    const positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);
    const indices = this._mesh.getIndices();
    const submesh = this._mesh.subMeshes[submeshIndex];
    const findInVertices = (positionToSearch) => {
      if (optimizeMesh) {
        for (let ii = 0; ii < this._vertices.length; ++ii) {
          if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 1e-4)) {
            return this._vertices[ii];
          }
        }
      }
      return null;
    };
    const vertexReferences = [];
    const vertexInit = (i) => {
      if (!positionData) {
        return;
      }
      const offset = i + submesh.verticesStart;
      const position = Vector3.FromArray(positionData, offset * 3);
      const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);
      vertex.originalOffsets.push(offset);
      if (vertex.id === this._vertices.length) {
        this._vertices.push(vertex);
      }
      vertexReferences.push(vertex.id);
    };
    const totalVertices = submesh.verticesCount;
    AsyncLoop.SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, () => {
      const indicesInit = (i) => {
        if (!indices) {
          return;
        }
        const offset = submesh.indexStart / 3 + i;
        const pos = offset * 3;
        const i0 = indices[pos + 0];
        const i1 = indices[pos + 1];
        const i2 = indices[pos + 2];
        const v0 = this._vertices[vertexReferences[i0 - submesh.verticesStart]];
        const v1 = this._vertices[vertexReferences[i1 - submesh.verticesStart]];
        const v2 = this._vertices[vertexReferences[i2 - submesh.verticesStart]];
        const triangle = new DecimationTriangle([v0, v1, v2]);
        triangle.originalOffset = pos;
        this._triangles.push(triangle);
      };
      AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, () => {
        this._init(callback);
      });
    });
  }
  _init(callback) {
    const triangleInit1 = (i) => {
      const t = this._triangles[i];
      t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();
      for (let j = 0; j < 3; j++) {
        t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));
      }
    };
    AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, () => {
      const triangleInit2 = (i) => {
        const t = this._triangles[i];
        for (let j = 0; j < 3; ++j) {
          t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);
        }
        t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      };
      AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, () => {
        callback();
      });
    });
  }
  _reconstructMesh(submeshIndex) {
    const newTriangles = [];
    let i;
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleCount = 0;
    }
    let t;
    let j;
    for (i = 0; i < this._triangles.length; ++i) {
      if (!this._triangles[i].deleted) {
        t = this._triangles[i];
        for (j = 0; j < 3; ++j) {
          t._vertices[j].triangleCount = 1;
        }
        newTriangles.push(t);
      }
    }
    const newPositionData = this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || [];
    const newNormalData = this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || [];
    const newUVsData = this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || [];
    const newColorsData = this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || [];
    const normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);
    const uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);
    const colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);
    let vertexCount = 0;
    for (i = 0; i < this._vertices.length; ++i) {
      const vertex = this._vertices[i];
      vertex.id = vertexCount;
      if (vertex.triangleCount) {
        vertex.originalOffsets.forEach((originalOffset) => {
          newPositionData.push(vertex.position.x);
          newPositionData.push(vertex.position.y);
          newPositionData.push(vertex.position.z);
          if (normalData && normalData.length) {
            newNormalData.push(normalData[originalOffset * 3]);
            newNormalData.push(normalData[originalOffset * 3 + 1]);
            newNormalData.push(normalData[originalOffset * 3 + 2]);
          }
          if (uvs && uvs.length) {
            newUVsData.push(uvs[originalOffset * 2]);
            newUVsData.push(uvs[originalOffset * 2 + 1]);
          }
          if (colorsData && colorsData.length) {
            newColorsData.push(colorsData[originalOffset * 4]);
            newColorsData.push(colorsData[originalOffset * 4 + 1]);
            newColorsData.push(colorsData[originalOffset * 4 + 2]);
            newColorsData.push(colorsData[originalOffset * 4 + 3]);
          }
          ++vertexCount;
        });
      }
    }
    const startingIndex = this._reconstructedMesh.getTotalIndices();
    const startingVertex = this._reconstructedMesh.getTotalVertices();
    const submeshesArray = this._reconstructedMesh.subMeshes;
    this._reconstructedMesh.subMeshes = [];
    const newIndicesArray = this._reconstructedMesh.getIndices();
    const originalIndices = this._mesh.getIndices();
    for (i = 0; i < newTriangles.length; ++i) {
      t = newTriangles[i];
      [0, 1, 2].forEach((idx) => {
        const id = originalIndices[t.originalOffset + idx];
        let offset = t._vertices[idx].originalOffsets.indexOf(id);
        if (offset < 0) {
          offset = 0;
        }
        newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);
      });
    }
    this._reconstructedMesh.setIndices(newIndicesArray);
    this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);
    if (newNormalData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);
    }
    if (newUVsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);
    }
    if (newColorsData.length > 0) {
      this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);
    }
    const originalSubmesh = this._mesh.subMeshes[submeshIndex];
    if (submeshIndex > 0) {
      this._reconstructedMesh.subMeshes = [];
      submeshesArray.forEach((submesh) => {
        SubMesh.AddToMesh(
          submesh.materialIndex,
          submesh.verticesStart,
          submesh.verticesCount,
          /* 0, newPositionData.length/3, */
          submesh.indexStart,
          submesh.indexCount,
          submesh.getMesh()
        );
      });
      SubMesh.AddToMesh(
        originalSubmesh.materialIndex,
        startingVertex,
        vertexCount,
        /* 0, newPositionData.length / 3, */
        startingIndex,
        newTriangles.length * 3,
        this._reconstructedMesh
      );
    }
  }
  _initDecimatedMesh() {
    this._reconstructedMesh = new Mesh(this._mesh.name + "Decimated", this._mesh.getScene());
    this._reconstructedMesh.material = this._mesh.material;
    this._reconstructedMesh.parent = this._mesh.parent;
    this._reconstructedMesh.isVisible = false;
    this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;
  }
  _isFlipped(vertex1, vertex2, point, deletedArray, delTr) {
    for (let i = 0; i < vertex1.triangleCount; ++i) {
      const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];
      if (t.deleted) {
        continue;
      }
      const s = this._references[vertex1.triangleStart + i].vertexId;
      const v1 = t._vertices[(s + 1) % 3];
      const v2 = t._vertices[(s + 2) % 3];
      if (v1 === vertex2 || v2 === vertex2) {
        deletedArray[i] = true;
        delTr.push(t);
        continue;
      }
      let d1 = v1.position.subtract(point);
      d1 = d1.normalize();
      let d2 = v2.position.subtract(point);
      d2 = d2.normalize();
      if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {
        return true;
      }
      const normal = Vector3.Cross(d1, d2).normalize();
      deletedArray[i] = false;
      if (Vector3.Dot(normal, t.normal) < 0.2) {
        return true;
      }
    }
    return false;
  }
  _updateTriangles(origVertex, vertex, deletedArray, deletedTriangles) {
    let newDeleted = deletedTriangles;
    for (let i = 0; i < vertex.triangleCount; ++i) {
      const ref = this._references[vertex.triangleStart + i];
      const t = this._triangles[ref.triangleId];
      if (t.deleted) {
        continue;
      }
      if (deletedArray[i] && t.deletePending) {
        t.deleted = true;
        newDeleted++;
        continue;
      }
      t._vertices[ref.vertexId] = origVertex;
      t.isDirty = true;
      t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;
      t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;
      t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;
      t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
      this._references.push(ref);
    }
    return newDeleted;
  }
  _identifyBorder() {
    for (let i = 0; i < this._vertices.length; ++i) {
      const vCount = [];
      const vId = [];
      const v = this._vertices[i];
      let j;
      for (j = 0; j < v.triangleCount; ++j) {
        const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];
        for (let ii = 0; ii < 3; ii++) {
          let ofs = 0;
          const vv = triangle._vertices[ii];
          while (ofs < vCount.length) {
            if (vId[ofs] === vv.id) {
              break;
            }
            ++ofs;
          }
          if (ofs === vCount.length) {
            vCount.push(1);
            vId.push(vv.id);
          } else {
            vCount[ofs]++;
          }
        }
      }
      for (j = 0; j < vCount.length; ++j) {
        if (vCount[j] === 1) {
          this._vertices[vId[j]].isBorder = true;
        } else {
          this._vertices[vId[j]].isBorder = false;
        }
      }
    }
  }
  _updateMesh(identifyBorders = false) {
    let i;
    if (!identifyBorders) {
      const newTrianglesVector = [];
      for (i = 0; i < this._triangles.length; ++i) {
        if (!this._triangles[i].deleted) {
          newTrianglesVector.push(this._triangles[i]);
        }
      }
      this._triangles = newTrianglesVector;
    }
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleCount = 0;
      this._vertices[i].triangleStart = 0;
    }
    let t;
    let j;
    let v;
    for (i = 0; i < this._triangles.length; ++i) {
      t = this._triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t._vertices[j];
        v.triangleCount++;
      }
    }
    let tStart = 0;
    for (i = 0; i < this._vertices.length; ++i) {
      this._vertices[i].triangleStart = tStart;
      tStart += this._vertices[i].triangleCount;
      this._vertices[i].triangleCount = 0;
    }
    const newReferences = new Array(this._triangles.length * 3);
    for (i = 0; i < this._triangles.length; ++i) {
      t = this._triangles[i];
      for (j = 0; j < 3; ++j) {
        v = t._vertices[j];
        newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);
        v.triangleCount++;
      }
    }
    this._references = newReferences;
    if (identifyBorders) {
      this._identifyBorder();
    }
  }
  _vertexError(q, point) {
    const x = point.x;
    const y = point.y;
    const z = point.z;
    return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];
  }
  _calculateError(vertex1, vertex2, pointResult) {
    const q = vertex1.q.add(vertex2.q);
    const border = vertex1.isBorder && vertex2.isBorder;
    let error = 0;
    const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
    if (qDet !== 0 && !border) {
      if (!pointResult) {
        pointResult = Vector3.Zero();
      }
      pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);
      pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);
      pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);
      error = this._vertexError(q, pointResult);
    } else {
      const p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));
      const error1 = this._vertexError(q, vertex1.position);
      const error2 = this._vertexError(q, vertex2.position);
      const error3 = this._vertexError(q, p3);
      error = Math.min(error1, error2, error3);
      if (error === error1) {
        if (pointResult) {
          pointResult.copyFrom(vertex1.position);
        }
      } else if (error === error2) {
        if (pointResult) {
          pointResult.copyFrom(vertex2.position);
        }
      } else {
        if (pointResult) {
          pointResult.copyFrom(p3);
        }
      }
    }
    return error;
  }
};

// node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js
Object.defineProperty(Scene.prototype, "simplificationQueue", {
  get: function() {
    if (!this._simplificationQueue) {
      this._simplificationQueue = new SimplificationQueue();
      let component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);
      if (!component) {
        component = new SimplicationQueueSceneComponent(this);
        this._addComponent(component);
      }
    }
    return this._simplificationQueue;
  },
  set: function(value) {
    this._simplificationQueue = value;
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype.simplify = function(settings, parallelProcessing = true, simplificationType = SimplificationType.QUADRATIC, successCallback) {
  this.getScene().simplificationQueue.addTask({
    settings,
    parallelProcessing,
    mesh: this,
    simplificationType,
    successCallback
  });
  return this;
};
var SimplicationQueueSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;
    this.scene = scene;
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources
   */
  dispose() {
  }
  _beforeCameraUpdate() {
    if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {
      this.scene._simplificationQueue.executeNext();
    }
  }
};

// node_modules/@babylonjs/core/Meshes/subMesh.project.js
SubMesh.prototype._projectOnTrianglesToRef = function(vector, positions, indices, step, checkStopper, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
    const indexA = indices[index];
    const indexB = indices[index + 1];
    const indexC = indices[index + 2];
    if (checkStopper && indexC === 4294967295) {
      index += 2;
      continue;
    }
    const p0 = positions[indexA];
    const p1 = positions[indexB];
    const p2 = positions[indexC];
    if (!p0 || !p1 || !p2) {
      continue;
    }
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype._projectOnUnIndexedTrianglesToRef = function(vector, positions, indices, ref) {
  const proj = TmpVectors.Vector3[0];
  const tmp = TmpVectors.Vector3[1];
  let distance = Infinity;
  for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
    const p0 = positions[index];
    const p1 = positions[index + 1];
    const p2 = positions[index + 2];
    const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
    if (tmpDist < distance) {
      proj.copyFrom(tmp);
      distance = tmpDist;
    }
  }
  ref.copyFrom(proj);
  return distance;
};
SubMesh.prototype.projectToRef = function(vector, positions, indices, ref) {
  const material = this.getMaterial();
  if (!material) {
    return -1;
  }
  let step = 3;
  let checkStopper = false;
  switch (material.fillMode) {
    case 3:
    case 5:
    case 6:
    case 8:
      return -1;
    case 7:
      step = 1;
      checkStopper = true;
      break;
    default:
      break;
  }
  if (material.fillMode === 4) {
    return -1;
  } else {
    if (!indices.length && this._mesh._unIndexed) {
      return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);
    }
    return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js
function CreateHemisphere(name52, options = {}, scene) {
  if (!options.diameter) {
    options.diameter = 1;
  }
  if (!options.segments) {
    options.segments = 16;
  }
  const halfSphere = CreateSphere("", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);
  const disc = CreateDisc("", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);
  disc.rotation.x = -Math.PI / 2;
  disc.parent = halfSphere;
  const merged = Mesh.MergeMeshes([disc, halfSphere], true);
  merged.name = name52;
  return merged;
}
var HemisphereBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateHemisphere
};
Mesh.CreateHemisphere = (name52, segments, diameter, scene) => {
  const options = {
    segments,
    diameter
  };
  return CreateHemisphere(name52, options, scene);
};

// node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js
var name9 = "rgbdDecodePixelShader";
var shader9 = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;
ShaderStore.ShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  const rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  const passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.getEffect().executeWhenCompiled(() => {
    passPostProcess.onApply = function(effect) {
      effect.setTexture("textureSampler", texture);
    };
    const internalTexture = rtt.renderTarget;
    if (internalTexture) {
      scene.postProcessManager.directRender([passPostProcess], internalTexture);
      engine.unBindFramebuffer(internalTexture);
      rtt.disposeFramebufferObjects();
      passPostProcess.dispose();
      rtt.getInternalTexture().isReady = true;
    }
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
  const engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;
  type = type !== null && type !== void 0 ? type : internalTexture.type;
  format = format !== null && format !== void 0 ? format : internalTexture.format;
  width = width !== null && width !== void 0 ? width : internalTexture.width;
  height = height !== null && height !== void 0 ? height : internalTexture.height;
  if (type === -1) {
    type = 0;
  }
  return new Promise((resolve) => {
    const postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    const encodedTexture = engine.createRenderTargetTexture({ width, height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.getEffect().executeWhenCompiled(() => {
      postProcess.onApply = (effect) => {
        effect._bindTexture("textureSampler", internalTexture);
        effect.setFloat2("scale", 1, 1);
      };
      scene.postProcessManager.directRender([postProcess], encodedTexture, true);
      engine.restoreDefaultFramebuffer();
      engine._releaseTexture(internalTexture);
      if (postProcess) {
        postProcess.dispose();
      }
      encodedTexture._swapAndDie(internalTexture);
      internalTexture.type = type;
      internalTexture.format = 5;
      internalTexture.isReady = true;
      resolve(internalTexture);
    });
  });
}
var floatView;
var int32View;
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  const s = (value & 32768) >> 15;
  const e = (value & 31744) >> 10;
  const f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var ProcessAsync = async (texture, width, height, face, lod) => {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  let lodPostProcess;
  if (!texture.isCube) {
    lodPostProcess = new PostProcess("lod", "lod", ["lod", "gamma"], null, 1, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);
  } else {
    const faceDefines = ["#define POSITIVEX", "#define NEGATIVEX", "#define POSITIVEY", "#define NEGATIVEY", "#define POSITIVEZ", "#define NEGATIVEZ"];
    lodPostProcess = new PostProcess("lodCube", "lodCube", ["lod", "gamma"], null, 1, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);
  }
  await new Promise((resolve) => {
    lodPostProcess.getEffect().executeWhenCompiled(() => {
      resolve(0);
    });
  });
  const rtt = new RenderTargetTexture("temp", { width, height }, scene, false);
  lodPostProcess.onApply = function(effect) {
    effect.setTexture("textureSampler", texture);
    effect.setFloat("lod", lod);
    effect.setBool("gamma", texture.gammaSpace);
  };
  const internalTexture = texture.getInternalTexture();
  try {
    if (rtt.renderTarget && internalTexture) {
      const samplingMode = internalTexture.samplingMode;
      if (lod !== 0) {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);
      } else {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST);
      }
      scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);
      texture.updateSamplingMode(samplingMode);
      const bufferView = await engine.readPixels(0, 0, width, height);
      const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
      engine.unBindFramebuffer(rtt.renderTarget);
      return data;
    } else {
      throw Error("Render to texture failed.");
    }
  } finally {
    rtt.dispose();
    lodPostProcess.dispose();
  }
};
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
  if (!texture.isReady() && texture._texture) {
    await new Promise((resolve, reject) => {
      if (texture._texture === null) {
        reject(0);
        return;
      }
      texture._texture.onLoadedObservable.addOnce(() => {
        resolve(0);
      });
    });
  }
  return await ProcessAsync(texture, width, height, face, lod);
}
var TextureTools = {
  /**
   * Uses the GPU to create a copy texture rescaled at a given size
   * @param texture Texture to copy from
   * @param width defines the desired width
   * @param height defines the desired height
   * @param useBilinearMode defines if bilinear mode has to be used
   * @returns the generated texture
   */
  CreateResizedCopy,
  /**
   * Apply a post process to a texture
   * @param postProcessName name of the fragment post process
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param type type of the output texture. If not provided, use the one from internalTexture
   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
   * @param format format of the output texture. If not provided, use the one from internalTexture
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  ApplyPostProcess,
  /**
   * Converts a number to half float
   * @param value number to convert
   * @returns converted number
   */
  ToHalfFloat,
  /**
   * Converts a half float to a number
   * @param value half float to convert
   * @returns converted half float
   */
  FromHalfFloat,
  /**
   * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
   * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
   * @param texture the source texture
   * @param width the width of the result, which does not have to match the source texture width
   * @param height the height of the result, which does not have to match the source texture height
   * @param face if the texture has multiple faces, the face index to use for the source
   * @param channels a filter for which of the RGBA channels to return in the result
   * @param lod if the texture has multiple LODs, the lod index to use for the source
   * @returns the 8-bit texture data
   */
  GetTextureDataAsync
};

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = class {
  /**
   * Expand the RGBD Texture from RGBD to Half Float if possible.
   * @param texture the texture to expand.
   */
  static ExpandRGBDTexture(texture) {
    const internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    const engine = internalTexture.getEngine();
    const caps = engine.getCaps();
    const isReady = internalTexture.isReady;
    let expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    const expandRGBDTexture = () => {
      if (expandTexture) {
        const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false);
        rgbdPostProcess.externalTextureSamplerBinding = true;
        const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
          generateDepthBuffer: false,
          generateMipMaps: false,
          generateStencilBuffer: false,
          samplingMode: internalTexture.samplingMode,
          type: internalTexture.type,
          format: 5
        });
        rgbdPostProcess.getEffect().executeWhenCompiled(() => {
          rgbdPostProcess.onApply = (effect) => {
            effect._bindTexture("textureSampler", internalTexture);
            effect.setFloat2("scale", 1, 1);
          };
          texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
          engine.restoreDefaultFramebuffer();
          engine._releaseTexture(internalTexture);
          if (rgbdPostProcess) {
            rgbdPostProcess.dispose();
          }
          expandedTexture._swapAndDie(internalTexture);
          internalTexture.isReady = true;
        });
      }
    };
    if (isReady) {
      expandRGBDTexture();
    } else {
      texture.onLoadObservable.addOnce(expandRGBDTexture);
    }
  }
  /**
   * Encode the texture to RGBD if possible.
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param outputTextureType type of the texture in which the encoding is performed
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
    return ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
  }
};

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
var _instanceNumber = 0;
var GetEnvironmentBRDFTexture = (scene) => {
  if (!scene.environmentBRDFTexture) {
    const useDelayedTextureLoading = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    const previousState = scene._blockEntityCollection;
    scene._blockEntityCollection = false;
    const texture = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
    scene._blockEntityCollection = previousState;
    const texturesCache = scene.getEngine().getLoadedTexturesCache();
    const index = texturesCache.indexOf(texture.getInternalTexture());
    if (index !== -1) {
      texturesCache.splice(index, 1);
    }
    texture.isRGBD = true;
    texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    scene.environmentBRDFTexture = texture;
    scene.useDelayedTextureLoading = useDelayedTextureLoading;
    RGBDTextureTools.ExpandRGBDTexture(texture);
    const observer = scene.getEngine().onContextRestoredObservable.add(() => {
      texture.isRGBD = true;
      const checkReady = () => {
        if (texture.isReady()) {
          RGBDTextureTools.ExpandRGBDTexture(texture);
        } else {
          Tools.SetImmediate(checkReady);
        }
      };
      checkReady();
    });
    scene.onDisposeObservable.add(() => {
      scene.getEngine().onContextRestoredObservable.remove(observer);
    });
  }
  return scene.environmentBRDFTexture;
};
var BRDFTextureTools = {
  /**
   * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
   * @param scene defines the hosting scene
   * @returns the environment BRDF texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  GetEnvironmentBRDFTexture
};

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.BRDF_V_HEIGHT_CORRELATED = false;
    this.MS_BRDF_ENERGY_CONSERVATION = false;
    this.SPHERICAL_HARMONICS = false;
    this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
  }
};
var PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
    this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
    this._enable(true);
  }
  prepareDefines(defines) {
    defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
    defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
    defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
    defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
  }
  getClassName() {
    return "PBRBRDFConfiguration";
  }
};
PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation = class {
  constructor(name52, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
    this.name = name52;
    this.worldAxisForNormal = worldAxisForNormal;
    this.worldAxisForFileX = worldAxisForFileX;
    this.worldAxisForFileY = worldAxisForFileY;
  }
};
var CubeMapToSphericalPolynomialTools = class {
  /**
   * Converts a texture to the according Spherical Polynomial data.
   * This extracts the first 3 orders only as they are the only one used in the lighting.
   *
   * @param texture The texture to extract the information from.
   * @returns The Spherical Polynomial data.
   */
  static ConvertCubeMapTextureToSphericalPolynomial(texture) {
    var _a;
    if (!texture.isCube) {
      return null;
    }
    (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();
    const size = texture.getSize().width;
    const rightPromise = texture.readPixels(0, void 0, void 0, false);
    const leftPromise = texture.readPixels(1, void 0, void 0, false);
    let upPromise;
    let downPromise;
    if (texture.isRenderTarget) {
      upPromise = texture.readPixels(3, void 0, void 0, false);
      downPromise = texture.readPixels(2, void 0, void 0, false);
    } else {
      upPromise = texture.readPixels(2, void 0, void 0, false);
      downPromise = texture.readPixels(3, void 0, void 0, false);
    }
    const frontPromise = texture.readPixels(4, void 0, void 0, false);
    const backPromise = texture.readPixels(5, void 0, void 0, false);
    const gammaSpace = texture.gammaSpace;
    const format = 5;
    let type = 0;
    if (texture.textureType == 1 || texture.textureType == 2) {
      type = 1;
    }
    return new Promise((resolve) => {
      Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {
        const cubeInfo = {
          size,
          right,
          left,
          up,
          down,
          front,
          back,
          format,
          type,
          gammaSpace
        };
        resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
      });
    });
  }
  /**
   * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin
   * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
   * @param x
   * @param y
   */
  static _AreaElement(x, y) {
    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
  }
  /**
   * Converts a cubemap to the according Spherical Polynomial data.
   * This extracts the first 3 orders only as they are the only one used in the lighting.
   *
   * @param cubeInfo The Cube map to extract the information from.
   * @returns The Spherical Polynomial data.
   */
  static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
    const sphericalHarmonics = new SphericalHarmonics();
    let totalSolidAngle = 0;
    const du = 2 / cubeInfo.size;
    const dv = du;
    const halfTexel = 0.5 * du;
    const minUV = halfTexel - 1;
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      const fileFace = this._FileFaces[faceIndex];
      const dataArray = cubeInfo[fileFace.name];
      let v = minUV;
      const stride = cubeInfo.format === 5 ? 4 : 3;
      for (let y = 0; y < cubeInfo.size; y++) {
        let u = minUV;
        for (let x = 0; x < cubeInfo.size; x++) {
          const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
          worldDirection.normalize();
          const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
          let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
          let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
          let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
          if (isNaN(r)) {
            r = 0;
          }
          if (isNaN(g)) {
            g = 0;
          }
          if (isNaN(b)) {
            b = 0;
          }
          if (cubeInfo.type === 0) {
            r /= 255;
            g /= 255;
            b /= 255;
          }
          if (cubeInfo.gammaSpace) {
            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);
            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);
            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);
          }
          const max = this.MAX_HDRI_VALUE;
          if (this.PRESERVE_CLAMPED_COLORS) {
            const currentMax = Math.max(r, g, b);
            if (currentMax > max) {
              const factor = max / currentMax;
              r *= factor;
              g *= factor;
              b *= factor;
            }
          } else {
            r = Scalar.Clamp(r, 0, max);
            g = Scalar.Clamp(g, 0, max);
            b = Scalar.Clamp(b, 0, max);
          }
          const color = new Color3(r, g, b);
          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
          totalSolidAngle += deltaSolidAngle;
          u += du;
        }
        v += dv;
      }
    }
    const sphereSolidAngle = 4 * Math.PI;
    const facesProcessed = 6;
    const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
    const correctionFactor = expectedSolidAngle / totalSolidAngle;
    sphericalHarmonics.scaleInPlace(correctionFactor);
    sphericalHarmonics.convertIncidentRadianceToIrradiance();
    sphericalHarmonics.convertIrradianceToLambertianRadiance();
    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
  }
};
CubeMapToSphericalPolynomialTools._FileFaces = [
  new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
  new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
  new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
  new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
  new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
  new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
  // -Z bottom
];
CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
  if (this._texture) {
    this._texture._sphericalPolynomial = null;
    this._texture._sphericalPolynomialPromise = null;
    this._texture._sphericalPolynomialComputed = false;
  }
};
Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
  get: function() {
    if (this._texture) {
      if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
        return this._texture._sphericalPolynomial;
      }
      if (this._texture.isReady) {
        if (!this._texture._sphericalPolynomialPromise) {
          this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
          if (this._texture._sphericalPolynomialPromise === null) {
            this._texture._sphericalPolynomialComputed = true;
          } else {
            this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
              this._texture._sphericalPolynomial = sphericalPolynomial;
              this._texture._sphericalPolynomialComputed = true;
            });
          }
        }
        return null;
      }
    }
    return null;
  },
  set: function(value) {
    if (this._texture) {
      this._texture._sphericalPolynomial = value;
    }
  },
  enumerable: true,
  configurable: true
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js
var name10 = "pbrFragmentDeclaration";
var shader10 = `uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#ifdef SS_DISPERSION
uniform float dispersion;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
ShaderStore.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js
var name11 = "pbrUboDeclaration";
var shader11 = `layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js
var name12 = "pbrFragmentExtraDeclaration";
var shader12 = `varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;
ShaderStore.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js
var name13 = "samplerFragmentAlternateDeclaration";
var shader13 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js
var name14 = "pbrFragmentSamplersDeclaration";
var shader14 = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#endif
`;
ShaderStore.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js
var name15 = "subSurfaceScatteringFunctions";
var shader15 = `bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;
ShaderStore.IncludesShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js
var name16 = "importanceSampling";
var shader16 = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;
ShaderStore.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js
var name17 = "pbrHelperFunctions";
var shader17 = `#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;
ShaderStore.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js
var name18 = "harmonicsFunctions";
var shader18 = `#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js
var name19 = "pbrDirectLightingSetupFunctions";
var shader19 = `struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;
ShaderStore.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js
var name20 = "pbrDirectLightingFalloffFunctions";
var shader20 = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;
ShaderStore.IncludesShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js
var name21 = "pbrBRDFFunctions";
var shader21 = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;
ShaderStore.IncludesShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js
var name22 = "hdrFilteringFunctions";
var shader22 = `#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; 
if (alphaG==0.) {
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js
var name23 = "pbrDirectLightingFunctions";
var shader23 = `#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;
ShaderStore.IncludesShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js
var name24 = "pbrIBLFunctions";
var shader24 = `#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;
ShaderStore.IncludesShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js
var name25 = "pbrBlockAlbedoOpacity";
var shader25 = `struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;
ShaderStore.IncludesShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js
var name26 = "pbrBlockReflectivity";
var shader26 = `struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;
ShaderStore.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js
var name27 = "pbrBlockAmbientOcclusion";
var shader27 = `struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;
ShaderStore.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js
var name28 = "pbrBlockAlphaFresnel";
var shader28 = `#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js
var name29 = "pbrBlockAnisotropic";
var shader29 = `#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;
ShaderStore.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js
var name30 = "pbrBlockReflection";
var shader30 = `#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;
ShaderStore.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js
var name31 = "pbrBlockSheen";
var shader31 = `#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL
sheenRoughness*=sheenMapData.a;
#else
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;
ShaderStore.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js
var name32 = "pbrBlockClearcoat";
var shader32 = `struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL
clearCoatRoughness*=clearCoatMapData.y;
#else
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js
var name33 = "pbrBlockIridescence";
var shader33 = `struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE
iridescenceThicknessWeight=iridescenceMapData.g;
#endif
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;
ShaderStore.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js
var name34 = "pbrBlockSubSurface";
var shader34 = `struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#define pbr_inline
#define inline
#ifdef SS_REFRACTION
vec4 sampleEnvironmentRefraction(
in float ior
,in float thickness
,in float refractionLOD
,in vec3 normalW
,in vec3 vPositionW
,in vec3 viewDirectionW
,in mat4 view
,in vec4 vRefractionInfos
,in mat4 refractionMatrix
,in vec4 vRefractionMicrosurfaceInfos
,in float alphaG
#ifdef SS_REFRACTIONMAP_3D
,in samplerCube refractionSampler
#ifndef LODBASEDMICROSFURACE
,in samplerCube refractionSamplerLow
,in samplerCube refractionSamplerHigh
#endif
#else
,in sampler2D refractionSampler
#ifndef LODBASEDMICROSFURACE
,in sampler2D refractionSamplerLow
,in sampler2D refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,in anisotropicOutParams anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,in vec2 vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,in vec3 refractionPosition
,in vec3 refractionSize
#endif
) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,ior);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
return environmentRefraction;}
#endif
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#ifdef SS_DISPERSION
in float dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#if defined(SS_USE_GLTF_TEXTURES)
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#ifdef SS_MASK_FROM_THICKNESS_TEXTURE
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)
#if defined(SS_USE_GLTF_TEXTURES)
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
#ifdef SS_DISPERSION
float realIOR=1.0/ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {ior=iors[i];
#endif
vec4 envSample=sampleEnvironmentRefraction(ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG
#ifdef SS_REFRACTIONMAP_3D
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#else
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,refractionPosition
,refractionSize
#endif
);
#ifdef SS_DISPERSION
environmentRefraction[i]=envSample[i];}
#else
environmentRefraction=envSample;
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js
var name35 = "pbrBlockNormalGeometric";
var shader35 = `vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;
ShaderStore.IncludesShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js
var name36 = "pbrBlockNormalFinal";
var shader36 = `#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;
ShaderStore.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js
var name37 = "pbrBlockLightmapInit";
var shader37 = `#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;
ShaderStore.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js
var name38 = "pbrBlockGeometryInfo";
var shader38 = `float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js
var name39 = "pbrBlockReflectance0";
var shader39 = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;
ShaderStore.IncludesShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js
var name40 = "pbrBlockReflectance";
var shader40 = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js
var name41 = "pbrBlockDirectLighting";
var shader41 = `vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;
ShaderStore.IncludesShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js
var name42 = "pbrBlockFinalLitComponents";
var shader42 = `aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js
var name43 = "pbrBlockFinalUnlitComponents";
var shader43 = `vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;
ShaderStore.IncludesShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js
var name44 = "pbrBlockFinalColorComposition";
var shader44 = `vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;
ShaderStore.IncludesShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js
var name45 = "pbrBlockImageProcessing";
var shader45 = `#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;
ShaderStore.IncludesShadersStore[name45] = shader45;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js
var name46 = "pbrDebug";
var shader46 = `#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name46] = shader46;

// node_modules/@babylonjs/core/Shaders/pbr.fragment.js
var name47 = "pbrPixelShader";
var shader47 = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#ifdef SS_DISPERSION
dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name47] = shader47;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js
var name48 = "pbrVertexDeclaration";
var shader48 = `uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;
ShaderStore.IncludesShadersStore[name48] = shader48;

// node_modules/@babylonjs/core/Shaders/pbr.vertex.js
var name49 = "pbrVertexShader";
var shader49 = `precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name49] = shader49;

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.CLEARCOAT = false;
    this.CLEARCOAT_DEFAULTIOR = false;
    this.CLEARCOAT_TEXTURE = false;
    this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
    this.CLEARCOAT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.CLEARCOAT_BUMP = false;
    this.CLEARCOAT_BUMPDIRECTUV = 0;
    this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
    this.CLEARCOAT_REMAP_F0 = false;
    this.CLEARCOAT_TINT = false;
    this.CLEARCOAT_TINT_TEXTURE = false;
    this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TINT_GAMMATEXTURE = false;
  }
};
var PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.roughness = 0;
    this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._remapF0OnInterfaceChange = true;
    this.remapF0OnInterfaceChange = true;
    this._bumpTexture = null;
    this.bumpTexture = null;
    this._isTintEnabled = false;
    this.isTintEnabled = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.tintThickness = 1;
    this._tintTexture = null;
    this.tintTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    const disableBumpMap = this._material._disableBumpMap;
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
          if (!this._tintTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    var _a;
    if (this._isEnabled) {
      defines.CLEARCOAT = true;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
      defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
          } else {
            defines.CLEARCOAT_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
          } else {
            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          }
          if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
          } else {
            defines.CLEARCOAT_BUMP = false;
          }
          defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
          if (this._isTintEnabled) {
            defines.CLEARCOAT_TINT = true;
            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
              defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
            } else {
              defines.CLEARCOAT_TINT_TEXTURE = false;
            }
          } else {
            defines.CLEARCOAT_TINT = false;
            defines.CLEARCOAT_TINT_TEXTURE = false;
          }
        }
      }
    } else {
      defines.CLEARCOAT = false;
      defines.CLEARCOAT_TEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
      defines.CLEARCOAT_BUMP = false;
      defines.CLEARCOAT_TINT = false;
      defines.CLEARCOAT_TINT_TEXTURE = false;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
      defines.CLEARCOAT_DEFAULTIOR = false;
      defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
      defines.CLEARCOAT_BUMPDIRECTUV = 0;
      defines.CLEARCOAT_REMAP_F0 = false;
      defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const disableBumpMap = this._material._disableBumpMap;
    const invertNormalMapX = this._material._invertNormalMapX;
    const invertNormalMapY = this._material._invertNormalMapY;
    const identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
      } else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
        if (this._texture) {
          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
        }
        if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
        }
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
        uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
        MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
        if (scene._mirroredCameraPosition) {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
        } else {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
        }
      }
      if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
        MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
      }
      uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
      const a = 1 - this._indexOfRefraction;
      const b = 1 + this._indexOfRefraction;
      const f0 = Math.pow(-a / b, 2);
      const eta = 1 / this._indexOfRefraction;
      uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
      if (this._isTintEnabled) {
        uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
        uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatSampler", this._texture);
      }
      if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
        uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
      }
      if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._tintTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._tintTexture) {
      activeTextures.push(this._tintTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      animatables.push(this._bumpTexture);
    }
    if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
      animatables.push(this._tintTexture);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b, _c, _d;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._bumpTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._tintTexture) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  getClassName() {
    return "PBRClearCoatConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.CLEARCOAT_BUMP) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
    }
    if (defines.CLEARCOAT_TINT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
    }
    if (defines.CLEARCOAT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vClearCoatParams", size: 2, type: "vec2" },
        { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
        { name: "vClearCoatInfos", size: 4, type: "vec4" },
        { name: "clearCoatMatrix", size: 16, type: "mat4" },
        { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
        { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
        { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatTintParams", size: 4, type: "vec4" },
        { name: "clearCoatColorAtDistance", size: 1, type: "float" },
        { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
        { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
__decorate([
  serializeAsColor3()
], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.IRIDESCENCE = false;
    this.IRIDESCENCE_TEXTURE = false;
    this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
    this.IRIDESCENCE_THICKNESS_TEXTURE = false;
    this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
    this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
  }
};
var PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
    this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
    this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    var _a;
    if (this._isEnabled) {
      defines.IRIDESCENCE = true;
      defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = this._texture !== null && this._texture._texture === ((_a = this._thicknessTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._thicknessTexture);
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
          } else {
            defines.IRIDESCENCE_TEXTURE = false;
          }
          if (!defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
          } else {
            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          }
        }
      }
    } else {
      defines.IRIDESCENCE = false;
      defines.IRIDESCENCE_TEXTURE = false;
      defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
      defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
      defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
      defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const identicalTextures = defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (identicalTextures && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.updateFloat4("vIridescenceInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
      } else if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.updateFloat4("vIridescenceInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._thicknessTexture) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._thicknessTexture) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
        if (this._texture) {
          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
        }
        if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE) {
          MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
        }
      }
      uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceSampler", this._texture);
      }
      if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._thicknessTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._thicknessTexture) === null || _b === void 0 ? void 0 : _b.dispose();
    }
  }
  getClassName() {
    return "PBRIridescenceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.IRIDESCENCE) {
      fallbacks.addFallback(currentRank++, "IRIDESCENCE");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vIridescenceParams", size: 4, type: "vec4" },
        { name: "vIridescenceInfos", size: 4, type: "vec4" },
        { name: "iridescenceMatrix", size: 16, type: "mat4" },
        { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "texture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.ANISOTROPIC = false;
    this.ANISOTROPIC_TEXTURE = false;
    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
    this.ANISOTROPIC_LEGACY = false;
    this.MAINUV1 = false;
  }
};
var PBRAnisotropicConfiguration = class extends MaterialPluginBase {
  /**
   * Sets the anisotropy direction as an angle.
   */
  set angle(value) {
    this.direction.x = Math.cos(value);
    this.direction.y = Math.sin(value);
  }
  /**
   * Gets the anisotropy angle value in radians.
   * @returns the anisotropy angle value in radians.
   */
  get angle() {
    return Math.atan2(this.direction.y, this.direction.x);
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.direction = new Vector2(1, 0);
    this._texture = null;
    this.texture = null;
    this._legacy = false;
    this.legacy = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
    if (this._isEnabled) {
      defines.ANISOTROPIC = this._isEnabled;
      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
          } else {
            defines.ANISOTROPIC_TEXTURE = false;
          }
        }
      }
      if (defines._areMiscDirty) {
        defines.ANISOTROPIC_LEGACY = this._legacy;
      }
    } else {
      defines.ANISOTROPIC = false;
      defines.ANISOTROPIC_TEXTURE = false;
      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
      defines.ANISOTROPIC_LEGACY = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
      }
      uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.setTexture("anisotropySampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._texture) {
        this._texture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRAnisotropicConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.ANISOTROPIC) {
      fallbacks.addFallback(currentRank++, "ANISOTROPIC");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("anisotropySampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vAnisotropy", size: 3, type: "vec3" },
        { name: "vAnisotropyInfos", size: 2, type: "vec2" },
        { name: "anisotropyMatrix", size: 16, type: "mat4" }
      ]
    };
  }
  /**
   * Parses a anisotropy Configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    super.parse(source, scene, rootUrl);
    if (source.legacy === void 0) {
      this.legacy = true;
    }
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsVector2()
], PBRAnisotropicConfiguration.prototype, "direction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRAnisotropicConfiguration.prototype, "legacy", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SHEEN = false;
    this.SHEEN_TEXTURE = false;
    this.SHEEN_GAMMATEXTURE = false;
    this.SHEEN_TEXTURE_ROUGHNESS = false;
    this.SHEEN_TEXTUREDIRECTUV = 0;
    this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.SHEEN_LINKWITHALBEDO = false;
    this.SHEEN_ROUGHNESS = false;
    this.SHEEN_ALBEDOSCALING = false;
    this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
  }
};
var PBRSheenConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this._linkSheenWithAlbedo = false;
    this.linkSheenWithAlbedo = false;
    this.intensity = 1;
    this.color = Color3.White();
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._roughness = null;
    this.roughness = null;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._albedoScaling = false;
    this.albedoScaling = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.SheenTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    var _a;
    if (this._isEnabled) {
      defines.SHEEN = true;
      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
      defines.SHEEN_ROUGHNESS = this._roughness !== null;
      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
            defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
          } else {
            defines.SHEEN_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
          } else {
            defines.SHEEN_TEXTURE_ROUGHNESS = false;
          }
        }
      }
    } else {
      defines.SHEEN = false;
      defines.SHEEN_TEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS = false;
      defines.SHEEN_LINKWITHALBEDO = false;
      defines.SHEEN_ROUGHNESS = false;
      defines.SHEEN_ALBEDOSCALING = false;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
      defines.SHEEN_GAMMATEXTURE = false;
      defines.SHEEN_TEXTUREDIRECTUV = 0;
      defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (identicalTextures && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
      } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
        if (this._texture) {
          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
        }
        if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
        }
      }
      uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
      if (this._roughness !== null) {
        uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenSampler", this._texture);
      }
      if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
    }
  }
  getClassName() {
    return "PBRSheenConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SHEEN) {
      fallbacks.addFallback(currentRank++, "SHEEN");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("sheenSampler", "sheenRoughnessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vSheenColor", size: 4, type: "vec4" },
        { name: "vSheenRoughness", size: 1, type: "float" },
        { name: "vSheenInfos", size: 4, type: "vec4" },
        { name: "sheenMatrix", size: 16, type: "mat4" },
        { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
__decorate([
  serialize()
], PBRSheenConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsColor3()
], PBRSheenConfiguration.prototype, "color", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "roughness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "albedoScaling", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SUBSURFACE = false;
    this.SS_REFRACTION = false;
    this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
    this.SS_TRANSLUCENCY = false;
    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
    this.SS_SCATTERING = false;
    this.SS_DISPERSION = false;
    this.SS_THICKNESSANDMASK_TEXTURE = false;
    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
    this.SS_HAS_THICKNESS = false;
    this.SS_REFRACTIONINTENSITY_TEXTURE = false;
    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_REFRACTIONMAP_3D = false;
    this.SS_REFRACTIONMAP_OPPOSITEZ = false;
    this.SS_LODINREFRACTIONALPHA = false;
    this.SS_GAMMAREFRACTION = false;
    this.SS_RGBDREFRACTION = false;
    this.SS_LINEARSPECULARREFRACTION = false;
    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
    this.SS_ALBEDOFORREFRACTIONTINT = false;
    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.SS_USE_THICKNESS_AS_DEPTH = false;
    this.SS_MASK_FROM_THICKNESS_TEXTURE = false;
    this.SS_USE_GLTF_TEXTURES = false;
  }
};
var PBRSubSurfaceConfiguration = class extends MaterialPluginBase {
  /**
   * Diffusion profile for subsurface scattering.
   * Useful for better scattering in the skins or foliages.
   */
  get scatteringDiffusionProfile() {
    if (!this._scene.subSurfaceConfiguration) {
      return null;
    }
    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
  }
  set scatteringDiffusionProfile(c) {
    if (!this._scene.enableSubSurfaceForPrePass()) {
      return;
    }
    if (c) {
      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
    }
  }
  /**
   * Index of refraction of the material's volume.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This ONLY impacts refraction. If not provided or given a non-valid value,
   * the volume will use the same IOR as the surface.
   */
  get volumeIndexOfRefraction() {
    if (this._volumeIndexOfRefraction >= 1) {
      return this._volumeIndexOfRefraction;
    }
    return this._indexOfRefraction;
  }
  set volumeIndexOfRefraction(value) {
    if (value >= 1) {
      this._volumeIndexOfRefraction = value;
    } else {
      this._volumeIndexOfRefraction = -1;
    }
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markScenePrePassDirty() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
    this._internalMarkScenePrePassDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
    this._isRefractionEnabled = false;
    this.isRefractionEnabled = false;
    this._isTranslucencyEnabled = false;
    this.isTranslucencyEnabled = false;
    this._isDispersionEnabled = false;
    this.isDispersionEnabled = false;
    this._isScatteringEnabled = false;
    this.isScatteringEnabled = false;
    this._scatteringDiffusionProfileIndex = 0;
    this.refractionIntensity = 1;
    this.translucencyIntensity = 1;
    this.useAlbedoToTintRefraction = false;
    this.useAlbedoToTintTranslucency = false;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._refractionTexture = null;
    this.refractionTexture = null;
    this._indexOfRefraction = 1.5;
    this.indexOfRefraction = 1.5;
    this._volumeIndexOfRefraction = -1;
    this._invertRefractionY = false;
    this.invertRefractionY = false;
    this._linkRefractionWithTransparency = false;
    this.linkRefractionWithTransparency = false;
    this.minimumThickness = 0;
    this.maximumThickness = 1;
    this.useThicknessAsDepth = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.dispersion = 0;
    this.diffusionDistance = Color3.White();
    this._useMaskFromThicknessTexture = false;
    this.useMaskFromThicknessTexture = false;
    this._refractionIntensityTexture = null;
    this.refractionIntensityTexture = null;
    this._translucencyIntensityTexture = null;
    this.translucencyIntensityTexture = null;
    this._useGltfStyleTextures = false;
    this.useGltfStyleTextures = false;
    this._scene = material.getScene();
    this.registerForExtraEvents = true;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const refractionTexture = this._getRefractionTexture(scene);
        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
          if (!refractionTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      defines.SUBSURFACE = false;
      defines.SS_DISPERSION = false;
      defines.SS_TRANSLUCENCY = false;
      defines.SS_SCATTERING = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      return;
    }
    if (defines._areTexturesDirty) {
      defines.SUBSURFACE = true;
      defines.SS_DISPERSION = this._isDispersionEnabled;
      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
      defines.SS_SCATTERING = this._isScatteringEnabled;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;
      const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;
      const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
          }
        }
      }
      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
      defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
      if (this._isRefractionEnabled) {
        if (scene.texturesEnabled) {
          const refractionTexture = this._getRefractionTexture(scene);
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            defines.SS_REFRACTION = true;
            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
          }
        }
      }
      if (this._isTranslucencyEnabled) {
        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
      }
    }
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine defines the engine the material belongs to.
   * @param subMesh the submesh to bind data for
   */
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
    const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
    uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const realTimeFiltering = this._material.realTimeFiltering;
    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
    const refractionTexture = this._getRefractionTexture(scene);
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
        MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
        MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
        let depth = 1;
        if (!refractionTexture.isCube) {
          if (refractionTexture.depth) {
            depth = refractionTexture.depth;
          }
        }
        const width = refractionTexture.getSize().width;
        const refractionIor = this.volumeIndexOfRefraction;
        uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
        uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
        if (realTimeFiltering) {
          uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Scalar.Log2(width));
        }
        if (refractionTexture.boundingBoxSize) {
          const cubeTexture = refractionTexture;
          uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
          uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
        }
      }
      if (this._isScatteringEnabled) {
        uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
      }
      uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
      uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
      uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
      uniformBuffer.updateFloat("dispersion", this.dispersion);
    }
    if (scene.texturesEnabled) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        if (lodBasedMicrosurface) {
          uniformBuffer.setTexture("refractionSampler", refractionTexture);
        } else {
          uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
        }
      }
    }
  }
  /**
   * Returns the texture used for refraction or null if none is used.
   * @param scene defines the scene the material belongs to.
   * @returns - Refraction texture if present.  If no refraction texture and refraction
   * is linked with transparency, returns environment texture.  Otherwise, returns null.
   */
  _getRefractionTexture(scene) {
    if (this._refractionTexture) {
      return this._refractionTexture;
    }
    if (this._isRefractionEnabled) {
      return scene.environmentTexture;
    }
    return null;
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get disableAlphaBlending() {
    return this._isRefractionEnabled && this._linkRefractionWithTransparency;
  }
  /**
   * Fills the list of render target textures.
   * @param renderTargets the list of render targets to update
   */
  fillRenderTargetTextures(renderTargets) {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      renderTargets.push(this._refractionTexture);
    }
  }
  hasTexture(texture) {
    if (this._thicknessTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return false;
  }
  hasRenderTargetTextures() {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      animatables.push(this._refractionTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._thicknessTexture) {
        this._thicknessTexture.dispose();
      }
      if (this._refractionTexture) {
        this._refractionTexture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRSubSurfaceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SS_SCATTERING) {
      fallbacks.addFallback(currentRank++, "SS_SCATTERING");
    }
    if (defines.SS_TRANSLUCENCY) {
      fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
        { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
        { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
        { name: "vRefractionInfos", size: 4, type: "vec4" },
        { name: "refractionMatrix", size: 16, type: "mat4" },
        { name: "vThicknessInfos", size: 2, type: "vec2" },
        { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
        { name: "thicknessMatrix", size: 16, type: "mat4" },
        { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
        { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
        { name: "vThicknessParam", size: 2, type: "vec2" },
        { name: "vDiffusionDistance", size: 3, type: "vec3" },
        { name: "vTintColor", size: 4, type: "vec4" },
        { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
        { name: "vRefractionPosition", size: 3, type: "vec3" },
        { name: "vRefractionSize", size: 3, type: "vec3" },
        { name: "scatteringDiffusionProfile", size: 1, type: "float" },
        { name: "dispersion", size: 1, type: "float" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markScenePrePassDirty")
], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters2 = { effect: null, subMesh: null };
var PBRMaterialDefines = class extends MaterialDefines {
  /**
   * Initializes the PBR Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.PBR = true;
    this.NUM_SAMPLES = "0";
    this.REALTIME_FILTERING = false;
    this.MAINUV1 = false;
    this.MAINUV2 = false;
    this.MAINUV3 = false;
    this.MAINUV4 = false;
    this.MAINUV5 = false;
    this.MAINUV6 = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.ALBEDO = false;
    this.GAMMAALBEDO = false;
    this.ALBEDODIRECTUV = 0;
    this.VERTEXCOLOR = false;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.AMBIENTINGRAYSCALE = false;
    this.OPACITY = false;
    this.VERTEXALPHA = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHABLEND = false;
    this.ALPHAFROMALBEDO = false;
    this.ALPHATESTVALUE = "0.5";
    this.SPECULAROVERALPHA = false;
    this.RADIANCEOVERALPHA = false;
    this.ALPHAFRESNEL = false;
    this.LINEARALPHAFRESNEL = false;
    this.PREMULTIPLYALPHA = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.GAMMAEMISSIVE = false;
    this.REFLECTIVITY = false;
    this.REFLECTIVITY_GAMMA = false;
    this.REFLECTIVITYDIRECTUV = 0;
    this.SPECULARTERM = false;
    this.MICROSURFACEFROMREFLECTIVITYMAP = false;
    this.MICROSURFACEAUTOMATIC = false;
    this.LODBASEDMICROSFURACE = false;
    this.MICROSURFACEMAP = false;
    this.MICROSURFACEMAPDIRECTUV = 0;
    this.METALLICWORKFLOW = false;
    this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    this.METALLNESSSTOREINMETALMAPBLUE = false;
    this.AOSTOREINMETALMAPRED = false;
    this.METALLIC_REFLECTANCE = false;
    this.METALLIC_REFLECTANCE_GAMMA = false;
    this.METALLIC_REFLECTANCEDIRECTUV = 0;
    this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
    this.REFLECTANCE = false;
    this.REFLECTANCE_GAMMA = false;
    this.REFLECTANCEDIRECTUV = 0;
    this.ENVIRONMENTBRDF = false;
    this.ENVIRONMENTBRDF_RGBD = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.NORMALXYSCALE = true;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.GAMMALIGHTMAP = false;
    this.RGBDLIGHTMAP = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.USESPHERICALFROMREFLECTIONMAP = false;
    this.USEIRRADIANCEMAP = false;
    this.USESPHERICALINVERTEX = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.LINEARSPECULARREFLECTION = false;
    this.RADIANCEOCCLUSION = false;
    this.HORIZONOCCLUSION = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.PREPASS = false;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.NONUNIFORMSCALING = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.EXPOSURE = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.USEPHYSICALLIGHTFALLOFF = false;
    this.USEGLTFLIGHTFALLOFF = false;
    this.TWOSIDEDLIGHTING = false;
    this.SHADOWFLOAT = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LOGARITHMICDEPTH = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.FORCENORMALFORWARD = false;
    this.SPECULARAA = false;
    this.UNLIT = false;
    this.DECAL_AFTER_DETAIL = false;
    this.DEBUGMODE = 0;
    this.rebuild();
  }
  /**
   * Resets the PBR Material defines.
   */
  reset() {
    super.reset();
    this.ALPHATESTVALUE = "0.5";
    this.PBR = true;
    this.NORMALXYSCALE = true;
  }
};
var PBRBaseMaterial = class _PBRBaseMaterial extends PushMaterial {
  /**
   * Enables realtime filtering on the texture.
   */
  get realTimeFiltering() {
    return this._realTimeFiltering;
  }
  set realTimeFiltering(b) {
    this._realTimeFiltering = b;
    this.markAsDirty(1);
  }
  /**
   * Quality switch for realtime filtering
   */
  get realTimeFilteringQuality() {
    return this._realTimeFilteringQuality;
  }
  set realTimeFilteringQuality(n) {
    this._realTimeFilteringQuality = n;
    this.markAsDirty(1);
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Attaches a new image processing configuration to the PBR Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   */
  constructor(name52, scene) {
    super(name52, scene);
    this._directIntensity = 1;
    this._emissiveIntensity = 1;
    this._environmentIntensity = 1;
    this._specularIntensity = 1;
    this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
    this._disableBumpMap = false;
    this._albedoTexture = null;
    this._ambientTexture = null;
    this._ambientTextureStrength = 1;
    this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._reflectivityTexture = null;
    this._metallicTexture = null;
    this._metallic = null;
    this._roughness = null;
    this._metallicF0Factor = 1;
    this._metallicReflectanceColor = Color3.White();
    this._useOnlyMetallicFromMetallicReflectanceTexture = false;
    this._metallicReflectanceTexture = null;
    this._reflectanceTexture = null;
    this._microSurfaceTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._ambientColor = new Color3(0, 0, 0);
    this._albedoColor = new Color3(1, 1, 1);
    this._reflectivityColor = new Color3(1, 1, 1);
    this._reflectionColor = new Color3(1, 1, 1);
    this._emissiveColor = new Color3(0, 0, 0);
    this._microSurface = 0.9;
    this._useLightmapAsShadowmap = false;
    this._useHorizonOcclusion = true;
    this._useRadianceOcclusion = true;
    this._useAlphaFromAlbedoTexture = false;
    this._useSpecularOverAlpha = true;
    this._useMicroSurfaceFromReflectivityMapAlpha = false;
    this._useRoughnessFromMetallicTextureAlpha = true;
    this._useRoughnessFromMetallicTextureGreen = false;
    this._useMetallnessFromMetallicTextureBlue = false;
    this._useAmbientOcclusionFromMetallicTextureRed = false;
    this._useAmbientInGrayScale = false;
    this._useAutoMicroSurfaceFromReflectivityMap = false;
    this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
    this._useRadianceOverAlpha = true;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this._parallaxScaleBias = 0.05;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._alphaCutOff = 0.4;
    this._forceAlphaTest = false;
    this._useAlphaFresnel = false;
    this._useLinearAlphaFresnel = false;
    this._environmentBRDFTexture = null;
    this._forceIrradianceInFragment = false;
    this._realTimeFiltering = false;
    this._realTimeFilteringQuality = 8;
    this._forceNormalForward = false;
    this._enableSpecularAntiAliasing = false;
    this._imageProcessingObserver = null;
    this._renderTargets = new SmartArray(16);
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._unlit = false;
    this._applyDecalMapAfterDetailMap = false;
    this._debugMode = 0;
    this.debugMode = 0;
    this.debugLimit = -1;
    this.debugFactor = 1;
    this._cacheHasRenderTargetTextures = false;
    this.brdf = new PBRBRDFConfiguration(this);
    this.clearCoat = new PBRClearCoatConfiguration(this);
    this.iridescence = new PBRIridescenceConfiguration(this);
    this.anisotropy = new PBRAnisotropicConfiguration(this);
    this.sheen = new PBRSheenConfiguration(this);
    this.subSurface = new PBRSubSurfaceConfiguration(this);
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
    this.prePassConfiguration = new PrePassConfiguration();
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * Gets the name of the material class.
   */
  getClassName() {
    return "PBRBaseMaterial";
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get _disableAlphaBlending() {
    var _a;
    return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending);
  }
  /**
   * Specifies whether or not this material should be rendered in alpha blend mode.
   */
  needAlphaBlending() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
  }
  /**
   * Specifies whether or not this material should be rendered in alpha test mode.
   */
  needAlphaTesting() {
    var _a;
    if (this._forceAlphaTest) {
      return true;
    }
    if ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending) {
      return false;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
  }
  /**
   * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
   */
  _shouldUseAlphaFromAlbedoTexture() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
  }
  /**
   * Specifies whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
  }
  /**
   * Gets the texture used for the alpha test.
   */
  getAlphaTestTexture() {
    return this._albedoTexture;
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param mesh - BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
   * @param useInstances - Specifies that instances should be used.
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    var _a;
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
      subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._albedoTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (reflectionTexture.irradianceTexture) {
            if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else {
            if (!reflectionTexture.sphericalPolynomial && ((_a = reflectionTexture.getInternalTexture()) === null || _a === void 0 ? void 0 : _a._sphericalPolynomialPromise)) {
              return false;
            }
          }
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            if (!this._metallicTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else if (this._reflectivityTexture) {
            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._metallicReflectanceTexture) {
            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._reflectanceTexture) {
            if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._microSurfaceTexture) {
            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
      }
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    const previousEffect = subMesh.effect;
    const lightDisposed = defines._areLightsDisposed;
    let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    let forceWasNotReadyPreviously = false;
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        defines.markAsUnprocessed();
        forceWasNotReadyPreviously = this.isFrozen;
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines, this._materialContext);
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Specifies if the material uses metallic roughness workflow.
   * @returns boolean specifying if the material uses metallic roughness workflow.
   */
  isMetallicWorkflow() {
    if (this._metallic != null || this._roughness != null || this._metallicTexture) {
      return true;
    }
    return false;
  }
  _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {
    this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    const scene = this.getScene();
    const engine = scene.getEngine();
    const fallbacks = new EffectFallbacks();
    let fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAX_RHS) {
      fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    if (defines.BUMP) {
      fallbacks.addFallback(fallbackRank++, "BUMP");
    }
    fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.LIGHTMAP) {
      fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.AMBIENT) {
      fallbacks.addFallback(fallbackRank++, "AMBIENT");
    }
    if (defines.EMISSIVE) {
      fallbacks.addFallback(fallbackRank++, "EMISSIVE");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    const attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    for (let i = 1; i <= 6; ++i) {
      if (defines["UV" + i]) {
        attribs.push(`uv${i === 1 ? "" : i}`);
      }
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    MaterialHelper.PrepareAttributesForInstances(attribs, defines);
    MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
    MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    let shaderName = "pbr";
    const uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "vAmbientColor",
      "vAlbedoColor",
      "vReflectivityColor",
      "vMetallicReflectanceFactors",
      "vEmissiveColor",
      "visibility",
      "vReflectionColor",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "vAlbedoInfos",
      "vAmbientInfos",
      "vOpacityInfos",
      "vReflectionInfos",
      "vReflectionPosition",
      "vReflectionSize",
      "vEmissiveInfos",
      "vReflectivityInfos",
      "vReflectionFilteringInfo",
      "vMetallicReflectanceInfos",
      "vReflectanceInfos",
      "vMicroSurfaceSamplerInfos",
      "vBumpInfos",
      "vLightmapInfos",
      "mBones",
      "albedoMatrix",
      "ambientMatrix",
      "opacityMatrix",
      "reflectionMatrix",
      "emissiveMatrix",
      "reflectivityMatrix",
      "normalMatrix",
      "microSurfaceSamplerMatrix",
      "bumpMatrix",
      "lightmapMatrix",
      "metallicReflectanceMatrix",
      "reflectanceMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vSphericalX",
      "vSphericalY",
      "vSphericalZ",
      "vSphericalXX_ZZ",
      "vSphericalYY_ZZ",
      "vSphericalZZ",
      "vSphericalXY",
      "vSphericalYZ",
      "vSphericalZX",
      "vSphericalL00",
      "vSphericalL1_1",
      "vSphericalL10",
      "vSphericalL11",
      "vSphericalL2_2",
      "vSphericalL2_1",
      "vSphericalL20",
      "vSphericalL21",
      "vSphericalL22",
      "vReflectionMicrosurfaceInfos",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices"
    ];
    const samplers = [
      "albedoSampler",
      "reflectivitySampler",
      "ambientSampler",
      "emissiveSampler",
      "bumpSampler",
      "lightmapSampler",
      "opacitySampler",
      "reflectionSampler",
      "reflectionSamplerLow",
      "reflectionSamplerHigh",
      "irradianceSampler",
      "microSurfaceSampler",
      "environmentBrdfSampler",
      "boneSampler",
      "metallicReflectanceSampler",
      "reflectanceSampler",
      "morphTargets",
      "oitDepthSampler",
      "oitFrontColorSampler"
    ];
    const uniformBuffers = ["Material", "Scene", "Mesh"];
    const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
    this._eventInfo.fallbacks = fallbacks;
    this._eventInfo.fallbackRank = fallbackRank;
    this._eventInfo.defines = defines;
    this._eventInfo.uniforms = uniforms;
    this._eventInfo.attributes = attribs;
    this._eventInfo.samplers = samplers;
    this._eventInfo.uniformBuffersNames = uniformBuffers;
    this._eventInfo.customCode = void 0;
    this._eventInfo.mesh = mesh;
    this._eventInfo.indexParameters = indexParameters;
    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(samplers);
    addClipPlaneUniforms(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    MaterialHelper.PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    const csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    const join = defines.toString();
    const effect = engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters,
      processFinalCode: csnrOptions.processFinalCode,
      processCodeAfterIncludes: this._eventInfo.customCode,
      multiTarget: defines.PREPASS
    }, engine);
    this._eventInfo.customCode = void 0;
    return effect;
  }
  _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {
    var _a;
    const scene = this.getScene();
    const engine = scene.getEngine();
    MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
    defines.METALLICWORKFLOW = this.isMetallicWorkflow();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.ALBEDODIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.REFLECTIVITYDIRECTUV = 0;
        defines.MICROSURFACEMAPDIRECTUV = 0;
        defines.METALLIC_REFLECTANCEDIRECTUV = 0;
        defines.REFLECTANCEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (engine.getCaps().textureLOD) {
          defines.LODBASEDMICROSFURACE = true;
        }
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
        } else {
          defines.ALBEDO = false;
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
        } else {
          defines.OPACITY = false;
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.REFLECTION = true;
          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
          defines.RGBDREFLECTION = reflectionTexture.isRGBD;
          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
          defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
          if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
            defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
            if (engine._features.needTypeSuffixInShaderConstants) {
              defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
            }
            defines.REALTIME_FILTERING = true;
          } else {
            defines.REALTIME_FILTERING = false;
          }
          defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
          defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          switch (reflectionTexture.coordinatesMode) {
            case Texture.EXPLICIT_MODE:
              defines.REFLECTIONMAP_EXPLICIT = true;
              break;
            case Texture.PLANAR_MODE:
              defines.REFLECTIONMAP_PLANAR = true;
              break;
            case Texture.PROJECTION_MODE:
              defines.REFLECTIONMAP_PROJECTION = true;
              break;
            case Texture.SKYBOX_MODE:
              defines.REFLECTIONMAP_SKYBOX = true;
              break;
            case Texture.SPHERICAL_MODE:
              defines.REFLECTIONMAP_SPHERICAL = true;
              break;
            case Texture.EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.CUBIC_MODE:
            case Texture.INVCUBIC_MODE:
            default:
              defines.REFLECTIONMAP_CUBIC = true;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
              break;
          }
          if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
            if (reflectionTexture.irradianceTexture) {
              defines.USEIRRADIANCEMAP = true;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
            } else if (reflectionTexture.isCube) {
              defines.USESPHERICALFROMREFLECTIONMAP = true;
              defines.USEIRRADIANCEMAP = false;
              if (this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8) {
                defines.USESPHERICALINVERTEX = false;
              } else {
                defines.USESPHERICALINVERTEX = true;
              }
            }
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_3D = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          defines.INVERTCUBICMAP = false;
          defines.USESPHERICALFROMREFLECTIONMAP = false;
          defines.USEIRRADIANCEMAP = false;
          defines.USESPHERICALINVERTEX = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
          defines.LODINREFLECTIONALPHA = false;
          defines.GAMMAREFLECTION = false;
          defines.RGBDREFLECTION = false;
          defines.LINEARSPECULARREFLECTION = false;
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
        } else {
          defines.EMISSIVE = false;
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
            defines.REFLECTIVITY_GAMMA = false;
          } else if (this._reflectivityTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
            defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
          } else {
            defines.REFLECTIVITY = false;
          }
          if (this._metallicReflectanceTexture || this._reflectanceTexture) {
            const identicalTextures = this._metallicReflectanceTexture !== null && this._metallicReflectanceTexture._texture === ((_a = this._reflectanceTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);
            defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;
            if (this._metallicReflectanceTexture) {
              MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
              defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
            } else {
              defines.METALLIC_REFLECTANCE = false;
            }
            if (this._reflectanceTexture && !identicalTextures && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
              MaterialHelper.PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
              defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
            } else {
              defines.REFLECTANCE = false;
            }
          } else {
            defines.METALLIC_REFLECTANCE = false;
            defines.REFLECTANCE = false;
          }
          if (this._microSurfaceTexture) {
            MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
          } else {
            defines.MICROSURFACEMAP = false;
          }
        } else {
          defines.REFLECTIVITY = false;
          defines.MICROSURFACEMAP = false;
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
          defines.OBJECTSPACE_NORMALMAP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._shouldUseAlphaFromAlbedoTexture()) {
          defines.ALPHAFROMALBEDO = true;
        } else {
          defines.ALPHAFROMALBEDO = false;
        }
      }
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if (defines._areMiscDirty) {
      MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
  }
  /**
   * Force shader compilation
   * @param mesh
   * @param onCompiled
   * @param options
   */
  forceCompilation(mesh, onCompiled, options) {
    const localOptions = Object.assign({ clipPlane: false, useInstances: false }, options);
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
    const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
    const effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
    if (this._onEffectCreatedObservable) {
      onCreatedEffectParameters2.effect = effect;
      onCreatedEffectParameters2.subMesh = null;
      this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
    }
    if (effect.isReady()) {
      if (onCompiled) {
        onCompiled(this);
      }
    } else {
      effect.onCompileObservable.add(() => {
        if (onCompiled) {
          onCompiled(this);
        }
      });
    }
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("vAlbedoInfos", 2);
    ubo.addUniform("vAmbientInfos", 4);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vReflectivityInfos", 3);
    ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionFilteringInfo", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("albedoMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("reflectivityMatrix", 16);
    ubo.addUniform("microSurfaceSamplerMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("vReflectionColor", 3);
    ubo.addUniform("vAlbedoColor", 4);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vReflectivityColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vAmbientColor", 3);
    ubo.addUniform("vDebugMode", 2);
    ubo.addUniform("vMetallicReflectanceFactors", 4);
    ubo.addUniform("vMetallicReflectanceInfos", 2);
    ubo.addUniform("metallicReflectanceMatrix", 16);
    ubo.addUniform("vReflectanceInfos", 2);
    ubo.addUniform("reflectanceMatrix", 16);
    ubo.addUniform("vSphericalL00", 3);
    ubo.addUniform("vSphericalL1_1", 3);
    ubo.addUniform("vSphericalL10", 3);
    ubo.addUniform("vSphericalL11", 3);
    ubo.addUniform("vSphericalL2_2", 3);
    ubo.addUniform("vSphericalL2_1", 3);
    ubo.addUniform("vSphericalL20", 3);
    ubo.addUniform("vSphericalL21", 3);
    ubo.addUniform("vSphericalL22", 3);
    ubo.addUniform("vSphericalX", 3);
    ubo.addUniform("vSphericalY", 3);
    ubo.addUniform("vSphericalZ", 3);
    ubo.addUniform("vSphericalXX_ZZ", 3);
    ubo.addUniform("vSphericalYY_ZZ", 3);
    ubo.addUniform("vSphericalZZ", 3);
    ubo.addUniform("vSphericalXY", 3);
    ubo.addUniform("vSphericalYZ", 3);
    ubo.addUniform("vSphericalZX", 3);
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh data.
   * @param world - The world matrix.
   * @param mesh - The BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.
   */
  bindForSubMesh(world, mesh, subMesh) {
    var _a, _b, _c, _d;
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const engine = scene.getEngine();
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);
    MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    let reflectionTexture = null;
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      reflectionTexture = this._getReflectionTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {
        if (scene.texturesEnabled) {
          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
            MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, "albedo");
          }
          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
            ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
            ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
            ubo.updateFloat2("vReflectionInfos", reflectionTexture.level, 0);
            if (reflectionTexture.boundingBoxSize) {
              const cubeTexture = reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
            if (this.realTimeFiltering) {
              const width = reflectionTexture.getSize().width;
              ubo.updateFloat2("vReflectionFilteringInfo", width, Scalar.Log2(width));
            }
            if (!defines.USEIRRADIANCEMAP) {
              const polynomials = reflectionTexture.sphericalPolynomial;
              if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                if (defines.SPHERICAL_HARMONICS) {
                  const preScaledHarmonics = polynomials.preScaledHarmonics;
                  ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
                  ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                  ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
                  ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
                  ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                  ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                  ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
                  ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
                  ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
                } else {
                  ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                  ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                  ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                  ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                  ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                  ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                  ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                  ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                  ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                }
              }
            }
            ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
          }
          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (MaterialFlags.SpecularTextureEnabled) {
            if (this._metallicTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
              MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
            } else if (this._reflectivityTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
              MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
            }
            if (this._metallicReflectanceTexture) {
              ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
              MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
            }
            if (this._reflectanceTexture && defines.REFLECTANCE) {
              ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
              MaterialHelper.BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
            }
            if (this._microSurfaceTexture) {
              ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
              MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.METALLICWORKFLOW) {
          TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
          TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
          ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
          const ior = (_b = (_a = this.subSurface) === null || _a === void 0 ? void 0 : _a._indexOfRefraction) !== null && _b !== void 0 ? _b : 1.5;
          const outsideIOR = 1;
          const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
          this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
          const metallicF90 = this._metallicF0Factor;
          ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
        } else {
          ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
        }
        ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor3("vReflectionColor", this._reflectionColor);
        if (!defines.SS_REFRACTION && ((_c = this.subSurface) === null || _c === void 0 ? void 0 : _c._linkRefractionWithTransparency)) {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
        } else {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
        }
        this._lightingInfos.x = this._directIntensity;
        this._lightingInfos.y = this._emissiveIntensity;
        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = this._specularIntensity;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
        scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
        ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
      }
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          ubo.setTexture("albedoSampler", this._albedoTexture);
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          ubo.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          ubo.setTexture("opacitySampler", this._opacityTexture);
        }
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (defines.LODBASEDMICROSFURACE) {
            ubo.setTexture("reflectionSampler", reflectionTexture);
          } else {
            ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
            ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
            ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
          }
          if (defines.USEIRRADIANCEMAP) {
            ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
          }
        }
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          ubo.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          ubo.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            ubo.setTexture("reflectivitySampler", this._metallicTexture);
          } else if (this._reflectivityTexture) {
            ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
          }
          if (this._metallicReflectanceTexture) {
            ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
          }
          if (this._reflectanceTexture && defines.REFLECTANCE) {
            ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
          }
          if (this._microSurfaceTexture) {
            ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
          }
        }
        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          ubo.setTexture("bumpSampler", this._bumpTexture);
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      bindClipPlane(this._activeEffect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS) {
        this.bindView(effect);
      }
      MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        (_d = mesh.bakedVertexAnimationManager) === null || _d === void 0 ? void 0 : _d.bind(effect, defines.INSTANCES);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);
    }
    this._afterBind(mesh, this._activeEffect);
    ubo.update();
  }
  /**
   * Returns the animatable textures.
   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
      results.push(this._albedoTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
      results.push(this._metallicTexture);
    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
      results.push(this._reflectivityTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
      results.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
      results.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
      results.push(this._microSurfaceTexture);
    }
    return results;
  }
  /**
   * Returns the texture used for reflections.
   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
   */
  _getReflectionTexture() {
    if (this._reflectionTexture) {
      return this._reflectionTexture;
    }
    return this.getScene().environmentTexture;
  }
  /**
   * Returns an array of the actively used textures.
   * @returns - Array of BaseTextures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._albedoTexture) {
      activeTextures.push(this._albedoTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._reflectivityTexture) {
      activeTextures.push(this._reflectivityTexture);
    }
    if (this._metallicTexture) {
      activeTextures.push(this._metallicTexture);
    }
    if (this._metallicReflectanceTexture) {
      activeTextures.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture) {
      activeTextures.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture) {
      activeTextures.push(this._microSurfaceTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    return activeTextures;
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._albedoTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._reflectivityTexture === texture) {
      return true;
    }
    if (this._metallicTexture === texture) {
      return true;
    }
    if (this._metallicReflectanceTexture === texture) {
      return true;
    }
    if (this._reflectanceTexture === texture) {
      return true;
    }
    if (this._microSurfaceTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Sets the required values to the prepass renderer.
   * It can't be sets when subsurface scattering of this material is disabled.
   * When scene have ability to enable subsurface prepass effect, it will enable.
   */
  setPrePassRenderer() {
    var _a;
    if (!((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.isScatteringEnabled)) {
      return false;
    }
    const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
    if (subSurfaceConfiguration) {
      subSurfaceConfiguration.enabled = true;
    }
    return true;
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeEffect - Forces the disposal of effects.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();
      (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();
      (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();
      (_l = this._reflectanceTexture) === null || _l === void 0 ? void 0 : _l.dispose();
      (_m = this._microSurfaceTexture) === null || _m === void 0 ? void 0 : _m.dispose();
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
};
PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
__decorate([
  serializeAsImageProcessingConfiguration()
], PBRBaseMaterial.prototype, "_imageProcessingConfiguration", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBaseMaterial.prototype, "debugMode", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial = class _PBRMaterial extends PBRBaseMaterial {
  /**
   * Stores the refracted light information in a texture.
   */
  get refractionTexture() {
    return this.subSurface.refractionTexture;
  }
  set refractionTexture(value) {
    this.subSurface.refractionTexture = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    } else if (!this.subSurface.linkRefractionWithTransparency) {
      this.subSurface.isRefractionEnabled = false;
    }
  }
  /**
   * Index of refraction of the material base layer.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This does not only impact refraction but also the Base F0 of Dielectric Materials.
   *
   * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
   */
  get indexOfRefraction() {
    return this.subSurface.indexOfRefraction;
  }
  set indexOfRefraction(value) {
    this.subSurface.indexOfRefraction = value;
  }
  /**
   * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
   */
  get invertRefractionY() {
    return this.subSurface.invertRefractionY;
  }
  set invertRefractionY(value) {
    this.subSurface.invertRefractionY = value;
  }
  /**
   * This parameters will make the material used its opacity to control how much it is refracting against not.
   * Materials half opaque for instance using refraction could benefit from this control.
   */
  get linkRefractionWithTransparency() {
    return this.subSurface.linkRefractionWithTransparency;
  }
  set linkRefractionWithTransparency(value) {
    this.subSurface.linkRefractionWithTransparency = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    }
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  get usePhysicalLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  set usePhysicalLightFalloff(value) {
    if (value !== this.usePhysicalLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  get useGLTFLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  set useGLTFLightFalloff(value) {
    if (value !== this.useGLTFLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set cameraColorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  set cameraColorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  /**
   * Gets whether tonemapping is enabled or not.
   */
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  /**
   * Sets whether tonemapping is enabled or not
   */
  set cameraToneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  set cameraExposure(value) {
    this._imageProcessingConfiguration.exposure = value;
  }
  /**
   * Gets The camera contrast used on this material.
   */
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  /**
   * Sets The camera contrast used on this material.
   */
  set cameraContrast(value) {
    this._imageProcessingConfiguration.contrast = value;
  }
  /**
   * Gets the Color Grading 2D Lookup Texture.
   */
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  /**
   * Sets the Color Grading 2D Lookup Texture.
   */
  set cameraColorGradingTexture(value) {
    this._imageProcessingConfiguration.colorGradingTexture = value;
  }
  /**
   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  /**
   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  set cameraColorCurves(value) {
    this._imageProcessingConfiguration.colorCurves = value;
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   */
  constructor(name52, scene) {
    super(name52, scene);
    this.directIntensity = 1;
    this.emissiveIntensity = 1;
    this.environmentIntensity = 1;
    this.specularIntensity = 1;
    this.disableBumpMap = false;
    this.ambientTextureStrength = 1;
    this.ambientTextureImpactOnAnalyticalLights = _PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this.metallicF0Factor = 1;
    this.metallicReflectanceColor = Color3.White();
    this.useOnlyMetallicFromMetallicReflectanceTexture = false;
    this.ambientColor = new Color3(0, 0, 0);
    this.albedoColor = new Color3(1, 1, 1);
    this.reflectivityColor = new Color3(1, 1, 1);
    this.reflectionColor = new Color3(1, 1, 1);
    this.emissiveColor = new Color3(0, 0, 0);
    this.microSurface = 1;
    this.useLightmapAsShadowmap = false;
    this.useAlphaFromAlbedoTexture = false;
    this.forceAlphaTest = false;
    this.alphaCutOff = 0.4;
    this.useSpecularOverAlpha = true;
    this.useMicroSurfaceFromReflectivityMapAlpha = false;
    this.useRoughnessFromMetallicTextureAlpha = true;
    this.useRoughnessFromMetallicTextureGreen = false;
    this.useMetallnessFromMetallicTextureBlue = false;
    this.useAmbientOcclusionFromMetallicTextureRed = false;
    this.useAmbientInGrayScale = false;
    this.useAutoMicroSurfaceFromReflectivityMap = false;
    this.useRadianceOverAlpha = true;
    this.useObjectSpaceNormalMap = false;
    this.useParallax = false;
    this.useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this.disableLighting = false;
    this.forceIrradianceInFragment = false;
    this.maxSimultaneousLights = 4;
    this.invertNormalMapX = false;
    this.invertNormalMapY = false;
    this.twoSidedLighting = false;
    this.useAlphaFresnel = false;
    this.useLinearAlphaFresnel = false;
    this.environmentBRDFTexture = null;
    this.forceNormalForward = false;
    this.enableSpecularAntiAliasing = false;
    this.useHorizonOcclusion = true;
    this.useRadianceOcclusion = true;
    this.unlit = false;
    this.applyDecalMapAfterDetailMap = false;
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
  }
  /**
   * Returns the name of this material class.
   */
  getClassName() {
    return "PBRMaterial";
  }
  /**
   * Makes a duplicate of the current material.
   * @param name - name to use for the new material.
   * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
   * @param rootUrl defines the root URL to use to load textures
   */
  clone(name52, cloneTexturesOnlyOnce = true, rootUrl = "") {
    const clone = SerializationHelper.Clone(() => new _PBRMaterial(name52, this.getScene()), this, { cloneTexturesOnlyOnce });
    clone.id = name52;
    clone.name = name52;
    this.stencil.copyTo(clone.stencil);
    this._clonePlugins(clone, rootUrl);
    return clone;
  }
  /**
   * Serializes this PBR Material.
   * @returns - An object with the serialized material.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.PBRMaterial";
    return serializationObject;
  }
  // Statics
  /**
   * Parses a PBR Material from a serialized object.
   * @param source - Serialized object.
   * @param scene - BJS scene instance.
   * @param rootUrl - url for the scene object
   * @returns - PBRMaterial
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _PBRMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    Material._parsePlugins(source, material, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    if (source.iridescence) {
      material.iridescence.parse(source.iridescence, scene, rootUrl);
    }
    return material;
  }
};
PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "directIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "specularIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "disableBumpMap", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureStrength", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallic", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicF0Factor", void 0);
__decorate([
  serializeAsColor3(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurfaceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
], PBRMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serializeAsColor3("ambient"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientColor", void 0);
__decorate([
  serializeAsColor3("albedo"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoColor", void 0);
__decorate([
  serializeAsColor3("reflectivity"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityColor", void 0);
__decorate([
  serializeAsColor3("reflection"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionColor", void 0);
__decorate([
  serializeAsColor3("emissive"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurface", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "forceAlphaTest", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
__decorate([
  serialize()
], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
__decorate([
  serialize()
], PBRMaterial.prototype, "useGLTFLightFalloff", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAlphaFresnel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceNormalForward", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "unlit", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
RegisterClass("BABYLON.PBRMaterial", PBRMaterial);

// node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
  if (!texture) {
    return;
  }
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
  const internalFormat = this._getInternalFormat(format);
  const textureType = this._getWebGLTextureType(type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (texture.width % 4 !== 0) {
    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
  }
  if (compression && data) {
    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
  } else {
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
  }
  if (texture.generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
  const texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
  if (generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
  const gl = this._gl;
  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  texture.isCube = true;
  texture.format = format;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
  }
  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  const width = size;
  const height = width;
  texture.width = width;
  texture.height = height;
  texture.invertY = invertY;
  texture._compression = compression;
  const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (!isPot) {
    generateMipMaps = false;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  } else {
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
    const level = 0;
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      if (compression) {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, void 0);
      } else {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);
      }
    }
    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
  if (data && generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.isReady = true;
  return texture;
};
ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression = null, level = 0) {
  texture._bufferViewArray = data;
  texture.format = format;
  texture.type = type;
  texture.invertY = invertY;
  texture._compression = compression;
  const gl = this._gl;
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
  let needConversion = false;
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
    needConversion = true;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (texture.width % 4 !== 0) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
    let faceData = data[faceIndex];
    if (compression) {
      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
    } else {
      if (needConversion) {
        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
      }
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
    }
  }
  const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (isPot && texture.generateMipMaps && level === 0) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
  const gl = this._gl;
  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene === null || scene === void 0 ? void 0 : scene.addPendingData(texture);
  texture.url = url;
  texture.isReady = false;
  this._internalTexturesCache.push(texture);
  const onerror = (request, exception) => {
    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  const internalCallback = (data) => {
    const width = texture.width;
    const faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      const textureType = this._getWebGLTextureType(type);
      let internalFormat = this._getInternalFormat(format);
      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
      let needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      this._unpackFlipY(false);
      const mipData = mipmapGenerator(faceDataArrays);
      for (let level = 0; level < mipData.length; level++) {
        const mipSize = width >> level;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          let mipFaceData = mipData[level][faceIndex];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
        }
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    } else {
      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, (data) => {
    internalCallback(data);
  }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
  return texture;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    const texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const internalType = this._getWebGLTextureType(textureType);
    const internalFormat = this._getInternalFormat(format);
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture = class _RawTexture extends Texture {
  /**
   * Instantiates a new RawTexture.
   * Raw texture can help creating a texture directly from an array of data.
   * This can be super useful if you either get the data from an uncompressed source or
   * if you wish to create your texture pixel by pixel.
   * @param data define the array of data to use to create the texture (null to create an empty texture)
   * @param width define the width of the texture
   * @param height define the height of the texture
   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps define whether mip maps should be generated or not
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   */
  constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {
    super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
    this.format = format;
    if (!this._engine) {
      return;
    }
    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
      samplingMode = 1;
    }
    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
      samplingMode = 1;
    }
    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
  }
  /**
   * Updates the texture underlying data.
   * @param data Define the new data of the texture
   */
  update(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
  }
  /**
   * Creates a luminance texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance texture
   */
  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a luminance alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance alpha texture
   */
  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates an alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the alpha texture
   */
  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a RGB texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGB alpha texture
   */
  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
  }
  /**
   * Creates a R texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  }
  /**
   * Creates a R storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
  }
};

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialDefaults.js
var GreasedLineMaterialDefaults = class {
};
GreasedLineMaterialDefaults.DEFAULT_COLOR = Color3.White();
GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED = 1;
GreasedLineMaterialDefaults.DEFAULT_WIDTH = 0.1;

// node_modules/@babylonjs/core/Misc/greasedLineTools.js
var GreasedLineTools = class _GreasedLineTools {
  /**
   * Converts GreasedLinePoints to number[][]
   * @param points GreasedLinePoints
   * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]
   */
  static ConvertPoints(points) {
    if (points.length && Array.isArray(points) && typeof points[0] === "number") {
      return [points];
    } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === "number") {
      return points;
    } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {
      const positions = [];
      for (let j = 0; j < points.length; j++) {
        const p = points[j];
        positions.push(p.x, p.y, p.z);
      }
      return [positions];
    } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {
      const positions = [];
      const vectorPoints = points;
      vectorPoints.forEach((p) => {
        positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));
      });
      return positions;
    } else if (points instanceof Float32Array) {
      return [Array.from(points)];
    } else if (points.length && points[0] instanceof Float32Array) {
      const positions = [];
      points.forEach((p) => {
        positions.push(Array.from(p));
      });
      return positions;
    }
    return [];
  }
  /**
   * Omit zero length lines predicate for the MeshesToLines function
   * @param p1 point1 position of the face
   * @param p2 point2 position of the face
   * @param p3 point3 position of the face
   * @returns original points or null if any edge length is zero
   */
  static OmitZeroLengthPredicate(p1, p2, p3) {
    const fileredPoints = [];
    if (p2.subtract(p1).lengthSquared() > 0) {
      fileredPoints.push([p1, p2]);
    }
    if (p3.subtract(p2).lengthSquared() > 0) {
      fileredPoints.push([p2, p3]);
    }
    if (p1.subtract(p3).lengthSquared() > 0) {
      fileredPoints.push([p3, p1]);
    }
    return fileredPoints.length === 0 ? null : fileredPoints;
  }
  /**
   * Omit duplicate lines predicate for the MeshesToLines function
   * @param p1 point1 position of the face
   * @param p2 point2 position of the face
   * @param p3 point3 position of the face
   * @returns original points or null if any edge length is zero
   */
  static OmitDuplicatesPredicate(p1, p2, p3, points) {
    const fileredPoints = [];
    if (!_GreasedLineTools._SearchInPoints(p1, p2, points)) {
      fileredPoints.push([p1, p2]);
    }
    if (!_GreasedLineTools._SearchInPoints(p2, p3, points)) {
      fileredPoints.push([p2, p3]);
    }
    if (!_GreasedLineTools._SearchInPoints(p3, p1, points)) {
      fileredPoints.push([p3, p1]);
    }
    return fileredPoints.length === 0 ? null : fileredPoints;
  }
  static _SearchInPoints(p1, p2, points) {
    var _a, _b, _c;
    for (const ps of points) {
      for (let i = 0; i < ps.length; i++) {
        if ((_a = ps[i]) === null || _a === void 0 ? void 0 : _a.equals(p1)) {
          if (((_b = ps[i + 1]) === null || _b === void 0 ? void 0 : _b.equals(p2)) || ((_c = ps[i - 1]) === null || _c === void 0 ? void 0 : _c.equals(p2))) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Gets mesh triangles as line positions
   * @param meshes array of meshes
   * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput
   * @returns array of arrays of points
   */
  static MeshesToLines(meshes, predicate) {
    const points = [];
    meshes.forEach((m, meshIndex) => {
      const vertices = m.getVerticesData(VertexBuffer.PositionKind);
      const indices = m.getIndices();
      if (vertices && indices) {
        for (let i = 0, ii = 0; i < indices.length; i++) {
          const vi1 = indices[ii++] * 3;
          const vi2 = indices[ii++] * 3;
          const vi3 = indices[ii++] * 3;
          const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);
          const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);
          const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);
          if (predicate) {
            const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);
            if (pointsFromPredicate) {
              for (const p of pointsFromPredicate) {
                points.push(p);
              }
            }
          } else {
            points.push([p1, p2], [p2, p3], [p3, p1]);
          }
        }
      }
    });
    return points;
  }
  /**
   * Converts number coordinates to Vector3s
   * @param points number array of x, y, z, x, y z, ... coordinates
   * @returns Vector3 array
   */
  static ToVector3Array(points) {
    if (Array.isArray(points[0])) {
      const array2 = [];
      const inputArray2 = points;
      for (const subInputArray of inputArray2) {
        const subArray = [];
        for (let i = 0; i < subInputArray.length; i += 3) {
          subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));
        }
        array2.push(subArray);
      }
      return array2;
    }
    const inputArray = points;
    const array = [];
    for (let i = 0; i < inputArray.length; i += 3) {
      array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));
    }
    return array;
  }
  /**
   * Gets a number array from a Vector3 array.
   * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.
   * @param points Vector3 array
   * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]
   */
  static ToNumberArray(points) {
    return points.flatMap((v) => [v.x, v.y, v.z]);
  }
  /**
   * Calculates the sum of points of every line and the number of points in each line.
   * This function is useful when you are drawing multiple lines in one mesh and you want
   * to know the counts. For example for creating an offsets table.
   * @param points point array
   * @returns points count info
   */
  static GetPointsCountInfo(points) {
    const counts = new Array(points.length);
    let total = 0;
    for (let n = points.length; n--; ) {
      counts[n] = points[n].length / 3;
      total += counts[n];
    }
    return { total, counts };
  }
  /**
   * Gets the length of the line counting all it's segments length
   * @param data array of line points
   * @returns length of the line
   */
  static GetLineLength(data) {
    if (data.length === 0) {
      return 0;
    }
    let points;
    if (typeof data[0] === "number") {
      points = _GreasedLineTools.ToVector3Array(data);
    } else {
      points = data;
    }
    const tmp = TmpVectors.Vector3[0];
    let length = 0;
    for (let index = 0; index < points.length - 1; index++) {
      const point1 = points[index];
      const point2 = points[index + 1];
      length += point2.subtractToRef(point1, tmp).length();
    }
    return length;
  }
  /**
   * Divides a segment into smaller segments.
   * A segment is a part of the line between it's two points.
   * @param point1 first point of the line
   * @param point2 second point of the line
   * @param segmentCount number of segments we want to have in the divided line
   * @returns
   */
  static SegmentizeSegmentByCount(point1, point2, segmentCount) {
    const dividedLinePoints = [];
    const diff = point2.subtract(point1);
    const divisor = TmpVectors.Vector3[0];
    divisor.setAll(segmentCount);
    const segmentVector = TmpVectors.Vector3[1];
    diff.divideToRef(divisor, segmentVector);
    let nextPoint = point1.clone();
    dividedLinePoints.push(nextPoint);
    for (let index = 0; index < segmentCount; index++) {
      nextPoint = nextPoint.clone();
      dividedLinePoints.push(nextPoint.addInPlace(segmentVector));
    }
    return dividedLinePoints;
  }
  /**
   * Divides a line into segments.
   * A segment is a part of the line between it's two points.
   * @param what line points
   * @param segmentLength length of each segment of the resulting line (distance between two line points)
   * @returns line point
   */
  static SegmentizeLineBySegmentLength(what, segmentLength) {
    const subLines = what[0] instanceof Vector3 ? _GreasedLineTools.GetLineSegments(what) : typeof what[0] === "number" ? _GreasedLineTools.GetLineSegments(_GreasedLineTools.ToVector3Array(what)) : what;
    const points = [];
    subLines.forEach((s) => {
      if (s.length > segmentLength) {
        const segments = _GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));
        segments.forEach((seg) => {
          points.push(seg);
        });
      } else {
        points.push(s.point1);
        points.push(s.point2);
      }
    });
    return points;
  }
  /**
   * Divides a line into segments.
   * A segment is a part of the line between it's two points.
   * @param what line points
   * @param segmentCount number of segments
   * @returns line point
   */
  static SegmentizeLineBySegmentCount(what, segmentCount) {
    const points = typeof what[0] === "number" ? _GreasedLineTools.ToVector3Array(what) : what;
    const segmentLength = _GreasedLineTools.GetLineLength(points) / segmentCount;
    return _GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);
  }
  /**
   * Gets line segments.
   * A segment is a part of the line between it's two points.
   * @param points line points
   * @returns segments information of the line segment including starting point, ending point and the distance between them
   */
  static GetLineSegments(points) {
    const segments = [];
    for (let index = 0; index < points.length - 1; index++) {
      const point1 = points[index];
      const point2 = points[index + 1];
      const length = point2.subtract(point1).length();
      segments.push({ point1, point2, length });
    }
    return segments;
  }
  /**
   * Gets the minimum and the maximum length of a line segment in the line.
   * A segment is a part of the line between it's two points.
   * @param points line points
   * @returns
   */
  static GetMinMaxSegmentLength(points) {
    const subLines = _GreasedLineTools.GetLineSegments(points);
    const sorted = subLines.sort((s) => s.length);
    return {
      min: sorted[0].length,
      max: sorted[sorted.length - 1].length
    };
  }
  /**
   * Finds the last visible position in world space of the line according to the visibility parameter
   * @param lineSegments segments of the line
   * @param lineLength total length of the line
   * @param visbility normalized value of visibility
   * @returns world space coordinate of the last visible piece of the line
   */
  static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {
    const lengthVisibilityRatio = lineLength * visbility;
    let sumSegmentLengths = 0;
    let segmentIndex = 0;
    const lineSegmentsLength = lineSegments.length;
    for (let i = 0; i < lineSegmentsLength; i++) {
      if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {
        segmentIndex = i;
        break;
      }
      sumSegmentLengths += lineSegments[i].length;
    }
    const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;
    lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);
    TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);
    if (!localSpace) {
      TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);
    }
    return TmpVectors.Vector3[1].clone();
  }
  /**
   * Creates lines in a shape of circle/arc.
   * A segment is a part of the line between it's two points.
   * @param radiusX radiusX of the circle
   * @param segments number of segments in the circle
   * @param z z coordinate of the points. Defaults to 0.
   * @param radiusY radiusY of the circle - you can draw an oval if using different values
   * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.
   * @returns line points
   */
  static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {
    const points = [];
    for (let i = 0; i <= segments; i++) {
      points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));
    }
    return points;
  }
  /**
   * Gets line points in a shape of a bezier curve
   * @param p0 bezier point0
   * @param p1 bezier point1
   * @param p2 bezier point2
   * @param segments number of segments in the curve
   * @returns
   */
  static GetBezierLinePoints(p0, p1, p2, segments) {
    return Curve3.CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap((v) => [v.x, v.y, v.z]);
  }
  /**
   *
   * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)
   * @param direction direction which the arrow points to
   * @param length length (size) of the arrow cap itself
   * @param widthUp the arrow width above the line
   * @param widthDown the arrow width belove the line
   * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.
   * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.
   * @returns
   */
  static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {
    const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];
    const widths = [widthUp, widthDown, widthStartUp, widthStartDown];
    return {
      points,
      widths
    };
  }
  /**
   * Gets 3D positions of points from a text and font
   * @param text Text
   * @param size Size of the font
   * @param resolution Resolution of the font
   * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)
   * @param z z coordinate
   * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.
   * @returns number[][] of 3D positions
   */
  static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {
    const allPoints = [];
    const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);
    for (const sp of shapePaths) {
      for (const p of sp.paths) {
        const points = [];
        const points2d = p.getPoints();
        for (const p2d of points2d) {
          points.push(p2d.x, p2d.y, z);
        }
        allPoints.push(points);
      }
      if (includeInner) {
        for (const h of sp.holes) {
          const holes = [];
          const points2d = h.getPoints();
          for (const p2d of points2d) {
            holes.push(p2d.x, p2d.y, z);
          }
          allPoints.push(holes);
        }
      }
    }
    return allPoints;
  }
  /**
   * Converts an array of Color3 to Uint8Array
   * @param colors Arrray of Color3
   * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]
   */
  static Color3toRGBAUint8(colors) {
    const colorTable = new Uint8Array(colors.length * 4);
    for (let i = 0, j = 0; i < colors.length; i++) {
      colorTable[j++] = colors[i].r * 255;
      colorTable[j++] = colors[i].g * 255;
      colorTable[j++] = colors[i].b * 255;
      colorTable[j++] = 255;
    }
    return colorTable;
  }
  /**
   * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.
   * @param name name of the texture
   * @param colors Uint8Array of colors
   */
  static CreateColorsTexture(name52, colors, colorsSampling, scene) {
    const colorsArray = _GreasedLineTools.Color3toRGBAUint8(colors);
    const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);
    colorsTexture.name = name52;
    return colorsTexture;
  }
  /**
   * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.
   * For fast switching using the useColors property without the need to use defines.
   * @param scene Scene
   * @returns empty colors texture
   */
  static PrepareEmptyColorsTexture(scene) {
    if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {
      const colorsArray = new Uint8Array(4);
      GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);
      GreasedLineMaterialDefaults.EmptyColorsTexture.name = "grlEmptyColorsTexture";
    }
    return GreasedLineMaterialDefaults.EmptyColorsTexture;
  }
  /**
   * Diposes the shared empty colors texture
   */
  static DisposeEmptyColorsTexture() {
    var _a;
    (_a = GreasedLineMaterialDefaults.EmptyColorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    GreasedLineMaterialDefaults.EmptyColorsTexture = null;
  }
  /**
   * Converts boolean to number.
   * @param bool
   * @returns 1 if true, 0 if false.
   */
  static BooleanToNumber(bool) {
    return bool ? 1 : 0;
  }
};

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialInterfaces.js
var GreasedLineMeshMaterialType;
(function(GreasedLineMeshMaterialType2) {
  GreasedLineMeshMaterialType2[GreasedLineMeshMaterialType2["MATERIAL_TYPE_STANDARD"] = 0] = "MATERIAL_TYPE_STANDARD";
  GreasedLineMeshMaterialType2[GreasedLineMeshMaterialType2["MATERIAL_TYPE_PBR"] = 1] = "MATERIAL_TYPE_PBR";
  GreasedLineMeshMaterialType2[GreasedLineMeshMaterialType2["MATERIAL_TYPE_SIMPLE"] = 2] = "MATERIAL_TYPE_SIMPLE";
})(GreasedLineMeshMaterialType || (GreasedLineMeshMaterialType = {}));
var GreasedLineMeshColorMode;
(function(GreasedLineMeshColorMode2) {
  GreasedLineMeshColorMode2[GreasedLineMeshColorMode2["COLOR_MODE_SET"] = 0] = "COLOR_MODE_SET";
  GreasedLineMeshColorMode2[GreasedLineMeshColorMode2["COLOR_MODE_ADD"] = 1] = "COLOR_MODE_ADD";
  GreasedLineMeshColorMode2[GreasedLineMeshColorMode2["COLOR_MODE_MULTIPLY"] = 2] = "COLOR_MODE_MULTIPLY";
})(GreasedLineMeshColorMode || (GreasedLineMeshColorMode = {}));
var GreasedLineMeshColorDistributionType;
(function(GreasedLineMeshColorDistributionType2) {
  GreasedLineMeshColorDistributionType2[GreasedLineMeshColorDistributionType2["COLOR_DISTRIBUTION_TYPE_SEGMENT"] = 0] = "COLOR_DISTRIBUTION_TYPE_SEGMENT";
  GreasedLineMeshColorDistributionType2[GreasedLineMeshColorDistributionType2["COLOR_DISTRIBUTION_TYPE_LINE"] = 1] = "COLOR_DISTRIBUTION_TYPE_LINE";
})(GreasedLineMeshColorDistributionType || (GreasedLineMeshColorDistributionType = {}));

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterial.js
var MaterialGreasedLineDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.GREASED_LINE_HAS_COLOR = false;
    this.GREASED_LINE_SIZE_ATTENUATION = false;
    this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;
    this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;
    this.GREASED_LINE_CAMERA_FACING = true;
  }
};
var GreasedLinePluginMaterial = class _GreasedLinePluginMaterial extends MaterialPluginBase {
  /**
   * Creates a new instance of the GreasedLinePluginMaterial
   * @param material base material for the plugin
   * @param scene the scene
   * @param options plugin options
   */
  constructor(material, scene, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    options = options || {
      color: GreasedLineMaterialDefaults.DEFAULT_COLOR
    };
    const defines = new MaterialGreasedLineDefines();
    defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;
    defines.GREASED_LINE_SIZE_ATTENUATION = (_a = options.sizeAttenuation) !== null && _a !== void 0 ? _a : false;
    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;
    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene !== null && scene !== void 0 ? scene : material.getScene()).useRightHandedSystem;
    defines.GREASED_LINE_CAMERA_FACING = (_b = options.cameraFacing) !== null && _b !== void 0 ? _b : true;
    super(material, _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines);
    this.colorsTexture = null;
    this._scene = scene !== null && scene !== void 0 ? scene : material.getScene();
    this._engine = this._scene.getEngine();
    this._cameraFacing = (_c = options.cameraFacing) !== null && _c !== void 0 ? _c : true;
    this.visibility = (_d = options.visibility) !== null && _d !== void 0 ? _d : 1;
    this.useDash = (_e = options.useDash) !== null && _e !== void 0 ? _e : false;
    this.dashRatio = (_f = options.dashRatio) !== null && _f !== void 0 ? _f : 0.5;
    this.dashOffset = (_g = options.dashOffset) !== null && _g !== void 0 ? _g : 0;
    this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
    this._sizeAttenuation = (_h = options.sizeAttenuation) !== null && _h !== void 0 ? _h : false;
    this.colorMode = (_j = options.colorMode) !== null && _j !== void 0 ? _j : GreasedLineMeshColorMode.COLOR_MODE_SET;
    this._color = (_k = options.color) !== null && _k !== void 0 ? _k : null;
    this.useColors = (_l = options.useColors) !== null && _l !== void 0 ? _l : false;
    this._colorsDistributionType = (_m = options.colorDistributionType) !== null && _m !== void 0 ? _m : GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;
    this.colorsSampling = (_o = options.colorsSampling) !== null && _o !== void 0 ? _o : RawTexture.NEAREST_NEAREST;
    this._colors = (_p = options.colors) !== null && _p !== void 0 ? _p : null;
    this.dashCount = (_q = options.dashCount) !== null && _q !== void 0 ? _q : 1;
    this.resolution = (_r = options.resolution) !== null && _r !== void 0 ? _r : new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight());
    if (options.colorsTexture) {
      this.colorsTexture = options.colorsTexture;
    } else {
      if (this._colors) {
        this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);
      } else {
        this._color = (_s = this._color) !== null && _s !== void 0 ? _s : GreasedLineMaterialDefaults.DEFAULT_COLOR;
        GreasedLineTools.PrepareEmptyColorsTexture(this._scene);
      }
    }
    this._engine.onDisposeObservable.add(() => {
      GreasedLineTools.DisposeEmptyColorsTexture();
    });
    this._enable(true);
  }
  /**
   * Get the shader attributes
   * @param attributes array which will be filled with the attributes
   */
  getAttributes(attributes) {
    attributes.push("grl_offsets");
    attributes.push("grl_widths");
    attributes.push("grl_colorPointers");
    attributes.push("grl_counters");
    if (this._cameraFacing) {
      attributes.push("grl_previousAndSide");
      attributes.push("grl_nextAndCounters");
    } else {
      attributes.push("grl_slopes");
    }
  }
  /**
   * Get the shader samplers
   * @param samplers
   */
  getSamplers(samplers) {
    samplers.push("grl_colors");
  }
  /**
   * Get the shader textures
   * @param activeTextures
   */
  getActiveTextures(activeTextures) {
    if (this.colorsTexture) {
      activeTextures.push(this.colorsTexture);
    }
  }
  /**
   * Get the shader uniforms
   * @returns uniforms
   */
  getUniforms() {
    const ubo = [
      { name: "grl_singleColor", size: 3, type: "vec3" },
      { name: "grl_dashOptions", size: 4, type: "vec4" },
      { name: "grl_colorMode_visibility_colorsWidth_useColors", size: 4, type: "vec4" }
    ];
    if (this._cameraFacing) {
      ubo.push({ name: "grl_projection", size: 16, type: "mat4" }, { name: "grl_aspect_resolution_lineWidth", size: 4, type: "vec4" });
    }
    return {
      ubo,
      vertex: this._cameraFacing ? `
                uniform vec4 grl_aspect_resolution_lineWidth;
                uniform mat4 grl_projection;
                ` : "",
      fragment: `
                uniform vec4 grl_dashOptions;
                uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;
                uniform vec3 grl_singleColor;
                `
    };
  }
  // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh
  // and it doesn't make sense to disable it on the mesh
  get isEnabled() {
    return true;
  }
  /**
   * Bind the uniform buffer
   * @param uniformBuffer
   */
  bindForSubMesh(uniformBuffer) {
    var _a;
    if (this._cameraFacing) {
      const activeCamera = this._scene.activeCamera;
      if (activeCamera) {
        const projection = activeCamera.getProjectionMatrix();
        uniformBuffer.updateMatrix("grl_projection", projection);
      } else {
        throw Error("GreasedLinePluginMaterial requires an active camera.");
      }
      const resolutionLineWidth = TmpVectors.Vector4[0];
      resolutionLineWidth.x = this._aspect;
      resolutionLineWidth.y = this._resolution.x;
      resolutionLineWidth.z = this._resolution.y;
      resolutionLineWidth.w = this.width;
      uniformBuffer.updateVector4("grl_aspect_resolution_lineWidth", resolutionLineWidth);
    }
    const dashOptions = TmpVectors.Vector4[0];
    dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);
    dashOptions.y = this._dashArray;
    dashOptions.z = this.dashOffset;
    dashOptions.w = this.dashRatio;
    uniformBuffer.updateVector4("grl_dashOptions", dashOptions);
    const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];
    colorModeVisibilityColorsWidthUseColors.x = this.colorMode;
    colorModeVisibilityColorsWidthUseColors.y = this.visibility;
    colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;
    colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);
    uniformBuffer.updateVector4("grl_colorMode_visibility_colorsWidth_useColors", colorModeVisibilityColorsWidthUseColors);
    if (this._color) {
      uniformBuffer.updateColor3("grl_singleColor", this._color);
    }
    uniformBuffer.setTexture("grl_colors", (_a = this.colorsTexture) !== null && _a !== void 0 ? _a : GreasedLineMaterialDefaults.EmptyColorsTexture);
  }
  /**
   * Prepare the defines
   * @param defines
   * @param _scene
   * @param _mesh
   */
  prepareDefines(defines, _scene, _mesh) {
    defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;
    defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;
    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;
    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;
    defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;
  }
  /**
   * Get the class name
   * @returns class name
   */
  getClassName() {
    return _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;
  }
  /**
   * Get shader code
   * @param shaderType vertex/fragment
   * @returns shader code
   */
  getCustomCode(shaderType) {
    if (shaderType === "vertex") {
      const obj = {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        CUSTOM_VERTEX_DEFINITIONS: `
                attribute float grl_widths;
                attribute vec3 grl_offsets;
                attribute float grl_colorPointers;

                varying float grlCounters;
                varying float grlColorPointer;

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute vec4 grl_previousAndSide;
                    attribute vec4 grl_nextAndCounters;

                    vec2 grlFix( vec4 i, float aspect ) {
                        vec2 res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute vec3 grl_slopes;
                    attribute float grl_counters;
                #endif
                `,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        CUSTOM_VERTEX_UPDATE_POSITION: `
                #ifdef GREASED_LINE_CAMERA_FACING
                    vec3 grlPositionOffset = grl_offsets;
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);
                #endif
                `,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        CUSTOM_VERTEX_MAIN_END: `
                grlColorPointer = grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    float grlAspect = grl_aspect_resolution_lineWidth.x;
                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;


                    vec3 grlPrevious = grl_previousAndSide.xyz;
                    float grlSide = grl_previousAndSide.w;

                    vec3 grlNext = grl_nextAndCounters.xyz;
                    grlCounters = grl_nextAndCounters.w;

                    mat4 grlMatrix = viewProjection * finalWorld;
                    vec4 grlFinalPosition = grlMatrix * vec4( positionUpdated , 1.0 );
                    vec4 grlPrevPos = grlMatrix * vec4( grlPrevious + grlPositionOffset, 1.0 );
                    vec4 grlNextPos = grlMatrix * vec4( grlNext + grlPositionOffset, 1.0 );

                    vec2 grlCurrentP = grlFix( grlFinalPosition, grlAspect );
                    vec2 grlPrevP = grlFix( grlPrevPos, grlAspect );
                    vec2 grlNextP = grlFix( grlNextPos, grlAspect );

                    float grlWidth = grlBaseWidth * grl_widths;

                    vec2 grlDir;
                    if( grlNextP == grlCurrentP ) grlDir = normalize( grlCurrentP - grlPrevP );
                    else if( grlPrevP == grlCurrentP ) grlDir = normalize( grlNextP - grlCurrentP );
                    else {
                        vec2 grlDir1 = normalize( grlCurrentP - grlPrevP );
                        vec2 grlDir2 = normalize( grlNextP - grlCurrentP );
                        grlDir = normalize( grlDir1 + grlDir2 );
                    }
                    vec4 grlNormal = vec4( -grlDir.y, grlDir.x, 0., 1. );
                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
                        grlNormal.xy *= -.5 * grlWidth;
                    #else
                        grlNormal.xy *= .5 * grlWidth;
                    #endif

                    grlNormal *= grl_projection;

                    #ifdef GREASED_LINE_SIZE_ATTENUATION
                        grlNormal.xy *= grlFinalPosition.w;
                        grlNormal.xy /= ( vec4( grl_aspect_resolution_lineWidth.yz, 0., 1. ) * grl_projection ).xy;
                    #endif

                    grlFinalPosition.xy += grlNormal.xy * grlSide;
                    gl_Position = grlFinalPosition;

                    vPositionW = vec3(grlFinalPosition);
                #else
                    grlCounters = grl_counters;
                #endif
                `
      };
      this._cameraFacing && (obj["!gl_Position\\=viewProjection\\*worldPos;"] = "//");
      return obj;
    }
    if (shaderType === "fragment") {
      return {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        CUSTOM_FRAGMENT_DEFINITIONS: `
                    varying float grlCounters;
                    varying float grlColorPointer;
                    uniform sampler2D grl_colors;
                `,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        CUSTOM_FRAGMENT_MAIN_END: `
                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;
                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;
                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;
                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;

                    float grlUseDash = grl_dashOptions.x;
                    float grlDashArray = grl_dashOptions.y;
                    float grlDashOffset = grl_dashOptions.z;
                    float grlDashRatio = grl_dashOptions.w;

                    gl_FragColor.a *= step(grlCounters, grlVisibility);
                    if( gl_FragColor.a == 0. ) discard;

                    if(grlUseDash == 1.){
                        gl_FragColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));
                        if (gl_FragColor.a == 0.) discard;
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {
                            gl_FragColor.rgb = grl_singleColor;
                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {
                            gl_FragColor.rgb += grl_singleColor;
                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {
                            gl_FragColor.rgb *= grl_singleColor;
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);
                            #else
                                vec4 grlColor = texture2D(grl_colors, vec2(grlColorPointer/grlColorsWidth, 0.), 0.);
                            #endif
                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {
                                gl_FragColor = grlColor;
                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {
                                gl_FragColor += grlColor;
                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {
                                gl_FragColor *= grlColor;
                            }
                        }
                    #endif

                `
      };
    }
    return null;
  }
  /**
   * Disposes the plugin material.
   */
  dispose() {
    var _a;
    (_a = this.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    super.dispose();
  }
  /**
   * Returns the colors used to colorize the line
   */
  get colors() {
    return this._colors;
  }
  /**
   * Sets the colors used to colorize the line
   */
  set colors(value) {
    this.setColors(value);
  }
  /**
   * Creates or updates the colors texture
   * @param colors color table RGBA
   * @param lazy if lazy, the colors are not updated
   * @param forceNewTexture force creation of a new texture
   * @returns
   */
  setColors(colors, lazy = false, forceNewTexture = false) {
    var _a, _b, _c, _d;
    const origColorsCount = (_b = (_a = this._colors) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    this._colors = colors;
    if (colors === null || colors.length === 0) {
      (_c = this.colorsTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      return;
    }
    if (lazy && !forceNewTexture) {
      return;
    }
    if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
      this.colorsTexture.update(colorArray);
    } else {
      (_d = this.colorsTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);
    }
  }
  /**
   * Updates the material. Use when material created in lazy mode.
   */
  updateLazy() {
    if (this._colors) {
      this.setColors(this._colors, false, true);
    }
  }
  /**
   * Gets the number of dashes in the line
   */
  get dashCount() {
    return this._dashCount;
  }
  /**
   * Sets the number of dashes in the line
   * @param value dash
   */
  set dashCount(value) {
    this._dashCount = value;
    this._dashArray = 1 / value;
  }
  /**
   * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
   * Not supported for non camera facing lines.
   */
  get sizeAttenuation() {
    return this._sizeAttenuation;
  }
  /**
   * Turn on/off size attenuation of the width option and widths array.
   * Not supported for non camera facing lines.
   * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
   */
  set sizeAttenuation(value) {
    this._sizeAttenuation = value;
    this.markAllDefinesAsDirty();
  }
  /**
   * Gets the color of the line
   */
  get color() {
    return this._color;
  }
  /**
   * Sets the color of the line
   * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true
   */
  set color(value) {
    this.setColor(value);
  }
  /**
   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
   * @param value color
   */
  setColor(value, doNotMarkDirty = false) {
    if (this._color === null && value !== null || this._color !== null && value === null) {
      this._color = value;
      !doNotMarkDirty && this.markAllDefinesAsDirty();
    } else {
      this._color = value;
    }
  }
  /**
   * Gets the color distributiopn type
   */
  get colorsDistributionType() {
    return this._colorsDistributionType;
  }
  /**
   * Sets the color distribution type
   * @see GreasedLineMeshColorDistributionType
   * @param value color distribution type
   */
  set colorsDistributionType(value) {
    this._colorsDistributionType = value;
    this.markAllDefinesAsDirty();
  }
  /**
   * Gets the resolution
   */
  get resolution() {
    return this._resolution;
  }
  /**
   * Sets the resolution
   * @param value resolution of the screen for GreasedLine
   */
  set resolution(value) {
    this._aspect = value.x / value.y;
    this._resolution = value;
  }
  /**
   * Serializes this plugin material
   * @returns serializationObjec
   */
  serialize() {
    const serializationObject = super.serialize();
    const greasedLineMaterialOptions = {
      colorDistributionType: this._colorsDistributionType,
      colorsSampling: this.colorsSampling,
      colorMode: this.colorMode,
      dashCount: this._dashCount,
      dashOffset: this.dashOffset,
      dashRatio: this.dashRatio,
      resolution: this._resolution,
      sizeAttenuation: this._sizeAttenuation,
      useColors: this.useColors,
      useDash: this.useDash,
      visibility: this.visibility,
      width: this.width
    };
    this._colors && (greasedLineMaterialOptions.colors = this._colors);
    this._color && (greasedLineMaterialOptions.color = this._color);
    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
    return serializationObject;
  }
  /**
   * Parses a serialized objects
   * @param source serialized object
   * @param scene scene
   * @param rootUrl root url for textures
   */
  parse(source, scene, rootUrl) {
    var _a;
    super.parse(source, scene, rootUrl);
    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
    (_a = this.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    greasedLineMaterialOptions.color && this.setColor(greasedLineMaterialOptions.color, true);
    greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);
    greasedLineMaterialOptions.colors && (this.colors = greasedLineMaterialOptions.colors);
    greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);
    greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);
    greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);
    greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);
    greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);
    greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);
    greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);
    greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);
    greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);
    greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);
    greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);
    if (this.colors) {
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);
    } else {
      GreasedLineTools.PrepareEmptyColorsTexture(scene);
    }
    this.markAllDefinesAsDirty();
  }
  /**
   * Makes a duplicate of the current configuration into another one.
   * @param plugin define the config where to copy the info
   */
  copyTo(plugin) {
    var _a;
    const dest = plugin;
    (_a = dest.colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    if (this._colors) {
      dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);
    }
    dest.setColor(this.color, true);
    dest.colorsDistributionType = this.colorsDistributionType;
    dest.colorsSampling = this.colorsSampling;
    dest.colorMode = this.colorMode;
    dest.useColors = this.useColors;
    dest.visibility = this.visibility;
    dest.useDash = this.useDash;
    dest.dashCount = this.dashCount;
    dest.dashRatio = this.dashRatio;
    dest.dashOffset = this.dashOffset;
    dest.width = this.width;
    dest.sizeAttenuation = this.sizeAttenuation;
    dest.resolution = this.resolution;
    dest.markAllDefinesAsDirty();
  }
};
GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME = "GreasedLinePluginMaterial";
RegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);

// node_modules/@babylonjs/core/Shaders/greasedLine.fragment.js
var name50 = "greasedLinePixelShader";
var shader50 = `precision highp float;uniform sampler2D grlColors;uniform float grlUseColors;uniform float grlUseDash;uniform float grlDashArray;uniform float grlDashOffset;uniform float grlDashRatio;uniform float grlVisibility;uniform float grlColorsWidth;uniform vec2 grl_colorModeAndColorDistributionType;uniform vec3 grlColor;varying float grlCounters;varying float grlColorPointer;void main() {float grlColorMode=grl_colorModeAndColorDistributionType.x;float grlColorDistributionType=grl_colorModeAndColorDistributionType.y;gl_FragColor=vec4(grlColor,1.);gl_FragColor.a=step(grlCounters,grlVisibility);if (gl_FragColor.a==0.) discard;if( grlUseDash==1. ){gl_FragColor.a=ceil(mod(grlCounters+grlDashOffset,grlDashArray)-(grlDashArray*grlDashRatio));if (gl_FragColor.a==0.) discard;}
if (grlUseColors==1.) {vec4 textureColor;if (grlColorDistributionType==COLOR_DISTRIBUTION_TYPE_LINE) { 
textureColor=texture2D(grlColors,vec2(grlCounters,0.),0.);} else {textureColor=texture2D(grlColors,vec2(grlColorPointer/grlColorsWidth,0.),0.);}
if (grlColorMode==COLOR_MODE_SET) {gl_FragColor=textureColor;} else if (grlColorMode==COLOR_MODE_ADD) {gl_FragColor+=textureColor;} else if (grlColorMode==COLOR_MODE_MULTIPLY) {gl_FragColor*=textureColor;}}}
`;
ShaderStore.ShadersStore[name50] = shader50;

// node_modules/@babylonjs/core/Shaders/greasedLine.vertex.js
var name51 = "greasedLineVertexShader";
var shader51 = `precision highp float;
#include<instancesDeclaration>
attribute float grl_widths;attribute vec3 grl_offsets;attribute float grl_colorPointers;attribute vec3 position;uniform mat4 viewProjection;uniform mat4 projection;varying float grlCounters;varying float grlColorPointer;
#ifdef GREASED_LINE_CAMERA_FACING
attribute vec4 grl_nextAndCounters;attribute vec4 grl_previousAndSide;uniform vec2 grlResolution;uniform float grlAspect;uniform float grlWidth;uniform float grlSizeAttenuation;vec2 grlFix( vec4 i,float aspect ) {vec2 res=i.xy/i.w;res.x*=aspect;return res;}
#else
attribute vec3 grl_slopes;attribute float grl_counters;
#endif
void main() {
#include<instancesVertex>
grlColorPointer=grl_colorPointers;
#ifdef GREASED_LINE_CAMERA_FACING
float grlBaseWidth=grlWidth;vec3 grlPrevious=grl_previousAndSide.xyz;float grlSide=grl_previousAndSide.w;vec3 grlNext=grl_nextAndCounters.xyz;grlCounters=grl_nextAndCounters.w;mat4 grlMatrix=viewProjection*finalWorld ;vec3 grlPositionOffset=grl_offsets;vec4 grlFinalPosition=grlMatrix*vec4( position+grlPositionOffset ,1.0 );vec4 grlPrevPos=grlMatrix*vec4( grlPrevious+grlPositionOffset,1.0 );vec4 grlNextPos=grlMatrix*vec4( grlNext+grlPositionOffset,1.0 );vec2 grlCurrentP=grlFix( grlFinalPosition,grlAspect );vec2 grlPrevP=grlFix( grlPrevPos,grlAspect );vec2 grlNextP=grlFix( grlNextPos,grlAspect );float grlWidth=grlBaseWidth*grl_widths;vec2 grlDir;if( grlNextP==grlCurrentP ) grlDir=normalize( grlCurrentP-grlPrevP );else if( grlPrevP==grlCurrentP ) grlDir=normalize( grlNextP-grlCurrentP );else {vec2 grlDir1=normalize( grlCurrentP-grlPrevP );vec2 grlDir2=normalize( grlNextP-grlCurrentP );grlDir=normalize( grlDir1+grlDir2 );}
vec4 grlNormal=vec4( -grlDir.y,grlDir.x,0.,1. );
#ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
grlNormal.xy*=-.5*grlWidth;
#else
grlNormal.xy*=.5*grlWidth;
#endif
grlNormal*=projection;if (grlSizeAttenuation==1.) {grlNormal.xy*=grlFinalPosition.w;grlNormal.xy/=( vec4( grlResolution,0.,1. )*projection ).xy;}
grlFinalPosition.xy+=grlNormal.xy*grlSide;gl_Position=grlFinalPosition;
#else
grlCounters=grl_counters;vec4 grlFinalPosition=worldViewProjection*vec4( (position+grl_offsets)+grl_slopes*grl_widths ,1.0 ) ;gl_Position=grlFinalPosition;
#endif
}
`;
ShaderStore.ShadersStore[name51] = shader51;

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineSimpleMaterial.js
var GreasedLineSimpleMaterial = class extends ShaderMaterial {
  /**
   * GreasedLineSimple material constructor
   * @param name material name
   * @param scene the scene
   * @param options material options
   */
  constructor(name52, scene, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const defines = [
      `COLOR_DISTRIBUTION_TYPE_LINE ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE}.`,
      `COLOR_DISTRIBUTION_TYPE_SEGMENT ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT}.`,
      `COLOR_MODE_SET ${GreasedLineMeshColorMode.COLOR_MODE_SET}.`,
      `COLOR_MODE_ADD ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.`,
      `COLOR_MODE_MULTIPLY ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.`
    ];
    const attributes = ["position", "grl_widths", "grl_offsets", "grl_colorPointers"];
    scene.useRightHandedSystem && defines.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");
    if (options.cameraFacing) {
      defines.push("GREASED_LINE_CAMERA_FACING");
      attributes.push("grl_previousAndSide", "grl_nextAndCounters");
    } else {
      attributes.push("grl_slopes");
      attributes.push("grl_counters");
    }
    super(name52, scene, {
      vertex: "greasedLine",
      fragment: "greasedLine"
    }, {
      attributes,
      uniforms: [
        "world",
        "viewProjection",
        "view",
        "projection",
        "grlColorsWidth",
        "grlUseColors",
        "grlWidth",
        "grlColor",
        "grl_colorModeAndColorDistributionType",
        "grlResolution",
        "grlAspect",
        "grlAizeAttenuation",
        "grlDashArray",
        "grlDashOffset",
        "grlDashRatio",
        "grlUseDash",
        "grlVisibility"
      ],
      samplers: ["grlColors"],
      defines
    });
    this._color = Color3.White();
    this._colorsDistributionType = GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;
    this._colorsTexture = null;
    options = options || {
      color: GreasedLineMaterialDefaults.DEFAULT_COLOR
    };
    const engine = scene.getEngine();
    this.visibility = (_a = options.visibility) !== null && _a !== void 0 ? _a : 1;
    this.useDash = (_b = options.useDash) !== null && _b !== void 0 ? _b : false;
    this.dashRatio = (_c = options.dashRatio) !== null && _c !== void 0 ? _c : 0.5;
    this.dashOffset = (_d = options.dashOffset) !== null && _d !== void 0 ? _d : 0;
    this.dashCount = (_e = options.dashCount) !== null && _e !== void 0 ? _e : 1;
    this.width = options.width ? options.width : options.sizeAttenuation && options.cameraFacing ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
    this.sizeAttenuation = (_f = options.sizeAttenuation) !== null && _f !== void 0 ? _f : false;
    this.color = (_g = options.color) !== null && _g !== void 0 ? _g : Color3.White();
    this.useColors = (_h = options.useColors) !== null && _h !== void 0 ? _h : false;
    this.colorsDistributionType = (_j = options.colorDistributionType) !== null && _j !== void 0 ? _j : GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;
    this.colorsSampling = (_k = options.colorsSampling) !== null && _k !== void 0 ? _k : RawTexture.NEAREST_NEAREST;
    this.colorMode = (_l = options.colorMode) !== null && _l !== void 0 ? _l : GreasedLineMeshColorMode.COLOR_MODE_SET;
    this._colors = (_m = options.colors) !== null && _m !== void 0 ? _m : null;
    this._cameraFacing = (_o = options.cameraFacing) !== null && _o !== void 0 ? _o : true;
    this.resolution = (_p = options.resolution) !== null && _p !== void 0 ? _p : new Vector2(engine.getRenderWidth(), engine.getRenderHeight());
    if (options.colorsTexture) {
      this.colorsTexture = options.colorsTexture;
    } else {
      this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
    }
    if (this._colors) {
      this.setColors(this._colors);
    }
    engine.onDisposeObservable.add(() => {
      GreasedLineTools.DisposeEmptyColorsTexture();
    });
  }
  /**
   * Disposes the plugin material.
   */
  dispose() {
    var _a;
    (_a = this._colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    super.dispose();
  }
  _setColorModeAndColorDistributionType() {
    this.setVector2("grl_colorModeAndColorDistributionType", new Vector2(this._colorMode, this._colorsDistributionType));
  }
  /**
   * Updates the material. Use when material created in lazy mode.
   */
  updateLazy() {
    if (this._colors) {
      this.setColors(this._colors, false, true);
    }
  }
  /**
   * Returns the colors used to colorize the line
   */
  get colors() {
    return this._colors;
  }
  /**
   * Sets the colors used to colorize the line
   */
  set colors(value) {
    this.setColors(value);
  }
  /**
   * Creates or updates the colors texture
   * @param colors color table RGBA
   * @param lazy if lazy, the colors are not updated
   * @param forceNewTexture force creation of a new texture
   * @returns
   */
  setColors(colors, lazy = false, forceNewTexture = false) {
    var _a, _b, _c, _d;
    const origColorsCount = (_b = (_a = this._colors) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    this._colors = colors;
    if (colors === null || colors.length === 0) {
      (_c = this._colorsTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      return;
    }
    if (lazy && !forceNewTexture) {
      return;
    }
    if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
      this._colorsTexture.update(colorArray);
    } else {
      (_d = this._colorsTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());
    }
  }
  /**
   * Gets the colors texture
   */
  get colorsTexture() {
    var _a;
    return (_a = this._colorsTexture) !== null && _a !== void 0 ? _a : null;
  }
  /**
   * Sets the colorsTexture
   */
  set colorsTexture(value) {
    this._colorsTexture = value;
    this.setFloat("grlColorsWidth", this._colorsTexture.getSize().width);
    this.setTexture("grlColors", this._colorsTexture);
  }
  /**
   * Line base width. At each point the line width is calculated by widths[pointIndex] * width
   */
  get width() {
    return this._width;
  }
  /**
   * Line base width. At each point the line width is calculated by widths[pointIndex] * width
   */
  set width(value) {
    this._width = value;
    this.setFloat("grlWidth", value);
  }
  /**
   * Whether to use the colors option to colorize the line
   */
  get useColors() {
    return this._useColors;
  }
  set useColors(value) {
    this._useColors = value;
    this.setFloat("grlUseColors", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * The type of sampling of the colors texture. The values are the same when using with textures.
   */
  get colorsSampling() {
    return this._colorsSampling;
  }
  /**
   * The type of sampling of the colors texture. The values are the same when using with textures.
   */
  set colorsSampling(value) {
    this._colorsSampling = value;
  }
  /**
   * Normalized value of how much of the line will be visible
   * 0 - 0% of the line will be visible
   * 1 - 100% of the line will be visible
   */
  get visibility() {
    return this._visibility;
  }
  set visibility(value) {
    this._visibility = value;
    this.setFloat("grlVisibility", value);
  }
  /**
   * Turns on/off dash mode
   */
  get useDash() {
    return this._useDash;
  }
  /**
   * Turns on/off dash mode
   */
  set useDash(value) {
    this._useDash = value;
    this.setFloat("grlUseDash", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * Gets the dash offset
   */
  get dashOffset() {
    return this._dashOffset;
  }
  /**
   * Sets the dash offset
   */
  set dashOffset(value) {
    this._dashOffset = value;
    this.setFloat("grlDashOffset", value);
  }
  /**
   * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
   */
  get dashRatio() {
    return this._dashRatio;
  }
  /**
   * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
   */
  set dashRatio(value) {
    this._dashRatio = value;
    this.setFloat("grlDashRatio", value);
  }
  /**
   * Gets the number of dashes in the line
   */
  get dashCount() {
    return this._dashCount;
  }
  /**
   * Sets the number of dashes in the line
   * @param value dash
   */
  set dashCount(value) {
    this._dashCount = value;
    this._dashArray = 1 / value;
    this.setFloat("grlDashArray", this._dashArray);
  }
  /**
   * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
   */
  get sizeAttenuation() {
    return this._sizeAttenuation;
  }
  /**
   * Turn on/off attenuation of the width option and widths array.
   * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
   */
  set sizeAttenuation(value) {
    this._sizeAttenuation = value;
    this.setFloat("grlSizeAttenuation", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * Gets the color of the line
   */
  get color() {
    return this.color;
  }
  /**
   * Sets the color of the line
   * @param value Color3
   */
  set color(value) {
    this.setColor(value);
  }
  /**
   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
   * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).
   * @param value color
   */
  setColor(value) {
    value = value !== null && value !== void 0 ? value : GreasedLineMaterialDefaults.DEFAULT_COLOR;
    this._color = value;
    this.setColor3("grlColor", value);
  }
  /**
   * Gets the color distributiopn type
   */
  get colorsDistributionType() {
    return this._colorsDistributionType;
  }
  /**
   * Sets the color distribution type
   * @see GreasedLineMeshColorDistributionType
   * @param value color distribution type
   */
  set colorsDistributionType(value) {
    this._colorsDistributionType = value;
    this._setColorModeAndColorDistributionType();
  }
  /**
   * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
   * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
   * @see GreasedLineMeshColorMode
   */
  get colorMode() {
    return this._colorMode;
  }
  /**
   * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
   * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
   * @see GreasedLineMeshColorMode
   */
  set colorMode(value) {
    this._colorMode = value;
    this._setColorModeAndColorDistributionType();
  }
  /**
   * Gets the resolution
   */
  get resolution() {
    return this._resolution;
  }
  /**
   * Sets the resolution
   * @param value resolution of the screen for GreasedLine
   */
  set resolution(value) {
    this._resolution = value;
    this.setVector2("grlResolution", value);
    this.setFloat("grlAspect", value.x / value.y);
  }
  /**
   * Serializes this plugin material
   * @returns serializationObjec
   */
  serialize() {
    const serializationObject = super.serialize();
    const greasedLineMaterialOptions = {
      colorDistributionType: this._colorsDistributionType,
      colorsSampling: this._colorsSampling,
      colorMode: this._colorMode,
      color: this._color,
      dashCount: this._dashCount,
      dashOffset: this._dashOffset,
      dashRatio: this._dashRatio,
      resolution: this._resolution,
      sizeAttenuation: this._sizeAttenuation,
      useColors: this._useColors,
      useDash: this._useDash,
      visibility: this._visibility,
      width: this._width,
      cameraFacing: this._cameraFacing
    };
    this._colors && (greasedLineMaterialOptions.colors = this._colors);
    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
    return serializationObject;
  }
  /**
   * Parses a serialized objects
   * @param source serialized object
   * @param scene scene
   * @param _rootUrl root url for textures
   */
  parse(source, scene, _rootUrl) {
    var _a, _b;
    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
    (_a = this._colorsTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    greasedLineMaterialOptions.color && (this.color = greasedLineMaterialOptions.color);
    greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);
    greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);
    greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);
    greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);
    greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);
    greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);
    greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);
    greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);
    greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);
    greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);
    greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);
    greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);
    if (greasedLineMaterialOptions.colors) {
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());
    } else {
      this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
    }
    this._cameraFacing = (_b = greasedLineMaterialOptions.cameraFacing) !== null && _b !== void 0 ? _b : true;
    this.setDefine("GREASED_LINE_CAMERA_FACING", this._cameraFacing);
  }
};

// node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js
var GreasedLineRibbonPointsMode;
(function(GreasedLineRibbonPointsMode2) {
  GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_POINTS"] = 0] = "POINTS_MODE_POINTS";
  GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_PATHS"] = 1] = "POINTS_MODE_PATHS";
})(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));
var GreasedLineRibbonFacesMode;
(function(GreasedLineRibbonFacesMode2) {
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED"] = 0] = "FACES_MODE_SINGLE_SIDED";
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING"] = 1] = "FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING";
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_DOUBLE_SIDED"] = 2] = "FACES_MODE_DOUBLE_SIDED";
})(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));
var GreasedLineRibbonAutoDirectionMode;
(function(GreasedLineRibbonAutoDirectionMode2) {
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_FIRST_SEGMENT"] = 0] = "AUTO_DIRECTIONS_FROM_FIRST_SEGMENT";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_ALL_SEGMENTS"] = 1] = "AUTO_DIRECTIONS_FROM_ALL_SEGMENTS";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_ENHANCED"] = 2] = "AUTO_DIRECTIONS_ENHANCED";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_NONE"] = 99] = "AUTO_DIRECTIONS_NONE";
})(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));
var GreasedLineBaseMesh = class extends Mesh {
  constructor(name52, scene, _options) {
    var _a, _b, _c, _d;
    super(name52, scene, null, null, false, false);
    this.name = name52;
    this._options = _options;
    this._lazy = false;
    this._updatable = false;
    this._engine = scene.getEngine();
    this._lazy = (_a = _options.lazy) !== null && _a !== void 0 ? _a : false;
    this._updatable = (_b = _options.updatable) !== null && _b !== void 0 ? _b : false;
    this._vertexPositions = [];
    this._indices = [];
    this._uvs = [];
    this._points = [];
    this._colorPointers = (_c = _options.colorPointers) !== null && _c !== void 0 ? _c : [];
    this._widths = (_d = _options.widths) !== null && _d !== void 0 ? _d : new Array(_options.points.length).fill(1);
  }
  /**
   * "GreasedLineMesh"
   * @returns "GreasedLineMesh"
   */
  getClassName() {
    return "GreasedLineMesh";
  }
  _updateWidthsWithValue(defaulValue) {
    let pointCount = 0;
    for (const points of this._points) {
      pointCount += points.length;
    }
    const countDiff = pointCount / 3 * 2 - this._widths.length;
    for (let i = 0; i < countDiff; i++) {
      this._widths.push(defaulValue);
    }
  }
  /**
   * Updated a lazy line. Rerenders the line and updates boundinfo as well.
   */
  updateLazy() {
    var _a, _b;
    this._setPoints(this._points);
    if (!this._options.colorPointers) {
      this._updateColorPointers();
    }
    this._createVertexBuffers((_a = this._options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.smoothShading);
    this.refreshBoundingInfo();
    (_b = this.greasedLineMaterial) === null || _b === void 0 ? void 0 : _b.updateLazy();
  }
  /**
   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
   * @param points points table
   */
  addPoints(points, options) {
    for (const p of points) {
      this._points.push(p);
    }
    if (!this._lazy) {
      this.setPoints(this._points, options);
    }
  }
  /**
   * Dispose the line and it's resources
   */
  dispose() {
    super.dispose();
  }
  /**
   *
   * @returns true if the mesh was created in lazy mode
   */
  isLazy() {
    return this._lazy;
  }
  /**
   * Return the points offsets
   */
  get offsets() {
    return this._offsets;
  }
  /**
   * Sets point offests
   * @param offsets offset table [x,y,z, x,y,z, ....]
   */
  set offsets(offsets) {
    this._offsets = offsets;
    if (!this._offsetsBuffer) {
      this._createOffsetsBuffer(offsets);
    } else {
      this._offsetsBuffer.update(offsets);
    }
  }
  /**
   * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]
   */
  get widths() {
    return this._widths;
  }
  /**
   * Sets widths at each line point
   * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]
   */
  set widths(widths) {
    this._widths = widths;
    if (!this._lazy) {
      this._widthsBuffer && this._widthsBuffer.update(widths);
    }
  }
  /**
   * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors
   */
  get colorPointers() {
    return this._colorPointers;
  }
  /**
   * Sets the color pointer
   * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.
   */
  set colorPointers(colorPointers) {
    this._colorPointers = colorPointers;
    if (!this._lazy) {
      this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);
    }
  }
  /**
   * Gets the pluginMaterial associated with line
   */
  get greasedLineMaterial() {
    var _a, _b;
    if (this.material && this.material instanceof GreasedLineSimpleMaterial) {
      return this.material;
    }
    const materialPlugin = (_b = (_a = this.material) === null || _a === void 0 ? void 0 : _a.pluginManager) === null || _b === void 0 ? void 0 : _b.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);
    if (materialPlugin) {
      return materialPlugin;
    }
    return;
  }
  /**
   * Return copy the points.
   */
  get points() {
    const pointsCopy = [];
    DeepCopier.DeepCopy(this._points, pointsCopy);
    return pointsCopy;
  }
  /**
   * Sets line points and rerenders the line.
   * @param points points table
   */
  setPoints(points, options) {
    this._points = points;
    this._updateWidths();
    if (!(options === null || options === void 0 ? void 0 : options.colorPointers)) {
      this._updateColorPointers();
    }
    this._setPoints(points, options);
  }
  _initGreasedLine() {
    this._vertexPositions = [];
    this._indices = [];
    this._uvs = [];
  }
  _createLineOptions() {
    const lineOptions = {
      points: this._points,
      colorPointers: this._colorPointers,
      lazy: this._lazy,
      updatable: this._updatable,
      uvs: this._uvs,
      widths: this._widths,
      ribbonOptions: this._options.ribbonOptions
    };
    return lineOptions;
  }
  /**
   * Serializes this GreasedLineMesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.lineOptions = this._createLineOptions();
  }
  _createVertexBuffers(computeNormals = false) {
    const vertexData = new VertexData();
    vertexData.positions = this._vertexPositions;
    vertexData.indices = this._indices;
    vertexData.uvs = this._uvs;
    if (computeNormals) {
      vertexData.normals = [];
      VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);
    }
    vertexData.applyToMesh(this, this._options.updatable);
    return vertexData;
  }
  _createOffsetsBuffer(offsets) {
    const engine = this._scene.getEngine();
    const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);
    this.setVerticesBuffer(offsetBuffer.createVertexBuffer("grl_offsets", 0, 3));
    this._offsetsBuffer = offsetBuffer;
  }
};

// node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineMesh.js
Mesh._GreasedLineMeshParser = (parsedMesh, scene) => {
  return GreasedLineMesh.Parse(parsedMesh, scene);
};
var GreasedLineMesh = class _GreasedLineMesh extends GreasedLineBaseMesh {
  /**
   * GreasedLineMesh
   * @param name name of the mesh
   * @param scene the scene
   * @param _options mesh options
   */
  constructor(name52, scene, _options) {
    super(name52, scene, _options);
    this.name = name52;
    this.intersectionThreshold = 0.1;
    this._previousAndSide = [];
    this._nextAndCounters = [];
    if (_options.points) {
      this.addPoints(GreasedLineTools.ConvertPoints(_options.points));
    }
  }
  /**
   * "GreasedLineMesh"
   * @returns "GreasedLineMesh"
   */
  getClassName() {
    return "GreasedLineMesh";
  }
  _updateColorPointers() {
    if (this._options.colorPointers) {
      return;
    }
    let colorPointer = 0;
    this._colorPointers = [];
    this._points.forEach((p) => {
      for (let jj = 0; jj < p.length; jj += 3) {
        this._colorPointers.push(colorPointer);
        this._colorPointers.push(colorPointer++);
      }
    });
  }
  _updateWidths() {
    super._updateWidthsWithValue(0);
  }
  _setPoints(points) {
    this._points = points;
    this._options.points = points;
    this._initGreasedLine();
    let indiceOffset = 0;
    points.forEach((p) => {
      var _a;
      const counters = [];
      const positions = [];
      const indices = [];
      const totalLength = GreasedLineTools.GetLineLength(p);
      for (let j = 0, jj = 0; jj < p.length; j++, jj += 3) {
        const partialLine = p.slice(0, jj + 3);
        const partialLineLength = GreasedLineTools.GetLineLength(partialLine);
        const c = partialLineLength / totalLength;
        positions.push(p[jj], p[jj + 1], p[jj + 2]);
        positions.push(p[jj], p[jj + 1], p[jj + 2]);
        counters.push(c);
        counters.push(c);
        if (jj < p.length - 3) {
          const n = j * 2 + indiceOffset;
          indices.push(n, n + 1, n + 2);
          indices.push(n + 2, n + 1, n + 3);
        }
      }
      indiceOffset += p.length / 3 * 2;
      const previous = [];
      const next = [];
      const side = [];
      let uvs = [];
      this._preprocess(positions, previous, next, side, uvs);
      for (const vp of positions) {
        this._vertexPositions.push(vp);
      }
      for (const i of indices) {
        this._indices.push(i);
      }
      for (let i = 0; i < side.length; i++) {
        this._previousAndSide.push(previous[i * 3], previous[i * 3 + 1], previous[i * 3 + 2], side[i]);
        this._nextAndCounters.push(next[i * 3], next[i * 3 + 1], next[i * 3 + 2], counters[i]);
      }
      uvs = (_a = this._options.uvs) !== null && _a !== void 0 ? _a : uvs;
      for (const uv of uvs) {
        this._uvs.push(uv);
      }
    });
    if (!this._lazy) {
      if (!this._options.colorPointers) {
        this._updateColorPointers();
      }
      this._createVertexBuffers();
      this.refreshBoundingInfo();
    }
  }
  /**
   * Clones the GreasedLineMesh.
   * @param name new line name
   * @param newParent new parent node
   * @returns cloned line
   */
  clone(name52 = `${this.name}-cloned`, newParent) {
    const lineOptions = this._createLineOptions();
    const deepCopiedLineOptions = {};
    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, ["instance"], void 0, true);
    const cloned = new _GreasedLineMesh(name52, this._scene, deepCopiedLineOptions);
    if (newParent) {
      cloned.parent = newParent;
    }
    cloned.material = this.material;
    return cloned;
  }
  /**
   * Serializes this GreasedLineMesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.lineOptions = this._createLineOptions();
  }
  /**
   * Parses a serialized GreasedLineMesh
   * @param parsedMesh the serialized GreasedLineMesh
   * @param scene the scene to create the GreasedLineMesh in
   * @returns the created GreasedLineMesh
   */
  static Parse(parsedMesh, scene) {
    const lineOptions = parsedMesh.lineOptions;
    const name52 = parsedMesh.name;
    const result = new _GreasedLineMesh(name52, scene, lineOptions);
    return result;
  }
  _initGreasedLine() {
    super._initGreasedLine();
    this._previousAndSide = [];
    this._nextAndCounters = [];
  }
  /**
   * Checks whether a ray is intersecting this GreasedLineMesh
   * @param ray ray to check the intersection of this mesh with
   * @param fastCheck not supported
   * @param trianglePredicate not supported
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse not supported
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns the picking info
   */
  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const pickingInfo = new PickingInfo();
    const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);
    if ((intersections === null || intersections === void 0 ? void 0 : intersections.length) === 1) {
      const intersection = intersections[0];
      pickingInfo.hit = true;
      pickingInfo.distance = intersection.distance;
      pickingInfo.ray = ray;
      pickingInfo.pickedMesh = this;
      pickingInfo.pickedPoint = intersection.point;
    }
    return pickingInfo;
  }
  /**
   * Gets all intersections of a ray and the line
   * @param ray Ray to check the intersection of this mesh with
   * @param _fastCheck not supported
   * @param _trianglePredicate not supported
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param _worldToUse not supported
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @param firstOnly If true, the first and only intersection is immediatelly returned if found
   * @returns intersection(s)
   */
  findAllIntersections(ray, _fastCheck, _trianglePredicate, onlyBoundingInfo = false, _worldToUse, skipBoundingInfo = false, firstOnly = false) {
    var _a, _b;
    if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {
      return;
    }
    const indices = this.getIndices();
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const widths = this._widths;
    const lineWidth = (_b = (_a = this.greasedLineMaterial) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 1;
    const intersects = [];
    if (indices && positions && widths) {
      let i = 0, l = 0;
      for (i = 0, l = indices.length - 1; i < l; i += 3) {
        const a = indices[i];
        const b = indices[i + 1];
        _GreasedLineMesh._V_START.fromArray(positions, a * 3);
        _GreasedLineMesh._V_END.fromArray(positions, b * 3);
        if (this._offsets) {
          _GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);
          _GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);
          _GreasedLineMesh._V_START.addInPlace(_GreasedLineMesh._V_OFFSET_START);
          _GreasedLineMesh._V_END.addInPlace(_GreasedLineMesh._V_OFFSET_END);
        }
        const iFloored = Math.floor(i / 3);
        const width = widths[iFloored] !== void 0 ? widths[iFloored] : 1;
        const precision = this.intersectionThreshold * (lineWidth * width) / 2;
        const distance = ray.intersectionSegment(_GreasedLineMesh._V_START, _GreasedLineMesh._V_END, precision);
        if (distance !== -1) {
          intersects.push({
            distance,
            point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin)
          });
          if (firstOnly) {
            return intersects;
          }
        }
      }
      i = l;
    }
    return intersects;
  }
  get _boundingSphere() {
    return this.getBoundingInfo().boundingSphere;
  }
  static _CompareV3(positionIdx1, positionIdx2, positions) {
    const arrayIdx1 = positionIdx1 * 6;
    const arrayIdx2 = positionIdx2 * 6;
    return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];
  }
  static _CopyV3(positionIdx, positions) {
    const arrayIdx = positionIdx * 6;
    return [positions[arrayIdx], positions[arrayIdx + 1], positions[arrayIdx + 2]];
  }
  _preprocess(positions, previous, next, side, uvs) {
    const l = positions.length / 6;
    let v = [];
    if (_GreasedLineMesh._CompareV3(0, l - 1, positions)) {
      v = _GreasedLineMesh._CopyV3(l - 2, positions);
    } else {
      v = _GreasedLineMesh._CopyV3(0, positions);
    }
    previous.push(v[0], v[1], v[2]);
    previous.push(v[0], v[1], v[2]);
    for (let j = 0; j < l; j++) {
      side.push(1);
      side.push(-1);
      if (!this._options.uvs) {
        uvs.push(j / (l - 1), 0);
        uvs.push(j / (l - 1), 1);
      }
      if (j < l - 1) {
        v = _GreasedLineMesh._CopyV3(j, positions);
        previous.push(v[0], v[1], v[2]);
        previous.push(v[0], v[1], v[2]);
      }
      if (j > 0) {
        v = _GreasedLineMesh._CopyV3(j, positions);
        next.push(v[0], v[1], v[2]);
        next.push(v[0], v[1], v[2]);
      }
    }
    if (_GreasedLineMesh._CompareV3(l - 1, 0, positions)) {
      v = _GreasedLineMesh._CopyV3(1, positions);
    } else {
      v = _GreasedLineMesh._CopyV3(l - 1, positions);
    }
    next.push(v[0], v[1], v[2]);
    next.push(v[0], v[1], v[2]);
    return {
      previous,
      next,
      uvs,
      side
    };
  }
  _createVertexBuffers() {
    const vertexData = super._createVertexBuffers();
    const engine = this._scene.getEngine();
    const previousAndSideBuffer = new Buffer(engine, this._previousAndSide, false, 4);
    this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer("grl_previousAndSide", 0, 4));
    const nextAndCountersBuffer = new Buffer(engine, this._nextAndCounters, false, 4);
    this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer("grl_nextAndCounters", 0, 4));
    const widthBuffer = new Buffer(engine, this._widths, this._updatable, 1);
    this.setVerticesBuffer(widthBuffer.createVertexBuffer("grl_widths", 0, 1));
    this._widthsBuffer = widthBuffer;
    const colorPointersBuffer = new Buffer(engine, this._colorPointers, this._updatable, 1);
    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer("grl_colorPointers", 0, 1));
    this._colorPointersBuffer = colorPointersBuffer;
    return vertexData;
  }
};
GreasedLineMesh._V_START = new Vector3();
GreasedLineMesh._V_END = new Vector3();
GreasedLineMesh._V_OFFSET_START = new Vector3();
GreasedLineMesh._V_OFFSET_END = new Vector3();

// node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineRibbonMesh.js
Mesh._GreasedLineRibbonMeshParser = (parsedMesh, scene) => {
  return GreasedLineRibbonMesh.Parse(parsedMesh, scene);
};
var GreasedLineRibbonMesh = class _GreasedLineRibbonMesh extends GreasedLineBaseMesh {
  /**
   * GreasedLineRibbonMesh
   * @param name name of the mesh
   * @param scene the scene
   * @param _options mesh options
   * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh
   */
  constructor(name52, scene, _options, _pathOptions) {
    var _a;
    super(name52, scene, _options);
    this.name = name52;
    if (!_options.ribbonOptions) {
      throw "'GreasedLineMeshOptions.ribbonOptions' is not set.";
    }
    this._paths = [];
    this._counters = [];
    this._slopes = [];
    this._widths = (_a = _options.widths) !== null && _a !== void 0 ? _a : [];
    this._ribbonWidths = [];
    this._pathsOptions = _pathOptions !== null && _pathOptions !== void 0 ? _pathOptions : [];
    if (_options.points) {
      this.addPoints(GreasedLineTools.ConvertPoints(_options.points), _options, !!_pathOptions);
    }
  }
  /**
   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
   * @param points points table
   */
  addPoints(points, options, hasPathOptions = false) {
    if (!options.ribbonOptions) {
      throw "addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.";
    }
    if (!hasPathOptions) {
      this._pathsOptions.push({ options, pathCount: points.length });
    }
    super.addPoints(points, options);
  }
  /**
   * "GreasedLineRibbonMesh"
   * @returns "GreasedLineRibbonMesh"
   */
  getClassName() {
    return "GreasedLineRibbonMesh";
  }
  /**
   * Return true if the line was created from two edge paths or one points path.
   * In this case the line is always flat.
   */
  get isFlatLine() {
    return this._paths.length < 3;
  }
  /**
   * Returns the slopes of the line at each point relative to the center of the line
   */
  get slopes() {
    return this._slopes;
  }
  /**
   * Set the slopes of the line at each point relative to the center of the line
   */
  set slopes(slopes) {
    this._slopes = slopes;
  }
  _updateColorPointers() {
    if (this._options.colorPointers) {
      return;
    }
    let colorPointer = 0;
    this._colorPointers = [];
    for (let i = 0; i < this._pathsOptions.length; i++) {
      const { options: pathOptions, pathCount } = this._pathsOptions[i];
      const points = this._points[i];
      if (pathOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {
        for (let k = 0; k < pathCount; k++) {
          for (let j = 0; j < points.length; j += 3) {
            this._colorPointers.push(colorPointer);
            this._colorPointers.push(colorPointer++);
          }
        }
      } else {
        for (let j = 0; j < points.length; j += 3) {
          for (let k = 0; k < pathCount; k++) {
            this._colorPointers.push(colorPointer);
          }
          colorPointer++;
        }
      }
    }
  }
  _updateWidths() {
    super._updateWidthsWithValue(1);
  }
  _setPoints(points, _options) {
    var _a, _b;
    if (!this._options.ribbonOptions) {
      throw "No 'GreasedLineMeshOptions.ribbonOptions' provided.";
    }
    this._points = points;
    this._options.points = points;
    this._initGreasedLine();
    let indiceOffset = 0;
    let directionPlanes;
    for (let i = 0, c = 0; i < this._pathsOptions.length; i++) {
      const { options: pathOptions, pathCount } = this._pathsOptions[i];
      const subPoints = points.slice(c, c + pathCount);
      c += pathCount;
      if (((_a = pathOptions.ribbonOptions) === null || _a === void 0 ? void 0 : _a.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS) {
        indiceOffset = this._preprocess(GreasedLineTools.ToVector3Array(subPoints), indiceOffset, pathOptions);
      } else {
        if (((_b = pathOptions.ribbonOptions) === null || _b === void 0 ? void 0 : _b.directionsAutoMode) === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE) {
          if (!pathOptions.ribbonOptions.directions) {
            throw "In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.";
          }
          directionPlanes = _GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions.directions);
        }
        subPoints.forEach((p, idx) => {
          const pathArray = _GreasedLineRibbonMesh._ConvertToRibbonPath(p, pathOptions.ribbonOptions, this._scene.useRightHandedSystem, directionPlanes ? directionPlanes[idx] : directionPlanes);
          indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);
        });
      }
    }
    if (!this._lazy) {
      this._createVertexBuffers();
      this.refreshBoundingInfo();
    }
  }
  static _GetDirectionPlanesFromDirectionsOption(count, directions) {
    if (Array.isArray(directions)) {
      return directions;
    }
    return new Array(count).fill(directions);
  }
  static _CreateRibbonVertexData(pathArray, options) {
    var _a, _b, _c;
    const numOfPaths = pathArray.length;
    if (numOfPaths < 2) {
      throw "Minimum of two paths are required to create a GreasedLineRibbonMesh.";
    }
    const positions = [];
    const indices = [];
    const path = pathArray[0];
    for (let i = 0; i < path.length; i++) {
      for (let pi = 0; pi < pathArray.length; pi++) {
        const v2 = pathArray[pi][i];
        positions.push(v2.x, v2.y, v2.z);
      }
    }
    const v = [1, 0, numOfPaths];
    const doubleSided = (_b = ((_a = options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.facesMode) === GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED) !== null && _b !== void 0 ? _b : false;
    const closePath = ((_c = options.ribbonOptions) === null || _c === void 0 ? void 0 : _c.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath;
    if (numOfPaths > 2) {
      for (let i = 0; i < path.length - 1; i++) {
        v[0] = 1 + numOfPaths * i;
        v[1] = numOfPaths * i;
        v[2] = (i + 1) * numOfPaths;
        for (let pi = 0; pi < (numOfPaths - 1) * 2; pi++) {
          if (pi % 2 !== 0) {
            v[2] += 1;
          }
          if (pi % 2 === 0 && pi > 0) {
            v[0] += 1;
            v[1] += 1;
          }
          indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);
          if (doubleSided) {
            indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);
          }
        }
      }
    } else {
      for (let i = 0; i < positions.length / 3 - 3; i += 2) {
        indices.push(i, i + 1, i + 2);
        indices.push(i + 2, i + 1, i + 3);
        if (doubleSided) {
          indices.push(i + 1, i, i + 2);
          indices.push(i + 1, i + 2, i + 3);
        }
      }
    }
    if (closePath) {
      let lastIndice = numOfPaths * (path.length - 1);
      for (let pi = 0; pi < numOfPaths - 1; pi++) {
        indices.push(lastIndice, pi + 1, pi);
        indices.push(lastIndice + 1, pi + 1, lastIndice);
        if (doubleSided) {
          indices.push(pi, pi + 1, lastIndice);
          indices.push(lastIndice, pi + 1, lastIndice + 1);
        }
        lastIndice++;
      }
    }
    return {
      positions,
      indices
    };
  }
  _preprocess(pathArray, indiceOffset, options) {
    var _a, _b, _c, _d;
    this._paths = pathArray;
    const ribbonVertexData = _GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);
    const positions = ribbonVertexData.positions;
    if (!this._options.widths) {
      throw "No 'GreasedLineMeshOptions.widths' table is specified.";
    }
    for (const p of positions) {
      this._vertexPositions.push(p);
    }
    let pathArrayCopy = pathArray;
    if (((_a = options.ribbonOptions) === null || _a === void 0 ? void 0 : _a.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath) {
      pathArrayCopy = [];
      for (let i = 0; i < pathArray.length; i++) {
        const pathCopy = pathArray[i].slice();
        pathCopy.push(pathArray[i][0].clone());
        pathArrayCopy.push(pathCopy);
      }
    }
    this._calculateSegmentLengths(pathArrayCopy);
    const pathArrayLength = pathArrayCopy.length;
    const previousCounters = new Array(pathArrayLength).fill(0);
    for (let i = 0; i < pathArrayCopy[0].length; i++) {
      let v = 0;
      for (let pi = 0; pi < pathArrayLength; pi++) {
        const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];
        this._counters.push(counter);
        this._uvs.push(counter, v);
        previousCounters[pi] = counter;
        v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];
      }
    }
    for (let i = 0, c = 0; i < pathArrayCopy[0].length; i++) {
      const widthLower = this._uSegmentLengths[i][0] / 2;
      const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;
      this._ribbonWidths.push((((_b = this._widths[c++]) !== null && _b !== void 0 ? _b : 1) - 1) * widthLower);
      for (let pi = 0; pi < pathArrayLength - 2; pi++) {
        this._ribbonWidths.push(0);
      }
      this._ribbonWidths.push((((_c = this._widths[c++]) !== null && _c !== void 0 ? _c : 1) - 1) * widthUpper);
    }
    const slopes = ((_d = options.ribbonOptions) === null || _d === void 0 ? void 0 : _d.pointsMode) === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0) : _GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);
    for (const s of slopes) {
      this._slopes.push(s);
    }
    if (ribbonVertexData.indices) {
      for (let i = 0; i < ribbonVertexData.indices.length; i++) {
        this._indices.push(ribbonVertexData.indices[i] + indiceOffset);
      }
    }
    indiceOffset += positions.length / 3;
    return indiceOffset;
  }
  static _ConvertToRibbonPath(points, ribbonInfo, rightHandedSystem, directionPlane) {
    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS && !ribbonInfo.width) {
      throw "'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.";
    }
    const path1 = [];
    const path2 = [];
    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {
      const width = ribbonInfo.width / 2;
      const pointVectors = GreasedLineTools.ToVector3Array(points);
      let direction = null;
      let fatDirection = null;
      if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT) {
        directionPlane = _GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);
      }
      for (let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++) {
        const p1 = pointVectors[i];
        const p2 = pointVectors[i + 1];
        if (directionPlane) {
          direction = directionPlane;
        } else if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS) {
          direction = _GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);
        } else {
          const directionTemp = p2.subtract(p1);
          directionTemp.applyRotationQuaternionInPlace(directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z ? rightHandedSystem ? _GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion : _GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion : _GreasedLineRibbonMesh._LeftReadOnlyQuaternion);
          direction = directionTemp.normalize();
        }
        fatDirection = direction.multiplyByFloats(width, width, width);
        path1.push(p1.add(fatDirection));
        path2.push(p1.subtract(fatDirection));
      }
      if (!directionPlane) {
        path1.push(pointVectors[pointVectors.length - 1].add(fatDirection));
        path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection));
      }
    }
    return [path1, path2];
  }
  static _GetDirectionFromPoints(p1, p2, previousDirection) {
    if (p1.x === p2.x && (!previousDirection || (previousDirection === null || previousDirection === void 0 ? void 0 : previousDirection.x) === 1)) {
      return _GreasedLineRibbonMesh.DIRECTION_YZ;
    }
    if (p1.y === p2.y) {
      return _GreasedLineRibbonMesh.DIRECTION_XZ;
    }
    if (p1.z === p2.z) {
      return _GreasedLineRibbonMesh.DIRECTION_XY;
    }
    return _GreasedLineRibbonMesh.DIRECTION_XZ;
  }
  /**
   * Clones the GreasedLineRibbonMesh.
   * @param name new line name
   * @param newParent new parent node
   * @returns cloned line
   */
  clone(name52 = `${this.name}-cloned`, newParent) {
    const lineOptions = this._createLineOptions();
    const deepCopiedLineOptions = {};
    const pathOptionsCloned = [];
    DeepCopier.DeepCopy(this._pathsOptions, pathOptionsCloned, void 0, void 0, true);
    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, ["instance"], void 0, true);
    const cloned = new _GreasedLineRibbonMesh(name52, this._scene, deepCopiedLineOptions, pathOptionsCloned);
    if (newParent) {
      cloned.parent = newParent;
    }
    cloned.material = this.material;
    return cloned;
  }
  /**
   * Serializes this GreasedLineRibbonMesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.lineOptions = this._createLineOptions();
    serializationObject.pathsOptions = this._pathsOptions;
  }
  /**
   * Parses a serialized GreasedLineRibbonMesh
   * @param parsedMesh the serialized GreasedLineRibbonMesh
   * @param scene the scene to create the GreasedLineRibbonMesh in
   * @returns the created GreasedLineRibbonMesh
   */
  static Parse(parsedMesh, scene) {
    const lineOptions = parsedMesh.lineOptions;
    const name52 = parsedMesh.name;
    const pathOptions = parsedMesh.pathOptions;
    const result = new _GreasedLineRibbonMesh(name52, scene, lineOptions, pathOptions);
    return result;
  }
  _initGreasedLine() {
    super._initGreasedLine();
    this._paths = [];
    this._counters = [];
    this._slopes = [];
    this._ribbonWidths = [];
  }
  _calculateSegmentLengths(pathArray) {
    const pathArrayLength = pathArray.length;
    this._vSegmentLengths = new Array(pathArrayLength);
    this._vTotalLengths = new Array(pathArrayLength);
    let length = 0;
    for (let pi = 0; pi < pathArrayLength; pi++) {
      const points = pathArray[pi];
      this._vSegmentLengths[pi] = [0];
      length = 0;
      for (let i = 0; i < points.length - 1; i++) {
        const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared());
        length += l;
        this._vSegmentLengths[pi].push(l);
      }
      this._vTotalLengths[pi] = length;
    }
    const positionsLength = pathArray[0].length;
    this._uSegmentLengths = new Array(positionsLength).fill([]);
    this._uTotalLengths = new Array(positionsLength).fill([]);
    const uLength = new Vector3();
    for (let i = 0; i < positionsLength; i++) {
      length = 0;
      for (let pi = 1; pi < pathArrayLength; pi++) {
        pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);
        const l = uLength.length();
        length += l;
        this._uSegmentLengths[i].push(l);
      }
      this._uTotalLengths[i] = length;
    }
  }
  static _CalculateSlopes(paths) {
    const points1 = paths[0];
    const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];
    const slopes = [];
    const slope = new Vector3();
    for (let i = 0; i < points1.length; i++) {
      for (let pi = 0; pi < paths.length; pi++) {
        if (pi === 0 || pi === paths.length - 1) {
          points1[i].subtract(points2[i]).normalizeToRef(slope);
          slopes.push(slope.x, slope.y, slope.z);
          slopes.push(-slope.x, -slope.y, -slope.z);
        } else {
          slopes.push(0, 0, 0, 0, 0, 0);
        }
      }
    }
    return slopes;
  }
  _createVertexBuffers() {
    var _a, _b;
    this._uvs = (_a = this._options.uvs) !== null && _a !== void 0 ? _a : this._uvs;
    const vertexData = super._createVertexBuffers((_b = this._options.ribbonOptions) === null || _b === void 0 ? void 0 : _b.smoothShading);
    const countersBuffer = new Buffer(this._engine, this._counters, this._updatable, 1);
    this.setVerticesBuffer(countersBuffer.createVertexBuffer("grl_counters", 0, 1));
    const colorPointersBuffer = new Buffer(this._engine, this._colorPointers, this._updatable, 1);
    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer("grl_colorPointers", 0, 1));
    const slopesBuffer = new Buffer(this._engine, this._slopes, this._updatable, 3);
    this.setVerticesBuffer(slopesBuffer.createVertexBuffer("grl_slopes", 0, 3));
    const widthsBuffer = new Buffer(this._engine, this._ribbonWidths, this._updatable, 1);
    this.setVerticesBuffer(widthsBuffer.createVertexBuffer("grl_widths", 0, 1));
    this._widthsBuffer = widthsBuffer;
    return vertexData;
  }
};
GreasedLineRibbonMesh.DEFAULT_WIDTH = 0.1;
GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.RightHandedForwardReadOnly, Math.PI / 2);
GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftHandedForwardReadOnly, Math.PI / 2);
GreasedLineRibbonMesh._LeftReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftReadOnly, Math.PI / 2);
GreasedLineRibbonMesh.DIRECTION_XY = Vector3.LeftHandedForwardReadOnly;
GreasedLineRibbonMesh.DIRECTION_XZ = Vector3.UpReadOnly;
GreasedLineRibbonMesh.DIRECTION_YZ = Vector3.LeftReadOnly;

// node_modules/@babylonjs/core/Meshes/Builders/greasedLineBuilder.js
var GreasedLineMeshColorDistribution;
(function(GreasedLineMeshColorDistribution2) {
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_NONE"] = 0] = "COLOR_DISTRIBUTION_NONE";
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_REPEAT"] = 1] = "COLOR_DISTRIBUTION_REPEAT";
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_EVEN"] = 2] = "COLOR_DISTRIBUTION_EVEN";
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_START"] = 3] = "COLOR_DISTRIBUTION_START";
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_END"] = 4] = "COLOR_DISTRIBUTION_END";
  GreasedLineMeshColorDistribution2[GreasedLineMeshColorDistribution2["COLOR_DISTRIBUTION_START_END"] = 5] = "COLOR_DISTRIBUTION_START_END";
})(GreasedLineMeshColorDistribution || (GreasedLineMeshColorDistribution = {}));
var GreasedLineMeshWidthDistribution;
(function(GreasedLineMeshWidthDistribution2) {
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_NONE"] = 0] = "WIDTH_DISTRIBUTION_NONE";
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_REPEAT"] = 1] = "WIDTH_DISTRIBUTION_REPEAT";
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_EVEN"] = 2] = "WIDTH_DISTRIBUTION_EVEN";
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_START"] = 3] = "WIDTH_DISTRIBUTION_START";
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_END"] = 4] = "WIDTH_DISTRIBUTION_END";
  GreasedLineMeshWidthDistribution2[GreasedLineMeshWidthDistribution2["WIDTH_DISTRIBUTION_START_END"] = 5] = "WIDTH_DISTRIBUTION_START_END";
})(GreasedLineMeshWidthDistribution || (GreasedLineMeshWidthDistribution = {}));
function CreateGreasedLineMaterial(name52, options, scene) {
  scene = scene !== null && scene !== void 0 ? scene : EngineStore.LastCreatedScene;
  let material;
  switch (options.materialType) {
    case GreasedLineMeshMaterialType.MATERIAL_TYPE_PBR:
      material = new PBRMaterial(name52, scene);
      new GreasedLinePluginMaterial(material, scene, options);
      break;
    case GreasedLineMeshMaterialType.MATERIAL_TYPE_SIMPLE:
      material = new GreasedLineSimpleMaterial(name52, scene, options);
      break;
    default:
      material = new StandardMaterial(name52, scene);
      new GreasedLinePluginMaterial(material, scene, options);
      break;
  }
  return material;
}
function CreateGreasedLine(name52, options, materialOptions, scene) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  scene = scene !== null && scene !== void 0 ? scene : EngineStore.LastCreatedScene;
  let instance;
  const allPoints = GreasedLineTools.ConvertPoints(options.points);
  options.widthDistribution = (_a = options.widthDistribution) !== null && _a !== void 0 ? _a : GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START;
  if (options.ribbonOptions) {
    options.ribbonOptions.facesMode = (_b = options.ribbonOptions.facesMode) !== null && _b !== void 0 ? _b : GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING;
    options.ribbonOptions.pointsMode = (_c = options.ribbonOptions.pointsMode) !== null && _c !== void 0 ? _c : GreasedLineRibbonPointsMode.POINTS_MODE_POINTS;
    options.ribbonOptions.directionsAutoMode = (_d = options.ribbonOptions.directionsAutoMode) !== null && _d !== void 0 ? _d : options.ribbonOptions.directions ? GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE : GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT;
  }
  materialOptions = materialOptions !== null && materialOptions !== void 0 ? materialOptions : {
    color: GreasedLineMaterialDefaults.DEFAULT_COLOR
  };
  materialOptions.createAndAssignMaterial = (_e = materialOptions.createAndAssignMaterial) !== null && _e !== void 0 ? _e : true;
  materialOptions.colorDistribution = (_f = materialOptions === null || materialOptions === void 0 ? void 0 : materialOptions.colorDistribution) !== null && _f !== void 0 ? _f : GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START;
  materialOptions.materialType = (_g = materialOptions.materialType) !== null && _g !== void 0 ? _g : GreasedLineMeshMaterialType.MATERIAL_TYPE_STANDARD;
  let length = 0;
  if (Array.isArray(allPoints[0])) {
    allPoints.forEach((points) => {
      length += points.length / 3;
    });
  }
  const widths = CompleteGreasedLineWidthTable(length, (_h = options.widths) !== null && _h !== void 0 ? _h : [], options.widthDistribution);
  const colors = (materialOptions === null || materialOptions === void 0 ? void 0 : materialOptions.colors) ? CompleteGreasedLineColorTable(length, materialOptions.colors, materialOptions.colorDistribution, (_j = materialOptions.color) !== null && _j !== void 0 ? _j : GreasedLineMaterialDefaults.DEFAULT_COLOR) : void 0;
  const initialGreasedLineOptions = {
    points: allPoints,
    updatable: options.updatable,
    widths,
    lazy: options.lazy,
    ribbonOptions: options.ribbonOptions,
    uvs: options.uvs,
    colorPointers: options.colorPointers
  };
  if (initialGreasedLineOptions.ribbonOptions) {
    if (initialGreasedLineOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {
      initialGreasedLineOptions.ribbonOptions.width = (_l = (_k = materialOptions.width) !== null && _k !== void 0 ? _k : initialGreasedLineOptions.ribbonOptions.width) !== null && _l !== void 0 ? _l : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
    }
  }
  if (!options.instance) {
    instance = initialGreasedLineOptions.ribbonOptions ? new GreasedLineRibbonMesh(name52, scene, initialGreasedLineOptions) : new GreasedLineMesh(name52, scene, initialGreasedLineOptions);
    if (materialOptions) {
      const initialMaterialOptions = {
        materialType: materialOptions.materialType,
        dashCount: materialOptions.dashCount,
        dashOffset: materialOptions.dashOffset,
        dashRatio: materialOptions.dashRatio,
        resolution: materialOptions.resolution,
        sizeAttenuation: materialOptions.sizeAttenuation,
        useColors: materialOptions.useColors,
        useDash: materialOptions.useDash,
        visibility: materialOptions.visibility,
        width: materialOptions.width,
        color: materialOptions.color,
        colorMode: materialOptions.colorMode,
        colorsSampling: materialOptions.colorsSampling,
        colorDistributionType: materialOptions.colorDistributionType,
        colors,
        cameraFacing: !options.ribbonOptions,
        colorsTexture: materialOptions.colorsTexture
      };
      if (materialOptions.createAndAssignMaterial) {
        const material = CreateGreasedLineMaterial(name52, initialMaterialOptions, scene);
        instance.material = material;
        if (((_m = options.ribbonOptions) === null || _m === void 0 ? void 0 : _m.facesMode) === GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING) {
          material.backFaceCulling = false;
        }
      }
    }
  } else {
    instance = options.instance;
    if (instance instanceof GreasedLineRibbonMesh) {
      instance.addPoints(allPoints, initialGreasedLineOptions);
    } else {
      const currentWidths = instance.widths;
      if (currentWidths) {
        const newWidths = currentWidths.slice();
        for (const w of widths) {
          newWidths.push(w);
        }
        instance.widths = newWidths;
      } else {
        instance.widths = widths;
      }
      instance.addPoints(allPoints);
    }
  }
  if (colors && options.instance) {
    if (options.instance.greasedLineMaterial) {
      const currentColors = options.instance.greasedLineMaterial.colors;
      if (currentColors) {
        const newColors = currentColors.concat(colors);
        options.instance.greasedLineMaterial.setColors(newColors, instance.isLazy());
      }
    }
  }
  return instance;
}
function CompleteGreasedLineWidthTable(pointCount, widths, widthsDistribution, defaultWidthUpper = 1, defaultWidthLower = 1) {
  const missingCount = pointCount - widths.length / 2;
  const widthsData = [];
  if (missingCount < 0) {
    return widths.slice(0, pointCount * 2);
  }
  if (missingCount > 0) {
    if (widths.length % 2 != 0) {
      widths.push(defaultWidthUpper);
    }
    if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START_END) {
      const halfCount = Math.floor(widths.length / 2);
      for (let i = 0, j = 0; i < halfCount - 1; i++) {
        widthsData.push(widths[j++]);
        widthsData.push(widths[j++]);
      }
      const widthL = widths[halfCount / 2];
      const widthU = widths[halfCount / 2 + 1];
      for (let i = 0; i < missingCount; i++) {
        widthsData.push(widthU);
        widthsData.push(widthL);
      }
      for (let i = halfCount; i < widths.length; i += 2) {
        widthsData.push(widths[i]);
        widthsData.push(widths[i + 1]);
      }
    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START) {
      for (let i = 0; i < widths.length; i += 2) {
        widthsData.push(widths[i]);
        widthsData.push(widths[i + 1]);
      }
      for (let i = 0; i < missingCount; i++) {
        widthsData.push(defaultWidthUpper);
        widthsData.push(defaultWidthLower);
      }
    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_END) {
      for (let i = 0; i < missingCount; i++) {
        widthsData.push(defaultWidthUpper);
        widthsData.push(defaultWidthLower);
      }
      for (let i = 0; i < widths.length; i += 2) {
        widthsData.push(widths[i]);
        widthsData.push(widths[i + 1]);
      }
    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_REPEAT) {
      let i = 0;
      for (let x = 0; x < pointCount; x++) {
        widthsData.push(widths[i++]);
        widthsData.push(widths[i++]);
        if (i === widths.length) {
          i = 0;
        }
      }
    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_EVEN) {
      let j = 0;
      const widthsectorLength = widths.length / ((pointCount - 1) * 2);
      for (let x = 0; x < pointCount; x++) {
        const i = Math.floor(j);
        widthsData.push(widths[i]);
        widthsData.push(widths[i + 1]);
        j += widthsectorLength;
      }
    }
  } else {
    for (let i = 0; i < widths.length; i++) {
      widthsData.push(widths[i]);
    }
  }
  return widthsData;
}
function CompleteGreasedLineColorTable(pointCount, colors, colorDistribution, defaultColor) {
  pointCount = Math.max(colors.length, pointCount);
  const missingCount = pointCount - colors.length;
  if (missingCount < 0) {
    return colors.slice(0, pointCount);
  }
  const colorsData = [];
  if (missingCount > 0) {
    if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START_END) {
      const halfCount = Math.floor(colors.length / 2);
      for (let i = 0; i < halfCount; i++) {
        colorsData.push(colors[i]);
      }
      for (let i = 0; i < missingCount - 1; i++) {
        colorsData.push(defaultColor);
      }
      for (let i = halfCount; i < colors.length; i++) {
        colorsData.push(colors[i]);
      }
    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START) {
      for (let i = 0; i < colors.length; i++) {
        colorsData.push(colors[i]);
      }
      for (let i = 0; i < missingCount; i++) {
        colorsData.push(defaultColor);
      }
    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_END) {
      for (let i = 0; i < missingCount - 1; i++) {
        colorsData.push(defaultColor);
      }
      for (let i = 0; i < colors.length; i++) {
        colorsData.push(colors[i]);
      }
    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_REPEAT) {
      let i = 0;
      for (let x = 0; x < pointCount; x++) {
        colorsData.push(colors[i]);
        i++;
        if (i === colors.length) {
          i = 0;
        }
      }
    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_EVEN) {
      let j = 0;
      const colorSectorLength = colors.length / (pointCount - 1);
      for (let x = 0; x < pointCount - 1; x++) {
        const i = Math.floor(j);
        colorsData.push(colors[i]);
        j += colorSectorLength;
      }
    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_NONE) {
      for (let i = 0; i < colors.length; i++) {
        colorsData.push(colors[i]);
      }
    }
  } else {
    for (let i = 0; i < pointCount; i++) {
      colorsData.push(colors[i]);
    }
  }
  return colorsData;
}

// node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js
var WebGPUDataBuffer = class extends DataBuffer {
  constructor(resource, capacity = 0) {
    super();
    this.capacity = capacity;
    this._buffer = resource;
  }
  get underlyingResource() {
    return this._buffer;
  }
};

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
  if (!this.getScene().getEngine().getCaps().instancedArrays) {
    Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
    return -1;
  }
  this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
  const index = this._thinInstanceDataStorage.instancesCount;
  if (Array.isArray(matrix)) {
    for (let i = 0; i < matrix.length; ++i) {
      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
    }
  } else {
    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
  }
  return index;
};
Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
};
Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  this.removeVerticesData(kind);
  this._thinInstanceInitializeUserStorage();
  this._userThinInstanceBuffersStorage.strides[kind] = stride;
  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
};
Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  matrix.copyToArray(matrixData, index * 16);
  if (this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices[index] = matrix;
  }
  if (refresh) {
    this.thinInstanceBufferUpdated("matrix");
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  }
  return true;
};
Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  this._thinInstanceUpdateBufferSize(kind, 0);
  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
  if (refresh) {
    this.thinInstanceBufferUpdated(kind);
  }
  return true;
};
Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
  get: function() {
    return this._thinInstanceDataStorage.instancesCount;
  },
  set: function(value) {
    var _a, _b;
    const matrixData = (_a = this._thinInstanceDataStorage.matrixData) !== null && _a !== void 0 ? _a : (_b = this.source) === null || _b === void 0 ? void 0 : _b._thinInstanceDataStorage.matrixData;
    const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
    if (value <= numMaxInstances) {
      this._thinInstanceDataStorage.instancesCount = value;
    }
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = false) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
  for (let i = 0; i < 4; i++) {
    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
  }
  return matrixBuffer;
};
Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = false) {
  var _a, _b, _c;
  stride = stride || 16;
  if (kind === "matrix") {
    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
    this._thinInstanceDataStorage.matrixData = buffer;
    this._thinInstanceDataStorage.worldMatrices = null;
    if (buffer !== null) {
      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
      if (!this.doNotSyncBoundingInfo) {
        this.thinInstanceRefreshBoundingInfo(false);
      }
    } else {
      this._thinInstanceDataStorage.instancesCount = 0;
      if (!this.doNotSyncBoundingInfo) {
        this.refreshBoundingInfo();
      }
    }
  } else if (kind === "previousMatrix") {
    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
    this._thinInstanceDataStorage.previousMatrixBuffer = null;
    this._thinInstanceDataStorage.previousMatrixData = buffer;
    if (buffer !== null) {
      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if (buffer === null) {
      if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {
        this.removeVerticesData(kind);
        delete this._userThinInstanceBuffersStorage.data[kind];
        delete this._userThinInstanceBuffersStorage.strides[kind];
        delete this._userThinInstanceBuffersStorage.sizes[kind];
        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
      }
    } else {
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.data[kind] = buffer;
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
  var _a, _b, _c;
  if (kind === "matrix") {
    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else if (kind === "previousMatrix") {
    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
    }
  }
};
Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
  var _a;
  if (kind === "matrix") {
    if (this._thinInstanceDataStorage.matrixBuffer) {
      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
    }
  }
};
Mesh.prototype.thinInstanceGetWorldMatrices = function() {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return [];
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (!this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices = [];
    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
    }
  }
  return this._thinInstanceDataStorage.worldMatrices;
};
Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return;
  }
  const vectors = this._thinInstanceDataStorage.boundingVectors;
  if (forceRefreshParentInfo || !this.rawBoundingInfo) {
    vectors.length = 0;
    this.refreshBoundingInfo(applySkeleton, applyMorph);
    const boundingInfo2 = this.getBoundingInfo();
    this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
  }
  const boundingInfo = this.getBoundingInfo();
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (vectors.length === 0) {
    for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
      vectors.push(boundingInfo.boundingBox.vectors[v].clone());
    }
  }
  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
  for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
    for (let v = 0; v < vectors.length; ++v) {
      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
    }
  }
  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
  this._updateBoundingInfo();
};
Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
  var _a, _b, _c;
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  const kindIsMatrix = kind === "matrix";
  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
    return;
  }
  const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
  const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
  let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
  const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
  let newSize = currentSize;
  while (newSize < bufferSize) {
    newSize *= 2;
  }
  if (!data || currentSize != newSize) {
    if (!data) {
      data = new Float32Array(newSize);
    } else {
      const newData = new Float32Array(newSize);
      newData.set(data, 0);
      data = newData;
    }
    if (kindIsMatrix) {
      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
      this._thinInstanceDataStorage.matrixData = data;
      this._thinInstanceDataStorage.matrixBufferSize = newSize;
      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
      }
    } else {
      (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();
      this._userThinInstanceBuffersStorage.data[kind] = data;
      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype._thinInstanceInitializeUserStorage = function() {
  if (!this._userThinInstanceBuffersStorage) {
    this._userThinInstanceBuffersStorage = {
      data: {},
      sizes: {},
      vertexBuffers: {},
      strides: {}
    };
  }
};
Mesh.prototype._disposeThinInstanceSpecificData = function() {
  var _a;
  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {
    this._thinInstanceDataStorage.matrixBuffer.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
  }
};

// node_modules/@babylonjs/core/Meshes/Node/Enums/nodeGeometryConnectionPointTypes.js
var NodeGeometryBlockConnectionPointTypes;
(function(NodeGeometryBlockConnectionPointTypes2) {
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Int"] = 1] = "Int";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Float"] = 2] = "Float";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Matrix"] = 32] = "Matrix";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Geometry"] = 64] = "Geometry";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Texture"] = 128] = "Texture";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["Undefined"] = 4096] = "Undefined";
  NodeGeometryBlockConnectionPointTypes2[NodeGeometryBlockConnectionPointTypes2["All"] = 4095] = "All";
})(NodeGeometryBlockConnectionPointTypes || (NodeGeometryBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Meshes/Node/nodeGeometryBlockConnectionPoint.js
var NodeGeometryConnectionPointCompatibilityStates;
(function(NodeGeometryConnectionPointCompatibilityStates2) {
  NodeGeometryConnectionPointCompatibilityStates2[NodeGeometryConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeGeometryConnectionPointCompatibilityStates2[NodeGeometryConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeGeometryConnectionPointCompatibilityStates2[NodeGeometryConnectionPointCompatibilityStates2["HierarchyIssue"] = 2] = "HierarchyIssue";
})(NodeGeometryConnectionPointCompatibilityStates || (NodeGeometryConnectionPointCompatibilityStates = {}));
var NodeGeometryConnectionPointDirection;
(function(NodeGeometryConnectionPointDirection2) {
  NodeGeometryConnectionPointDirection2[NodeGeometryConnectionPointDirection2["Input"] = 0] = "Input";
  NodeGeometryConnectionPointDirection2[NodeGeometryConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeGeometryConnectionPointDirection || (NodeGeometryConnectionPointDirection = {}));
var NodeGeometryConnectionPoint = class {
  /** Gets the direction of the point */
  get direction() {
    return this._direction;
  }
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
        return this._linkedConnectionSource.type;
      }
    }
    if (this._type === NodeGeometryBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
          return this._defaultConnectionPointType;
        }
        return this._typeConnectionSource.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  /**
   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
   */
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  /** Get the other side of the connection (if any) */
  get connectedPoint() {
    return this._connectedPoint;
  }
  /** Get the block that owns this connection point */
  get ownerBlock() {
    return this._ownerBlock;
  }
  /** Get the block connected on the other side of this connection (if any) */
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  /** Get the block connected on the endpoints of this connection (if any) */
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  /** Gets the list of connected endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /** Gets a boolean indicating if that output point is connected to at least one input */
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
  get innerType() {
    if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  /** @internal */
  _resetCounters() {
    this._callCount = 0;
    this._executionCount = 0;
  }
  /**
   * Gets the number of times this point was called
   */
  get callCount() {
    return this._callCount;
  }
  /**
   * Gets the number of times this point was executed
   */
  get executionCount() {
    return this._executionCount;
  }
  /**
   * Gets the value represented by this connection point
   * @param state current evaluation state
   * @returns the connected value or the value if nothing is connected
   */
  getConnectedValue(state) {
    var _a;
    if (this.isConnected) {
      if ((_a = this._connectedPoint) === null || _a === void 0 ? void 0 : _a._storedFunction) {
        this._connectedPoint._callCount++;
        this._connectedPoint._executionCount++;
        return this._connectedPoint._storedFunction(state);
      }
      this._connectedPoint._callCount++;
      this._connectedPoint._executionCount = 1;
      return this._connectedPoint._storedValue;
    }
    this._callCount++;
    this._executionCount = 1;
    return this.value;
  }
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   */
  constructor(name52, ownerBlock, direction) {
    this._connectedPoint = null;
    this._storedValue = null;
    this._storedFunction = null;
    this._acceptedConnectionPointType = null;
    this._endpoints = new Array();
    this._type = NodeGeometryBlockConnectionPointTypes.Geometry;
    this._linkedConnectionSource = null;
    this._typeConnectionSource = null;
    this._defaultConnectionPointType = null;
    this.acceptedConnectionPointTypes = [];
    this.excludedConnectionPointTypes = [];
    this.onConnectionObservable = new Observable();
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this.defaultValue = null;
    this.value = null;
    this.valueMin = null;
    this.valueMax = null;
    this._callCount = 0;
    this._executionCount = 0;
    this._ownerBlock = ownerBlock;
    this.name = name52;
    this._direction = direction;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialConnectionPoint"
   * @returns the class name
   */
  getClassName() {
    return "NodeGeometryConnectionPoint";
  }
  /**
   * Gets a boolean indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a boolean
   */
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === NodeGeometryConnectionPointCompatibilityStates.Compatible;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeGeometryBlockConnectionPointTypes.AutoDetect) {
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {
        return NodeGeometryConnectionPointCompatibilityStates.Compatible;
      } else {
        return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return NodeGeometryConnectionPointCompatibilityStates.TypeIncompatible;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === NodeGeometryConnectionPointDirection.Input) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return NodeGeometryConnectionPointCompatibilityStates.HierarchyIssue;
    }
    return NodeGeometryConnectionPointCompatibilityStates.Compatible;
  }
  /**
   * Connect this point to another connection point
   * @param connectionPoint defines the other connection point
   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
   * @returns the current connection point
   */
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw "Cannot connect these two connectors.";
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Disconnect this point from one of his endpoint
   * @param endpoint defines the other connection point
   * @returns the current connection point
   */
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    return this;
  }
  /**
   * Fill the list of excluded connection point types with all types other than those passed in the parameter
   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
   */
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 1;
    while (bitmask < NodeGeometryBlockConnectionPointTypes.All) {
      if (!(mask & bitmask)) {
        this.excludedConnectionPointTypes.push(bitmask);
      }
      bitmask = bitmask << 1;
    }
  }
  /**
   * Serializes this point in a JSON representation
   * @param isInput defines if the connection point is an input (default is true)
   * @returns the serialized point object
   */
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.displayName = this.displayName;
    if (this.value !== void 0 && this.value !== null) {
      if (this.value.asArray) {
        serializationObject.valueType = "BABYLON." + this.value.getClassName();
        serializationObject.value = this.value.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this.value;
      }
    }
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
    }
    return serializationObject;
  }
  /**
   * Release resources
   */
  dispose() {
    this.onConnectionObservable.clear();
  }
};

// node_modules/@babylonjs/core/Meshes/Node/nodeGeometryBlock.js
var NodeGeometryBlock = class {
  /**
   * Gets the time spent to build this block (in ms)
   */
  get buildExecutionTime() {
    return this._buildExecutionTime;
  }
  /**
   * Gets the list of input points
   */
  get inputs() {
    return this._inputs;
  }
  /** Gets the list of output points */
  get outputs() {
    return this._outputs;
  }
  /**
   * Gets or set the name of the block
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Gets a boolean indicating if this block is an input
   */
  get isInput() {
    return this._isInput;
  }
  /**
   * Gets a boolean indicating if this block is a teleport out
   */
  get isTeleportOut() {
    return this._isTeleportOut;
  }
  /**
   * Gets a boolean indicating if this block is a teleport in
   */
  get isTeleportIn() {
    return this._isTeleportIn;
  }
  /**
   * Gets a boolean indicating if this block is a debug block
   */
  get isDebug() {
    return this._isDebug;
  }
  /**
   * Gets a boolean indicating that this block can only be used once per NodeGeometry
   */
  get isUnique() {
    return this._isUnique;
  }
  /**
   * Gets the current class name e.g. "NodeGeometryBlock"
   * @returns the class name
   */
  getClassName() {
    return "NodeGeometryBlock";
  }
  _inputRename(name52) {
    return name52;
  }
  _outputRename(name52) {
    return name52;
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Checks if the current block is an ancestor of a given type
   * @param type defines the potential type to check
   * @returns true if block is a descendant
   */
  isAnAncestorOfType(type) {
    if (this.getClassName() === type) {
      return true;
    }
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock.isAnAncestorOfType(type)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Get the first descendant using a predicate
   * @param predicate defines the predicate to check
   * @returns descendant or null if none found
   */
  getDescendantOfPredicate(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);
        if (descendant) {
          return descendant;
        }
      }
    }
    return null;
  }
  /**
   * Creates a new NodeGeometryBlock
   * @param name defines the block name
   */
  constructor(name52) {
    this._name = "";
    this._isInput = false;
    this._isTeleportOut = false;
    this._isTeleportIn = false;
    this._isDebug = false;
    this._isUnique = false;
    this._buildExecutionTime = 0;
    this.onBuildObservable = new Observable();
    this._inputs = new Array();
    this._outputs = new Array();
    this._codeVariableName = "";
    this.visibleOnFrame = false;
    this._name = name52;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  /**
   * Register a new input. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param isOptional defines a boolean indicating that this input can be omitted
   * @param value value to return if there is no connection
   * @param valueMin min value accepted for value
   * @param valueMax max value accepted for value
   * @returns the current block
   */
  registerInput(name52, type, isOptional = false, value, valueMin, valueMax) {
    const point = new NodeGeometryConnectionPoint(name52, this, NodeGeometryConnectionPointDirection.Input);
    point.type = type;
    point.isOptional = isOptional;
    point.defaultValue = value;
    point.value = value;
    point.valueMin = valueMin;
    point.valueMax = valueMax;
    this._inputs.push(point);
    return this;
  }
  /**
   * Register a new output. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerOutput(name52, type, point) {
    point = point !== null && point !== void 0 ? point : new NodeGeometryConnectionPoint(name52, this, NodeGeometryConnectionPointDirection.Output);
    point.type = type;
    this._outputs.push(point);
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _buildBlock(state) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _customBuildStep(state) {
  }
  /**
   * Build the current node and generate the vertex data
   * @param state defines the current generation state
   * @returns true if already built
   */
  build(state) {
    if (this._buildId === state.buildId) {
      return true;
    }
    if (this._outputs.length > 0) {
      if (!this._outputs.some((o) => o.hasEndpoints) && !this.isDebug) {
        return false;
      }
      this.outputs.forEach((o) => o._resetCounters());
    }
    this._buildId = state.buildId;
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        block.build(state);
      }
    }
    this._customBuildStep(state);
    if (state.verbose) {
      console.log(`Building ${this.name} [${this.getClassName()}]`);
    }
    const now = PrecisionDate.Now;
    this._buildBlock(state);
    this._buildExecutionTime = PrecisionDate.Now - now;
    for (const output of this._outputs) {
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block) {
          block.build(state);
        }
      }
    }
    this.onBuildObservable.notifyObservers(this);
    return false;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  /**
   * Initialize the block and prepare the context for build
   */
  initialize() {
  }
  /**
   * Lets the block try to connect some inputs automatically
   */
  autoConfigure() {
  }
  /**
   * Find an input by its name
   * @param name defines the name of the input to look for
   * @returns the input or null if not found
   */
  getInputByName(name52) {
    const filter = this._inputs.filter((e) => e.name === name52);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Find an output by its name
   * @param name defines the name of the output to look for
   * @returns the output or null if not found
   */
  getOutputByName(name52) {
    const filter = this._outputs.filter((e) => e.name === name52);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  _deserialize(serializationObject) {
    this._name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleOnFrame = !!serializationObject.visibleOnFrame;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      serializedInputs.forEach((port) => {
        const input = this.inputs.find((i) => i.name === port.name);
        if (!input) {
          return;
        }
        if (port.displayName) {
          input.displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          input.isExposedOnFrame = port.isExposedOnFrame;
          input.exposedPortPosition = port.exposedPortPosition;
        }
        if (port.value !== void 0 && port.value !== null) {
          if (port.valueType === "number") {
            input.value = port.value;
          } else {
            const valueType = GetClass(port.valueType);
            if (valueType) {
              input.value = valueType.FromArray(port.value);
            }
          }
        }
      });
    }
    if (serializedOutputs) {
      serializedOutputs.forEach((port, i) => {
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};
`;
  }
  /**
   * @internal
   */
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
    }
    return codeString;
  }
  /**
   * @internal
   */
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    let codeString = `
// ${this.getClassName()}
`;
    if (this.comments) {
      codeString += `// ${this.comments}
`;
    }
    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`;
    codeString += this._dumpPropertiesCode();
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @returns a copy of the current block
   */
  clone() {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const block = new blockType();
      block._deserialize(serializationObject);
      return block;
    }
    return null;
  }
  /**
   * Release resources
   */
  dispose() {
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
    this.onBuildObservable.clear();
  }
};
__decorate([
  serialize("comment")
], NodeGeometryBlock.prototype, "comments", void 0);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryOutputBlock.js
var GeometryOutputBlock = class extends NodeGeometryBlock {
  /**
   * Gets the current vertex data if the graph was successfully built
   */
  get currentVertexData() {
    return this._vertexData;
  }
  /**
   * Create a new GeometryOutputBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._vertexData = null;
    this._isUnique = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryOutputBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  _buildBlock(state) {
    state.vertexData = this.geometry.getConnectedValue(state);
    this._vertexData = state.vertexData;
  }
};
RegisterClass("BABYLON.GeometryOutputBlock", GeometryOutputBlock);

// node_modules/@babylonjs/core/Meshes/Node/Enums/nodeGeometryContextualSources.js
var NodeGeometryContextualSources;
(function(NodeGeometryContextualSources2) {
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["None"] = 0] = "None";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["Positions"] = 1] = "Positions";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["Normals"] = 2] = "Normals";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["Tangents"] = 3] = "Tangents";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV"] = 4] = "UV";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV2"] = 5] = "UV2";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV3"] = 6] = "UV3";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV4"] = 7] = "UV4";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV5"] = 8] = "UV5";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["UV6"] = 9] = "UV6";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["Colors"] = 10] = "Colors";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["VertexID"] = 11] = "VertexID";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["FaceID"] = 12] = "FaceID";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["GeometryID"] = 13] = "GeometryID";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["CollectionID"] = 14] = "CollectionID";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["LoopID"] = 15] = "LoopID";
  NodeGeometryContextualSources2[NodeGeometryContextualSources2["InstanceID"] = 16] = "InstanceID";
})(NodeGeometryContextualSources || (NodeGeometryContextualSources = {}));

// node_modules/@babylonjs/core/Meshes/Node/nodeGeometryBuildState.js
var NodeGeometryBuildState = class {
  constructor() {
    this._rotationMatrix = new Matrix();
    this._scalingMatrix = new Matrix();
    this._positionMatrix = new Matrix();
    this._scalingRotationMatrix = new Matrix();
    this._transformMatrix = new Matrix();
    this._tempVector3 = new Vector3();
    this.notConnectedNonOptionalInputs = [];
    this.noContextualData = [];
    this.vertexData = null;
    this._geometryContext = null;
    this._executionContext = null;
    this._instancingContext = null;
    this._geometryContextStack = [];
    this._executionContextStack = [];
    this._instancingContextStack = [];
  }
  /** Gets or sets the geometry context */
  get geometryContext() {
    return this._geometryContext;
  }
  /** Gets or sets the execution context */
  get executionContext() {
    return this._executionContext;
  }
  /** Gets or sets the instancing context */
  get instancingContext() {
    return this._instancingContext;
  }
  /**
   * Push the new active geometry context
   * @param geometryContext defines the geometry context
   */
  pushGeometryContext(geometryContext) {
    this._geometryContext = geometryContext;
    this._geometryContextStack.push(this._geometryContext);
  }
  /**
   * Push the new active execution context
   * @param executionContext defines the execution context
   */
  pushExecutionContext(executionContext) {
    this._executionContext = executionContext;
    this._executionContextStack.push(this._executionContext);
  }
  /**
   * Push the new active instancing context
   * @param instancingContext defines the instancing context
   */
  pushInstancingContext(instancingContext) {
    this._instancingContext = instancingContext;
    this._instancingContextStack.push(this._instancingContext);
  }
  /**
   * Remove current geometry context and restore the previous one
   */
  restoreGeometryContext() {
    this._geometryContextStack.pop();
    this._geometryContext = this._geometryContextStack.length > 0 ? this._geometryContextStack[this._geometryContextStack.length - 1] : null;
  }
  /**
   * Remove current execution context and restore the previous one
   */
  restoreExecutionContext() {
    this._executionContextStack.pop();
    this._executionContext = this._executionContextStack.length > 0 ? this._executionContextStack[this._executionContextStack.length - 1] : null;
  }
  /**
   * Remove current isntancing context and restore the previous one
   */
  restoreInstancingContext() {
    this._instancingContextStack.pop();
    this._instancingContext = this._instancingContextStack.length > 0 ? this._instancingContextStack[this._instancingContextStack.length - 1] : null;
  }
  /**
   * Gets the value associated with a contextual source
   * @param source Source of the contextual value
   * @param skipWarning Do not store the warning for reporting if true
   * @returns the value associated with the source
   */
  getContextualValue(source, skipWarning = false) {
    if (!this.executionContext) {
      if (!skipWarning) {
        this.noContextualData.push(source);
      }
      return null;
    }
    const index = this.executionContext.getExecutionIndex();
    switch (source) {
      case NodeGeometryContextualSources.Positions:
        if (this.executionContext.getOverridePositionsContextualValue) {
          return this.executionContext.getOverridePositionsContextualValue();
        }
        if (!this.geometryContext || !this.geometryContext.positions) {
          return Vector3.Zero();
        }
        return Vector3.FromArray(this.geometryContext.positions, index * 3);
      case NodeGeometryContextualSources.Normals:
        if (this.executionContext.getOverrideNormalsContextualValue) {
          return this.executionContext.getOverrideNormalsContextualValue();
        }
        if (!this.geometryContext || !this.geometryContext.normals) {
          return Vector3.Zero();
        }
        return Vector3.FromArray(this.geometryContext.normals, index * 3);
      case NodeGeometryContextualSources.Colors:
        if (!this.geometryContext || !this.geometryContext.colors) {
          return Vector4.Zero();
        }
        return Vector4.FromArray(this.geometryContext.colors, index * 4);
      case NodeGeometryContextualSources.Tangents:
        if (!this.geometryContext || !this.geometryContext.tangents) {
          return Vector4.Zero();
        }
        return Vector4.FromArray(this.geometryContext.tangents, index * 4);
      case NodeGeometryContextualSources.UV:
        if (this.executionContext.getOverrideUVs1ContextualValue) {
          return this.executionContext.getOverrideUVs1ContextualValue();
        }
        if (!this.geometryContext || !this.geometryContext.uvs) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs, index * 2);
      case NodeGeometryContextualSources.UV2:
        if (!this.geometryContext || !this.geometryContext.uvs2) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs2, index * 2);
      case NodeGeometryContextualSources.UV3:
        if (!this.geometryContext || !this.geometryContext.uvs3) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs3, index * 2);
      case NodeGeometryContextualSources.UV4:
        if (!this.geometryContext || !this.geometryContext.uvs4) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs4, index * 2);
      case NodeGeometryContextualSources.UV5:
        if (!this.geometryContext || !this.geometryContext.uvs5) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs5, index * 2);
      case NodeGeometryContextualSources.UV6:
        if (!this.geometryContext || !this.geometryContext.uvs6) {
          return Vector2.Zero();
        }
        return Vector2.FromArray(this.geometryContext.uvs6, index * 2);
      case NodeGeometryContextualSources.VertexID:
        return index;
      case NodeGeometryContextualSources.FaceID:
        return this.executionContext.getExecutionFaceIndex();
      case NodeGeometryContextualSources.LoopID:
        return this.executionContext.getExecutionLoopIndex();
      case NodeGeometryContextualSources.InstanceID:
        return this.instancingContext ? this.instancingContext.getInstanceIndex() : 0;
      case NodeGeometryContextualSources.GeometryID:
        return !this.geometryContext ? 0 : this.geometryContext.uniqueId;
      case NodeGeometryContextualSources.CollectionID: {
        if (!this.geometryContext || !this.geometryContext.metadata) {
          return 0;
        }
        return this.geometryContext.metadata.collectionId || 0;
      }
    }
    return null;
  }
  /**
   * Adapt a value to a target type
   * @param source defines the value to adapt
   * @param targetType defines the target type
   * @returns the adapted value
   */
  adapt(source, targetType) {
    const value = source.getConnectedValue(this) || 0;
    if (source.type === targetType) {
      return value;
    }
    switch (targetType) {
      case NodeGeometryBlockConnectionPointTypes.Vector2:
        return new Vector2(value, value);
      case NodeGeometryBlockConnectionPointTypes.Vector3:
        return new Vector3(value, value, value);
      case NodeGeometryBlockConnectionPointTypes.Vector4:
        return new Vector4(value, value, value, value);
    }
    return null;
  }
  /**
   * Adapt an input value to a target type
   * @param source defines the value to adapt
   * @param targetType defines the target type
   * @param defaultValue defines the default value to use if not connected
   * @returns the adapted value
   */
  adaptInput(source, targetType, defaultValue) {
    var _a;
    if (!source.isConnected) {
      return source.value || defaultValue;
    }
    const value = source.getConnectedValue(this);
    if (((_a = source._connectedPoint) === null || _a === void 0 ? void 0 : _a.type) === targetType) {
      return value;
    }
    switch (targetType) {
      case NodeGeometryBlockConnectionPointTypes.Vector2:
        return new Vector2(value, value);
      case NodeGeometryBlockConnectionPointTypes.Vector3:
        return new Vector3(value, value, value);
      case NodeGeometryBlockConnectionPointTypes.Vector4:
        return new Vector4(value, value, value, value);
    }
    return null;
  }
  /**
   * Emits console errors and exceptions if there is a failing check
   */
  emitErrors() {
    let errorMessage = "";
    for (const notConnectedInput of this.notConnectedNonOptionalInputs) {
      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
    }
    for (const source of this.noContextualData) {
      errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).
`;
    }
    if (errorMessage) {
      throw "Build of NodeGeometry failed:\n" + errorMessage;
    }
  }
  /** @internal  */
  _instantiate(clone, currentPosition, rotation, scaling, additionalVertexData) {
    Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);
    Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);
    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);
    this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);
    this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);
    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {
      this._tempVector3.fromArray(clone.positions, clonePositionIndex);
      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);
      this._tempVector3.toArray(clone.positions, clonePositionIndex);
      if (clone.normals) {
        this._tempVector3.fromArray(clone.normals, clonePositionIndex);
        Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);
        this._tempVector3.toArray(clone.normals, clonePositionIndex);
      }
    }
    additionalVertexData.push(clone);
  }
  /** @internal  */
  _instantiateWithMatrix(clone, transform, additionalVertexData) {
    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {
      this._tempVector3.fromArray(clone.positions, clonePositionIndex);
      Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);
      this._tempVector3.toArray(clone.positions, clonePositionIndex);
      if (clone.normals) {
        this._tempVector3.fromArray(clone.normals, clonePositionIndex);
        Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);
        this._tempVector3.toArray(clone.normals, clonePositionIndex);
      }
    }
    additionalVertexData.push(clone);
  }
  /** @internal  */
  _instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData) {
    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);
    transform.multiplyToRef(this._positionMatrix, this._transformMatrix);
    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {
      this._tempVector3.fromArray(clone.positions, clonePositionIndex);
      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);
      this._tempVector3.toArray(clone.positions, clonePositionIndex);
      if (clone.normals) {
        this._tempVector3.fromArray(clone.normals, clonePositionIndex);
        Vector3.TransformNormalToRef(this._tempVector3, this._transformMatrix, this._tempVector3);
        this._tempVector3.toArray(clone.normals, clonePositionIndex);
      }
    }
    additionalVertexData.push(clone);
  }
};

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryInputBlock.js
var GeometryInputBlock = class extends NodeGeometryBlock {
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {
      if (this.value != null) {
        if (!isNaN(this.value)) {
          this._type = NodeGeometryBlockConnectionPointTypes.Float;
          return this._type;
        }
        switch (this.value.getClassName()) {
          case "Vector2":
            this._type = NodeGeometryBlockConnectionPointTypes.Vector2;
            return this._type;
          case "Vector3":
            this._type = NodeGeometryBlockConnectionPointTypes.Vector3;
            return this._type;
          case "Vector4":
            this._type = NodeGeometryBlockConnectionPointTypes.Vector4;
            return this._type;
          case "Matrix":
            this._type = NodeGeometryBlockConnectionPointTypes.Matrix;
            return this._type;
        }
      }
    }
    return this._type;
  }
  /**
   * Gets a boolean indicating that the current connection point is a contextual value
   */
  get isContextual() {
    return this._contextualSource !== NodeGeometryContextualSources.None;
  }
  /**
   * Gets or sets the current contextual value
   */
  get contextualValue() {
    return this._contextualSource;
  }
  set contextualValue(value) {
    this._contextualSource = value;
    switch (value) {
      case NodeGeometryContextualSources.Positions:
      case NodeGeometryContextualSources.Normals:
        this._type = NodeGeometryBlockConnectionPointTypes.Vector3;
        break;
      case NodeGeometryContextualSources.Colors:
      case NodeGeometryContextualSources.Tangents:
        this._type = NodeGeometryBlockConnectionPointTypes.Vector4;
        break;
      case NodeGeometryContextualSources.UV:
      case NodeGeometryContextualSources.UV2:
      case NodeGeometryContextualSources.UV3:
      case NodeGeometryContextualSources.UV4:
      case NodeGeometryContextualSources.UV5:
      case NodeGeometryContextualSources.UV6:
        this._type = NodeGeometryBlockConnectionPointTypes.Vector2;
        break;
      case NodeGeometryContextualSources.VertexID:
      case NodeGeometryContextualSources.GeometryID:
      case NodeGeometryContextualSources.CollectionID:
      case NodeGeometryContextualSources.FaceID:
      case NodeGeometryContextualSources.LoopID:
      case NodeGeometryContextualSources.InstanceID:
        this._type = NodeGeometryBlockConnectionPointTypes.Int;
        break;
    }
    if (this.output) {
      this.output.type = this._type;
    }
  }
  /**
   * Creates a new InputBlock
   * @param name defines the block name
   * @param type defines the type of the input (can be set to NodeGeometryBlockConnectionPointTypes.AutoDetect)
   */
  constructor(name52, type = NodeGeometryBlockConnectionPointTypes.AutoDetect) {
    super(name52);
    this._type = NodeGeometryBlockConnectionPointTypes.Undefined;
    this._contextualSource = NodeGeometryContextualSources.None;
    this.min = 0;
    this.max = 0;
    this.groupInInspector = "";
    this.onValueChangedObservable = new Observable();
    this._type = type;
    this._isInput = true;
    this.setDefaultValue();
    this.registerOutput("output", type);
  }
  /**
   * Gets or sets the value of that point.
   * Please note that this value will be ignored if valueCallback is defined
   */
  get value() {
    return this._storedValue;
  }
  set value(value) {
    if (this.type === NodeGeometryBlockConnectionPointTypes.Float) {
      if (this.min !== this.max) {
        value = Math.max(this.min, value);
        value = Math.min(this.max, value);
      }
    }
    this._storedValue = value;
    this.onValueChangedObservable.notifyObservers(this);
  }
  /**
   * Gets or sets a callback used to get the value of that point.
   * Please note that setting this value will force the connection point to ignore the value property
   */
  get valueCallback() {
    return this._valueCallback;
  }
  set valueCallback(value) {
    this._valueCallback = value;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryInputBlock";
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Set the input block to its default value (based on its type)
   */
  setDefaultValue() {
    this.contextualValue = NodeGeometryContextualSources.None;
    switch (this.type) {
      case NodeGeometryBlockConnectionPointTypes.Int:
      case NodeGeometryBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeGeometryBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.isContextual) {
      this.output._storedValue = null;
      this.output._storedFunction = (state2) => {
        return state2.getContextualValue(this._contextualSource);
      };
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = this.value;
    }
  }
  dispose() {
    this.onValueChangedObservable.clear();
    super.dispose();
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    if (this.isContextual) {
      return super._dumpPropertiesCode() + `${variableName}.contextualValue = BABYLON.NodeGeometryContextualSources.${NodeGeometryContextualSources[this._contextualSource]};
`;
    }
    const codes = [];
    let valueString = "";
    switch (this.type) {
      case NodeGeometryBlockConnectionPointTypes.Float:
      case NodeGeometryBlockConnectionPointTypes.Int:
        valueString = `${this.value}`;
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector2:
        valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector3:
        valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
        break;
      case NodeGeometryBlockConnectionPointTypes.Vector4:
        valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
        break;
    }
    codes.push(`${variableName}.value = ${valueString}`);
    if (this.type === NodeGeometryBlockConnectionPointTypes.Float || this.type === NodeGeometryBlockConnectionPointTypes.Int) {
      codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`);
    }
    codes.push("");
    return super._dumpPropertiesCode() + codes.join(";\n");
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.type = this.type;
    serializationObject.contextualValue = this.contextualValue;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.groupInInspector = this.groupInInspector;
    if (this._storedValue !== null && !this.isContextual) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this._type = serializationObject.type;
    this.contextualValue = serializationObject.contextualValue;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.groupInInspector = serializationObject.groupInInspector || "";
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      const valueType = GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  }
};
RegisterClass("BABYLON.GeometryInputBlock", GeometryInputBlock);

// node_modules/@babylonjs/core/Decorators/nodeDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 4] = "List";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType = PropertyTypeForEdition.Boolean, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options !== null && options !== void 0 ? options : {}
    });
  };
}

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/boxBlock.js
var BoxBlock = class extends NodeGeometryBlock {
  /**
   * Create a new BoxBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("size", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("width", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("height", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("depth", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("subdivisions", NodeGeometryBlockConnectionPointTypes.Int, true, 1);
    this.registerInput("subdivisionsX", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerInput("subdivisionsY", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerInput("subdivisionsZ", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "BoxBlock";
  }
  /**
   * Gets the size input component
   */
  get size() {
    return this._inputs[0];
  }
  /**
   * Gets the width input component
   */
  get width() {
    return this._inputs[1];
  }
  /**
   * Gets the height input component
   */
  get height() {
    return this._inputs[2];
  }
  /**
   * Gets the depth input component
   */
  get depth() {
    return this._inputs[3];
  }
  /**
   * Gets the subdivisions input component
   */
  get subdivisions() {
    return this._inputs[4];
  }
  /**
   * Gets the subdivisionsX input component
   */
  get subdivisionsX() {
    return this._inputs[5];
  }
  /**
   * Gets the subdivisionsY input component
   */
  get subdivisionsY() {
    return this._inputs[6];
  }
  /**
   * Gets the subdivisionsZ input component
   */
  get subdivisionsZ() {
    return this._inputs[7];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (this.size.isConnected) {
      return;
    }
    if (!this.width.isConnected && !this.height.isConnected && !this.depth.isConnected) {
      const sizeInput = new GeometryInputBlock("Size");
      sizeInput.value = 1;
      sizeInput.output.connectTo(this.size);
      return;
    }
    if (!this.width.isConnected) {
      const widthInput = new GeometryInputBlock("Width");
      widthInput.value = 1;
      widthInput.output.connectTo(this.width);
    }
    if (!this.height.isConnected) {
      const heightInput = new GeometryInputBlock("Height");
      heightInput.value = 1;
      heightInput.output.connectTo(this.height);
    }
    if (!this.depth.isConnected) {
      const depthInput = new GeometryInputBlock("Depth");
      depthInput.value = 1;
      depthInput.output.connectTo(this.depth);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.size = this.size.getConnectedValue(state2);
      options.width = this.width.getConnectedValue(state2);
      options.height = this.height.getConnectedValue(state2);
      options.depth = this.depth.getConnectedValue(state2);
      const subdivisions = this.subdivisions.getConnectedValue(state2);
      const subdivisionsX = this.subdivisionsX.getConnectedValue(state2);
      const subdivisionsY = this.subdivisionsY.getConnectedValue(state2);
      const subdivisionsZ = this.subdivisionsZ.getConnectedValue(state2);
      if (subdivisions) {
        options.segments = subdivisions;
      }
      if (subdivisionsX) {
        options.widthSegments = subdivisionsX;
      }
      if (subdivisionsY) {
        options.heightSegments = subdivisionsY;
      }
      if (subdivisionsZ) {
        options.depthSegments = subdivisionsZ;
      }
      return CreateSegmentedBoxVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], BoxBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.BoxBlock", BoxBlock);

// node_modules/@babylonjs/core/Meshes/Node/nodeGeometry.js
var NodeGeometry = class _NodeGeometry {
  /** Get the inspector from bundle or global */
  _getGlobalNodeGeometryEditor() {
    if (typeof NODEGEOMETRYEDITOR !== "undefined") {
      return NODEGEOMETRYEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeGeometryEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  /**
   * Gets the time spent to build this block (in ms)
   */
  get buildExecutionTime() {
    return this._buildExecutionTime;
  }
  /**
   * Creates a new geometry
   * @param name defines the name of the geometry
   */
  constructor(name52) {
    this._buildId = _NodeGeometry._BuildIdGenerator++;
    this._buildWasSuccessful = false;
    this._vertexData = null;
    this._buildExecutionTime = 0;
    this.BJSNODEGEOMETRYEDITOR = this._getGlobalNodeGeometryEditor();
    this.editorData = null;
    this.attachedBlocks = [];
    this.onBuildObservable = new Observable();
    this.outputBlock = null;
    this.name = name52;
  }
  /**
   * Gets the current class name of the geometry e.g. "NodeGeometry"
   * @returns the class name
   */
  getClassName() {
    return "NodeGeometry";
  }
  /**
   * Get a block by its name
   * @param name defines the name of the block to retrieve
   * @returns the required block or null if not found
   */
  getBlockByName(name52) {
    let result = null;
    for (const block of this.attachedBlocks) {
      if (block.name === name52) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name52 + "`");
          return result;
        }
      }
    }
    return result;
  }
  /**
   * Get a block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required block or null if not found
   */
  getBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Gets the list of input blocks attached to this material
   * @returns an array of InputBlocks
   */
  getInputBlocks() {
    const blocks = [];
    for (const block of this.attachedBlocks) {
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  }
  /**
   * Launch the node geometry editor
   * @param config Define the configuration of the editor
   * @returns a promise fulfilled when the node editor is visible
   */
  edit(config) {
    return new Promise((resolve) => {
      this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();
      if (typeof this.BJSNODEGEOMETRYEDITOR == "undefined") {
        const editorUrl = config && config.editorURL ? config.editorURL : _NodeGeometry.EditorURL;
        Tools.LoadBabylonScript(editorUrl, () => {
          this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();
          this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeGeometryEditorConfig);
          resolve();
        });
      } else {
        this._createNodeEditor(config === null || config === void 0 ? void 0 : config.nodeGeometryEditorConfig);
        resolve();
      }
    });
  }
  /** Creates the node editor window. */
  _createNodeEditor(additionalConfig) {
    const nodeEditorConfig = Object.assign({ nodeGeometry: this }, additionalConfig);
    this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(nodeEditorConfig);
  }
  /**
   * Build the final geometry
   * @param verbose defines if the build should log activity
   * @param updateBuildId defines if the internal build Id should be updated (default is true)
   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)
   */
  build(verbose = false, updateBuildId = true, autoConfigure = false) {
    this._buildWasSuccessful = false;
    if (!this.outputBlock) {
      throw "You must define the outputBlock property before building the geometry";
    }
    const now = PrecisionDate.Now;
    this._initializeBlock(this.outputBlock, autoConfigure);
    const state = new NodeGeometryBuildState();
    state.buildId = this._buildId;
    state.verbose = verbose;
    this.outputBlock.build(state);
    if (updateBuildId) {
      this._buildId = _NodeGeometry._BuildIdGenerator++;
    }
    this._buildExecutionTime = PrecisionDate.Now - now;
    state.emitErrors();
    this._buildWasSuccessful = true;
    this._vertexData = state.vertexData;
    this.onBuildObservable.notifyObservers(this);
  }
  /**
   * Creates a mesh from the geometry blocks
   * @param name defines the name of the mesh
   * @param scene The scene the mesh is scoped to
   * @returns The new mesh
   */
  createMesh(name52, scene = null) {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    if (!this._vertexData) {
      return null;
    }
    const mesh = new Mesh(name52, scene);
    this._vertexData.applyToMesh(mesh);
    mesh._internalMetadata = mesh._internalMetadata || {};
    mesh._internalMetadata.nodeGeometry = this;
    return mesh;
  }
  /**
   * Creates a mesh from the geometry blocks
   * @param mesh the mesh to update
   * @returns True if successfully updated
   */
  updateMesh(mesh) {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    if (!this._vertexData) {
      return false;
    }
    this._vertexData.applyToMesh(mesh);
    mesh._internalMetadata = mesh._internalMetadata || {};
    mesh._internalMetadata.nodeGeometry = this;
    return mesh;
  }
  _initializeBlock(node, autoConfigure = true) {
    node.initialize();
    if (autoConfigure) {
      node.autoConfigure();
    }
    node._preparationId = this._buildId;
    if (this.attachedBlocks.indexOf(node) === -1) {
      this.attachedBlocks.push(node);
    }
    for (const input of node.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._initializeBlock(block, autoConfigure);
        }
      }
    }
  }
  /**
   * Clear the current geometry
   */
  clear() {
    this.outputBlock = null;
    this.attachedBlocks.length = 0;
  }
  /**
   * Remove a block from the current geometry
   * @param block defines the block to remove
   */
  removeBlock(block) {
    const attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block === this.outputBlock) {
      this.outputBlock = null;
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the geometry
   * @param merge defines whether or not the source must be merged or replace the current content
   */
  parseSerializedObject(source, merge = false) {
    if (!merge) {
      this.clear();
    }
    const map = {};
    for (const parsedBlock of source.blocks) {
      const blockType = GetClass(parsedBlock.customType);
      if (blockType) {
        const block = new blockType();
        block._deserialize(parsedBlock);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (const block of this.attachedBlocks) {
      if (block.isTeleportOut) {
        const teleportOut = block;
        const id = teleportOut._tempEntryPointUniqueId;
        if (id) {
          const source2 = map[id];
          if (source2) {
            source2.attachToEndpoint(teleportOut);
          }
        }
      }
    }
    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      const parsedBlock = source.blocks[blockIndex];
      const block = map[parsedBlock.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && parsedBlock.inputs.some((i) => i.targetConnectionName) && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodeId) {
      this.outputBlock = map[source.outputNodeId];
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      const locations = source.locations || source.editorData.locations;
      for (const location of locations) {
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      const blockMap = [];
      for (const key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    this.comment = source.comment;
  }
  _restoreConnections(block, source, map) {
    for (const outputPoint of block.outputs) {
      for (const candidate of source.blocks) {
        const target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (const input of candidate.inputs) {
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            const inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  }
  /**
   * Generate a string containing the code declaration required to create an equivalent of this geometry
   * @returns a string
   */
  generateCode() {
    let alreadyDumped = [];
    const blocks = [];
    const uniqueNames = ["const", "var", "let"];
    if (this.outputBlock) {
      this._gatherBlocks(this.outputBlock, blocks);
    }
    let codeString = `let nodeGeometry = new BABYLON.NodeGeometry("${this.name || "node geometry"}");
`;
    for (const node of blocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    if (this.outputBlock) {
      alreadyDumped = [];
      codeString += "// Connections\n";
      codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += "// Output nodes\n";
      codeString += `nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};
`;
      codeString += `nodeGeometry.build();
`;
    }
    return codeString;
  }
  _gatherBlocks(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (const input of rootNode.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
    if (rootNode.isTeleportOut) {
      const block = rootNode;
      if (block.entryPoint) {
        this._gatherBlocks(block.entryPoint, list);
      }
    }
  }
  /**
   * Clear the current geometry and set it to a default state
   */
  setToDefault() {
    this.clear();
    this.editorData = null;
    const dataBlock = new BoxBlock("Box");
    dataBlock.autoConfigure();
    const output = new GeometryOutputBlock("Geometry Output");
    dataBlock.geometry.connectTo(output.geometry);
    this.outputBlock = output;
  }
  /**
   * Makes a duplicate of the current geometry.
   * @param name defines the name to use for the new geometry
   */
  clone(name52) {
    const serializationObject = this.serialize();
    const clone = SerializationHelper.Clone(() => new _NodeGeometry(name52), this);
    clone.name = name52;
    clone.parseSerializedObject(serializationObject);
    clone._buildId = this._buildId;
    clone.build(false);
    return clone;
  }
  /**
   * Serializes this geometry in a JSON representation
   * @param selectedBlocks defines the list of blocks to save (if null the whole geometry will be saved)
   * @returns the serialized geometry object
   */
  serialize(selectedBlocks) {
    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    let blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeGeometry";
      if (this.outputBlock) {
        serializationObject.outputNodeId = this.outputBlock.uniqueId;
      }
    }
    serializationObject.blocks = [];
    for (const block of blocks) {
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (const block of this.attachedBlocks) {
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    return serializationObject;
  }
  /**
   * Disposes the ressources
   */
  dispose() {
    for (const block of this.attachedBlocks) {
      block.dispose();
    }
    this.attachedBlocks.length = 0;
    this.onBuildObservable.clear();
  }
  /**
   * Creates a new node geometry set to default basic configuration
   * @param name defines the name of the geometry
   * @returns a new NodeGeometry
   */
  static CreateDefault(name52) {
    const nodeGeometry = new _NodeGeometry(name52);
    nodeGeometry.setToDefault();
    nodeGeometry.build();
    return nodeGeometry;
  }
  /**
   * Creates a node geometry from parsed geometry data
   * @param source defines the JSON representation of the geometry
   * @returns a new node geometry
   */
  static Parse(source) {
    const nodeGeometry = SerializationHelper.Parse(() => new _NodeGeometry(source.name), source, null);
    nodeGeometry.parseSerializedObject(source);
    nodeGeometry.build();
    return nodeGeometry;
  }
  /**
   * Creates a node geometry from a snippet saved by the node geometry editor
   * @param snippetId defines the snippet to load
   * @param nodeGeometry defines a node geometry to update (instead of creating a new one)
   * @param skipBuild defines whether to build the node geometry
   * @returns a promise that will resolve to the new node geometry
   */
  static ParseFromSnippetAsync(snippetId, nodeGeometry, skipBuild = false) {
    if (snippetId === "_BLANK") {
      return Promise.resolve(_NodeGeometry.CreateDefault("blank"));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.nodeGeometry);
            if (!nodeGeometry) {
              nodeGeometry = SerializationHelper.Parse(() => new _NodeGeometry(snippetId), serializationObject, null);
            }
            nodeGeometry.parseSerializedObject(serializationObject);
            nodeGeometry.snippetId = snippetId;
            try {
              if (!skipBuild) {
                nodeGeometry.build();
              }
              resolve(nodeGeometry);
            } catch (err) {
              reject(err);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
NodeGeometry._BuildIdGenerator = 0;
NodeGeometry.EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;
NodeGeometry.SnippetUrl = `https://snippet.babylonjs.com`;
__decorate([
  serialize()
], NodeGeometry.prototype, "name", void 0);
__decorate([
  serialize("comment")
], NodeGeometry.prototype, "comment", void 0);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryOptimizeBlock.js
var GeometryOptimizeBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new GeometryOptimizeBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.epsilon = Epsilon;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryOptimizeBlock";
  }
  /**
   * Gets the geometry component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      if (!this.geometry.isConnected) {
        return null;
      }
      const vertexData = this.geometry.getConnectedValue(state2);
      const newPositions = [];
      const newIndicesMap = {};
      for (let index = 0; index < vertexData.positions.length; index += 3) {
        const x = vertexData.positions[index];
        const y = vertexData.positions[index + 1];
        const z = vertexData.positions[index + 2];
        let found = false;
        for (let checkIndex = 0; checkIndex < newPositions.length; checkIndex += 3) {
          if (Scalar.WithinEpsilon(x, newPositions[checkIndex], this.epsilon) && Scalar.WithinEpsilon(y, newPositions[checkIndex + 1], this.epsilon) && Scalar.WithinEpsilon(z, newPositions[checkIndex + 2], this.epsilon)) {
            newIndicesMap[index / 3] = checkIndex / 3;
            found = true;
            continue;
          }
        }
        if (!found) {
          newIndicesMap[index / 3] = newPositions.length / 3;
          newPositions.push(x, y, z);
        }
      }
      const newVertexData = new VertexData();
      newVertexData.positions = newPositions;
      newVertexData.indices = vertexData.indices.map((index) => newIndicesMap[index]);
      return newVertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    codeString += `${this._codeVariableName}.epsilon = ${this.epsilon};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    serializationObject.epsilon = this.epsilon;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
    this.epsilon = serializationObject.epsilon;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryOptimizeBlock.prototype, "evaluateContext", void 0);
__decorate([
  editableInPropertyPage("Epsilon", PropertyTypeForEdition.Float, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryOptimizeBlock.prototype, "epsilon", void 0);
RegisterClass("BABYLON.GeometryOptimizeBlock", GeometryOptimizeBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/planeBlock.js
var PlaneBlock = class extends NodeGeometryBlock {
  /**
   * Create a new PlaneBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("size", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("width", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("height", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PlaneBlock";
  }
  /**
   * Gets the size input component
   */
  get size() {
    return this._inputs[0];
  }
  /**
   * Gets the width input component
   */
  get width() {
    return this._inputs[1];
  }
  /**
   * Gets the height input component
   */
  get height() {
    return this._inputs[2];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (this.size.isConnected) {
      return;
    }
    if (!this.width.isConnected && !this.height.isConnected) {
      const sizeInput = new GeometryInputBlock("Size");
      sizeInput.value = 1;
      sizeInput.output.connectTo(this.size);
      return;
    }
    if (!this.width.isConnected) {
      const widthInput = new GeometryInputBlock("Width");
      widthInput.value = 1;
      widthInput.output.connectTo(this.width);
    }
    if (!this.height.isConnected) {
      const heightInput = new GeometryInputBlock("Height");
      heightInput.value = 1;
      heightInput.output.connectTo(this.height);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.size = this.size.getConnectedValue(state2);
      options.width = this.width.getConnectedValue(state2);
      options.height = this.height.getConnectedValue(state2);
      return CreatePlaneVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], PlaneBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.PlaneBlock", PlaneBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/meshBlock.js
var MeshBlock = class extends NodeGeometryBlock {
  /**
   * Gets or sets the mesh to use to get vertex data
   */
  get mesh() {
    return this._mesh;
  }
  set mesh(value) {
    this._mesh = value;
  }
  /**
   * Create a new MeshBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._cachedVertexData = null;
    this.reverseWindingOrder = false;
    this.serializedCachedData = false;
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MeshBlock";
  }
  /**
   * Gets a boolean indicating if the block is using cached data
   */
  get isUsingCachedData() {
    return !this.mesh && !!this._cachedVertexData;
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  /**
   * Remove stored data
   */
  cleanData() {
    this._mesh = null;
    this._cachedVertexData = null;
  }
  _buildBlock() {
    if (!this._mesh) {
      if (this._cachedVertexData) {
        this.geometry._storedValue = this._cachedVertexData.clone();
      } else {
        this.geometry._storedValue = null;
      }
      return;
    }
    const vertexData = VertexData.ExtractFromMesh(this._mesh, false, true);
    this._cachedVertexData = null;
    if (this.reverseWindingOrder && vertexData.indices) {
      for (let index = 0; index < vertexData.indices.length; index += 3) {
        const tmp = vertexData.indices[index];
        vertexData.indices[index] = vertexData.indices[index + 2];
        vertexData.indices[index + 2] = tmp;
      }
    }
    this.geometry._storedFunction = () => {
      return vertexData.clone();
    };
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.serializedCachedData = this.serializedCachedData;
    if (this.serializedCachedData) {
      if (this._mesh) {
        serializationObject.cachedVertexData = VertexData.ExtractFromMesh(this._mesh, false, true).serialize();
      } else if (this._cachedVertexData) {
        serializationObject.cachedVertexData = this._cachedVertexData.serialize();
      }
    }
    serializationObject.reverseWindingOrder = this.reverseWindingOrder;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.cachedVertexData) {
      this._cachedVertexData = VertexData.Parse(serializationObject.cachedVertexData);
    }
    this.serializedCachedData = !!serializationObject.serializedCachedData;
    this.reverseWindingOrder = serializationObject.reverseWindingOrder;
  }
};
__decorate([
  editableInPropertyPage("Serialize cached data", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], MeshBlock.prototype, "serializedCachedData", void 0);
RegisterClass("BABYLON.MeshBlock", MeshBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/icoSphereBlock.js
var IcoSphereBlock = class extends NodeGeometryBlock {
  /**
   * Create a new IcoSphereBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("radius", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("radiusX", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("radiusY", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("radiusZ", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("subdivisions", NodeGeometryBlockConnectionPointTypes.Int, true, 4);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "IcoSphereBlock";
  }
  /**
   * Gets the radius input component
   */
  get radius() {
    return this._inputs[0];
  }
  /**
   * Gets the radiusX input component
   */
  get radiusX() {
    return this._inputs[1];
  }
  /**
   * Gets the radiusY input component
   */
  get radiusY() {
    return this._inputs[2];
  }
  /**
   * Gets the radiusZ input component
   */
  get radiusZ() {
    return this._inputs[3];
  }
  /**
   * Gets the subdivisions input component
   */
  get subdivisions() {
    return this._inputs[4];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.radius.isConnected) {
      const radiusInput = new GeometryInputBlock("Radius");
      radiusInput.value = 0.2;
      radiusInput.output.connectTo(this.radius);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.radius = this.radius.getConnectedValue(state2);
      options.subdivisions = this.subdivisions.getConnectedValue(state2);
      options.radiusX = this.radiusX.getConnectedValue(state2);
      options.radiusY = this.radiusY.getConnectedValue(state2);
      options.radiusZ = this.radiusZ.getConnectedValue(state2);
      return CreateIcoSphereVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], IcoSphereBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.IcoSphereBlock", IcoSphereBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/sphereBlock.js
var SphereBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SphereBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("segments", NodeGeometryBlockConnectionPointTypes.Int, true, 32);
    this.registerInput("diameter", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("diameterX", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("diameterY", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("diameterZ", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("arc", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("slice", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SphereBlock";
  }
  /**
   * Gets the segments input component
   */
  get segments() {
    return this._inputs[0];
  }
  /**
   * Gets the diameter input component
   */
  get diameter() {
    return this._inputs[1];
  }
  /**
   * Gets the diameterX input component
   */
  get diameterX() {
    return this._inputs[2];
  }
  /**
   * Gets the diameterY input component
   */
  get diameterY() {
    return this._inputs[3];
  }
  /**
   * Gets the diameterZ input component
   */
  get diameterZ() {
    return this._inputs[4];
  }
  /**
   * Gets the arc input component
   */
  get arc() {
    return this._inputs[5];
  }
  /**
   * Gets the slice input component
   */
  get slice() {
    return this._inputs[6];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.diameter.isConnected) {
      const diameterInput = new GeometryInputBlock("Diameter");
      diameterInput.value = 1;
      diameterInput.output.connectTo(this.diameter);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.segments = this.segments.getConnectedValue(state2);
      options.diameter = this.diameter.getConnectedValue(state2);
      options.diameterX = this.diameterX.getConnectedValue(state2);
      options.diameterY = this.diameterY.getConnectedValue(state2);
      options.diameterZ = this.diameterZ.getConnectedValue(state2);
      options.arc = this.arc.getConnectedValue(state2);
      options.slice = this.slice.getConnectedValue(state2);
      return CreateSphereVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SphereBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SphereBlock", SphereBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/gridBlock.js
var GridBlock = class extends NodeGeometryBlock {
  /**
   * Create a new GridBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("width", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("height", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("subdivisions", NodeGeometryBlockConnectionPointTypes.Int, true, 1);
    this.registerInput("subdivisionsX", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerInput("subdivisionsY", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GridBlock";
  }
  /**
   * Gets the width input component
   */
  get width() {
    return this._inputs[0];
  }
  /**
   * Gets the height input component
   */
  get height() {
    return this._inputs[1];
  }
  /**
   * Gets the subdivisions input component
   */
  get subdivisions() {
    return this._inputs[2];
  }
  /**
   * Gets the subdivisionsX input component
   */
  get subdivisionsX() {
    return this._inputs[3];
  }
  /**
   * Gets the subdivisionsY input component
   */
  get subdivisionsY() {
    return this._inputs[4];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.width.isConnected) {
      const widthInput = new GeometryInputBlock("Width");
      widthInput.value = 1;
      widthInput.output.connectTo(this.width);
    }
    if (!this.height.isConnected) {
      const heightInput = new GeometryInputBlock("Height");
      heightInput.value = 1;
      heightInput.output.connectTo(this.height);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.width = this.width.getConnectedValue(state2);
      options.height = this.height.getConnectedValue(state2);
      options.subdivisions = this.subdivisions.getConnectedValue(state2);
      options.subdivisionsX = this.subdivisionsX.getConnectedValue(state2);
      options.subdivisionsY = this.subdivisionsY.getConnectedValue(state2);
      return CreateGroundVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GridBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.GridBlock", GridBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/torusBlock.js
var TorusBlock = class extends NodeGeometryBlock {
  /**
   * Create a new TorusBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("diameter", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("thickness", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5);
    this.registerInput("tessellation", NodeGeometryBlockConnectionPointTypes.Int, true, 16);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TorusBlock";
  }
  /**
   * Gets the diameter input component
   */
  get diameter() {
    return this._inputs[0];
  }
  /**
   * Gets the thickness input component
   */
  get thickness() {
    return this._inputs[1];
  }
  /**
   * Gets the tessellation input component
   */
  get tessellation() {
    return this._inputs[2];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.diameter.isConnected) {
      const diameterInput = new GeometryInputBlock("Diameter");
      diameterInput.value = 1;
      diameterInput.output.connectTo(this.diameter);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.thickness = this.thickness.getConnectedValue(state2);
      options.diameter = this.diameter.getConnectedValue(state2);
      options.tessellation = this.tessellation.getConnectedValue(state2);
      return CreateTorusVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], TorusBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.TorusBlock", TorusBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/cylinderBlock.js
var CylinderBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SphereBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("height", NodeGeometryBlockConnectionPointTypes.Float, true, 25);
    this.registerInput("diameter", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("diameterTop", NodeGeometryBlockConnectionPointTypes.Float, true, -1);
    this.registerInput("diameterBottom", NodeGeometryBlockConnectionPointTypes.Float, true, -1);
    this.registerInput("subdivisions", NodeGeometryBlockConnectionPointTypes.Int, true, 1);
    this.registerInput("tessellation", NodeGeometryBlockConnectionPointTypes.Int, true, 24);
    this.registerInput("arc", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CylinderBlock";
  }
  /**
   * Gets the height input component
   */
  get height() {
    return this._inputs[0];
  }
  /**
   * Gets the diameter input component
   */
  get diameter() {
    return this._inputs[1];
  }
  /**
   * Gets the diameterTop input component
   */
  get diameterTop() {
    return this._inputs[2];
  }
  /**
   * Gets the diameterBottom input component
   */
  get diameterBottom() {
    return this._inputs[3];
  }
  /**
   * Gets the subdivisions input component
   */
  get subdivisions() {
    return this._inputs[4];
  }
  /**
   * Gets the tessellation input component
   */
  get tessellation() {
    return this._inputs[5];
  }
  /**
   * Gets the arc input component
   */
  get arc() {
    return this._inputs[6];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.diameter.isConnected) {
      const diameterInput = new GeometryInputBlock("Diameter");
      diameterInput.value = 1;
      diameterInput.output.connectTo(this.diameter);
    }
    if (!this.height.isConnected) {
      const heightInput = new GeometryInputBlock("Height");
      heightInput.value = 1;
      heightInput.output.connectTo(this.height);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.height = this.height.getConnectedValue(state2);
      options.diameter = this.diameter.getConnectedValue(state2);
      options.diameterTop = this.diameterTop.getConnectedValue(state2);
      options.diameterBottom = this.diameterBottom.getConnectedValue(state2);
      if (options.diameterTop === -1) {
        options.diameterTop = options.diameter;
      }
      if (options.diameterBottom === -1) {
        options.diameterBottom = options.diameter;
      }
      options.tessellation = this.tessellation.getConnectedValue(state2);
      options.subdivisions = this.subdivisions.getConnectedValue(state2);
      options.arc = this.arc.getConnectedValue(state2);
      return CreateCylinderVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], CylinderBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.CylinderBlock", CylinderBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/capsuleBlock.js
var CapsuleBlock = class extends NodeGeometryBlock {
  /**
   * Create a new CapsuleBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("height", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("radius", NodeGeometryBlockConnectionPointTypes.Float, true, 0.25);
    this.registerInput("tessellation", NodeGeometryBlockConnectionPointTypes.Int, true, 16);
    this.registerInput("subdivisions", NodeGeometryBlockConnectionPointTypes.Int, true, 2);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CapsuleBlock";
  }
  /**
   * Gets the height input component
   */
  get height() {
    return this._inputs[0];
  }
  /**
   * Gets the radius input component
   */
  get radius() {
    return this._inputs[1];
  }
  /**
   * Gets the tessellation input component
   */
  get tessellation() {
    return this._inputs[2];
  }
  /**
   * Gets the subdivisions input component
   */
  get subdivisions() {
    return this._inputs[3];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.height.isConnected) {
      const heightInput = new GeometryInputBlock("Height");
      heightInput.value = 1;
      heightInput.output.connectTo(this.height);
    }
    if (!this.radius.isConnected) {
      const radiusInput = new GeometryInputBlock("Radius");
      radiusInput.value = 0.2;
      radiusInput.output.connectTo(this.radius);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.height = this.height.getConnectedValue(state2);
      options.radius = this.radius.getConnectedValue(state2);
      options.tessellation = this.tessellation.getConnectedValue(state2);
      options.subdivisions = this.subdivisions.getConnectedValue(state2);
      return CreateCapsuleVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], CapsuleBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.CapsuleBlock", CapsuleBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/discBlock.js
var DiscBlock = class extends NodeGeometryBlock {
  /**
   * Create a new DiscBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("radius", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5);
    this.registerInput("tessellation", NodeGeometryBlockConnectionPointTypes.Int, true, 64);
    this.registerInput("arc", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DiscBlock";
  }
  /**
   * Gets the radius input component
   */
  get radius() {
    return this._inputs[0];
  }
  /**
   * Gets the tessellation input component
   */
  get tessellation() {
    return this._inputs[1];
  }
  /**
   * Gets the arc input component
   */
  get arc() {
    return this._inputs[2];
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.radius.isConnected) {
      const radiusInput = new GeometryInputBlock("Radius");
      radiusInput.value = 0.2;
      radiusInput.output.connectTo(this.radius);
    }
  }
  _buildBlock(state) {
    const options = {};
    const func = (state2) => {
      options.radius = this.radius.getConnectedValue(state2);
      options.tessellation = this.tessellation.getConnectedValue(state2);
      options.arc = this.arc.getConnectedValue(state2);
      return CreateDiscVertexData(options);
    };
    if (this.evaluateContext) {
      this.geometry._storedFunction = func;
    } else {
      const value = func(state);
      this.geometry._storedFunction = () => {
        this.geometry._executionCount = 1;
        return value.clone();
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], DiscBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.DiscBlock", DiscBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Sources/nullBlock.js
var NullBlock = class extends NodeGeometryBlock {
  /**
   * Create a new NullBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerOutput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NullBlock";
  }
  /**
   * Gets the geometry output component
   */
  get geometry() {
    return this._outputs[0];
  }
  _buildBlock() {
    this.geometry._storedValue = null;
  }
};
RegisterClass("BABYLON.NullBlock", NullBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setPositionsBlock.js
var SetPositionsBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetPositionsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("positions", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetPositionsBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the positions input component
   */
  get positions() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      if (this._vertexData) {
        this._vertexData = this._vertexData.clone();
      }
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions || !this.positions.isConnected) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = null;
        return;
      }
      const vertexCount = this._vertexData.positions.length / 3;
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const tempVector3 = this.positions.getConnectedValue(state2);
        if (tempVector3) {
          tempVector3.toArray(this._vertexData.positions, this._currentIndex * 3);
        }
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetPositionsBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SetPositionsBlock", SetPositionsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setNormalsBlock.js
var SetNormalsBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetNormalsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("normals", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetNormalsBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the normals input component
   */
  get normals() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      if (this._vertexData) {
        this._vertexData = this._vertexData.clone();
      }
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = null;
        return;
      }
      if (!this.normals.isConnected) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = this._vertexData;
        return;
      }
      if (!this._vertexData.normals) {
        this._vertexData.normals = [];
      }
      const vertexCount = this._vertexData.positions.length / 3;
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const tempVector3 = this.normals.getConnectedValue(state2);
        if (tempVector3) {
          tempVector3.toArray(this._vertexData.normals, this._currentIndex * 3);
        }
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetNormalsBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SetNormalsBlock", SetNormalsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setUVsBlock.js
var SetUVsBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetUVsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.textureCoordinateIndex = 0;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("uvs", NodeGeometryBlockConnectionPointTypes.Vector2);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetUVsBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the uvs input component
   */
  get uvs() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      if (this._vertexData) {
        this._vertexData = this._vertexData.clone();
      }
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = null;
        return;
      }
      if (!this.uvs.isConnected) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = this._vertexData;
        return;
      }
      const uvs = [];
      const vertexCount = this._vertexData.positions.length / 3;
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const tempVector2 = this.uvs.getConnectedValue(state2);
        if (tempVector2) {
          tempVector2.toArray(uvs, this._currentIndex * 2);
        }
      }
      switch (this.textureCoordinateIndex) {
        case 0:
          this._vertexData.uvs = uvs;
          break;
        case 1:
          this._vertexData.uvs2 = uvs;
          break;
        case 2:
          this._vertexData.uvs3 = uvs;
          break;
        case 3:
          this._vertexData.uvs4 = uvs;
          break;
        case 4:
          this._vertexData.uvs5 = uvs;
          break;
        case 5:
          this._vertexData.uvs6 = uvs;
          break;
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.textureCoordinateIndex};
`;
    codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    serializationObject.textureCoordinateIndex = this.textureCoordinateIndex;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.textureCoordinateIndex = serializationObject.textureCoordinateIndex;
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetUVsBlock.prototype, "evaluateContext", void 0);
__decorate([
  editableInPropertyPage("Texture coordinates index", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { update: true },
    options: [
      { label: "UV1", value: 0 },
      { label: "UV2", value: 1 },
      { label: "UV3", value: 2 },
      { label: "UV4", value: 3 },
      { label: "UV5", value: 4 },
      { label: "UV6", value: 5 }
    ]
  })
], SetUVsBlock.prototype, "textureCoordinateIndex", void 0);
RegisterClass("BABYLON.SetUVsBlock", SetUVsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setColorsBlock.js
var SetColorsBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetColorsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("colors", NodeGeometryBlockConnectionPointTypes.Vector4);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetColorsBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the colors input component
   */
  get colors() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      if (this._vertexData) {
        this._vertexData = this._vertexData.clone();
      }
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = null;
        return;
      }
      if (!this.colors.isConnected) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = this._vertexData;
        return;
      }
      if (!this._vertexData.colors) {
        this._vertexData.colors = [];
      }
      const vertexCount = this._vertexData.positions.length / 3;
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const tempVector4 = this.colors.getConnectedValue(state2);
        if (tempVector4) {
          tempVector4.toArray(this._vertexData.colors, this._currentIndex * 4);
        }
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetColorsBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SetColorsBlock", SetColorsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setTangentsBlock.js
var SetTangentsBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetTangentsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("tangents", NodeGeometryBlockConnectionPointTypes.Vector4);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetTangentsBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the tangents input component
   */
  get tangents() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      if (this._vertexData) {
        this._vertexData = this._vertexData.clone();
      }
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = null;
        return;
      }
      if (!this.tangents.isConnected) {
        state2.restoreGeometryContext();
        state2.restoreExecutionContext();
        this.output._storedValue = this._vertexData;
        return;
      }
      if (!this._vertexData.tangents) {
        this._vertexData.tangents = [];
      }
      const vertexCount = this._vertexData.positions.length / 3;
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const tempVector4 = this.tangents.getConnectedValue(state2);
        if (tempVector4) {
          tempVector4.toArray(this._vertexData.tangents, this._currentIndex * 4);
        }
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetTangentsBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SetTangentsBlock", SetTangentsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/mathBlock.js
var MathBlockOperations;
(function(MathBlockOperations2) {
  MathBlockOperations2[MathBlockOperations2["Add"] = 0] = "Add";
  MathBlockOperations2[MathBlockOperations2["Subtract"] = 1] = "Subtract";
  MathBlockOperations2[MathBlockOperations2["Multiply"] = 2] = "Multiply";
  MathBlockOperations2[MathBlockOperations2["Divide"] = 3] = "Divide";
  MathBlockOperations2[MathBlockOperations2["Max"] = 4] = "Max";
  MathBlockOperations2[MathBlockOperations2["Min"] = 5] = "Min";
})(MathBlockOperations || (MathBlockOperations = {}));
var MathBlock = class extends NodeGeometryBlock {
  /**
   * Create a new MathBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.operation = MathBlockOperations.Add;
    this.registerInput("left", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MathBlock";
  }
  /**
   * Gets the left input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock() {
    let func;
    const left = this.left;
    const right = this.right;
    if (!left.isConnected || !right.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    const isFloat = left.type === NodeGeometryBlockConnectionPointTypes.Float || left.type === NodeGeometryBlockConnectionPointTypes.Int;
    switch (this.operation) {
      case MathBlockOperations.Add: {
        if (isFloat) {
          func = (state) => {
            return left.getConnectedValue(state) + right.getConnectedValue(state);
          };
        } else {
          func = (state) => {
            return left.getConnectedValue(state).add(state.adapt(right, left.type));
          };
        }
        break;
      }
      case MathBlockOperations.Subtract: {
        if (isFloat) {
          func = (state) => {
            return left.getConnectedValue(state) - right.getConnectedValue(state);
          };
        } else {
          func = (state) => {
            return left.getConnectedValue(state).subtract(state.adapt(right, left.type));
          };
        }
        break;
      }
      case MathBlockOperations.Multiply: {
        if (isFloat) {
          func = (state) => {
            return left.getConnectedValue(state) * right.getConnectedValue(state);
          };
        } else {
          func = (state) => {
            return left.getConnectedValue(state).multiply(state.adapt(right, left.type));
          };
        }
        break;
      }
      case MathBlockOperations.Divide: {
        if (isFloat) {
          func = (state) => {
            return left.getConnectedValue(state) / right.getConnectedValue(state);
          };
        } else {
          func = (state) => {
            return left.getConnectedValue(state).divide(state.adapt(right, left.type));
          };
        }
        break;
      }
      case MathBlockOperations.Min: {
        if (isFloat) {
          func = (state) => {
            return Math.min(left.getConnectedValue(state), right.getConnectedValue(state));
          };
        } else {
          switch (left.type) {
            case NodeGeometryBlockConnectionPointTypes.Vector2: {
              func = (state) => {
                return Vector2.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
            case NodeGeometryBlockConnectionPointTypes.Vector3: {
              func = (state) => {
                return Vector3.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
            case NodeGeometryBlockConnectionPointTypes.Vector4: {
              func = (state) => {
                return Vector4.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
          }
        }
        break;
      }
      case MathBlockOperations.Max: {
        if (isFloat) {
          func = (state) => {
            return Math.max(left.getConnectedValue(state), right.getConnectedValue(state));
          };
        } else {
          switch (left.type) {
            case NodeGeometryBlockConnectionPointTypes.Vector2: {
              func = (state) => {
                return Vector2.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
            case NodeGeometryBlockConnectionPointTypes.Vector3: {
              func = (state) => {
                return Vector3.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
            case NodeGeometryBlockConnectionPointTypes.Vector4: {
              func = (state) => {
                return Vector4.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));
              };
              break;
            }
          }
          break;
        }
      }
    }
    this.output._storedFunction = (state) => {
      if (left.type === NodeGeometryBlockConnectionPointTypes.Int) {
        return func(state) | 0;
      }
      return func(state);
    };
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${MathBlockOperations[this.operation]};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.operation = serializationObject.operation;
  }
};
__decorate([
  editableInPropertyPage("Operation", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "Add", value: MathBlockOperations.Add },
      { label: "Subtract", value: MathBlockOperations.Subtract },
      { label: "Multiply", value: MathBlockOperations.Multiply },
      { label: "Divide", value: MathBlockOperations.Divide },
      { label: "Max", value: MathBlockOperations.Max },
      { label: "Min", value: MathBlockOperations.Min }
    ]
  })
], MathBlock.prototype, "operation", void 0);
RegisterClass("BABYLON.MathBlock", MathBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/mapRangeBlock.js
var MapRangeBlock = class extends NodeGeometryBlock {
  /**
   * Create a new MapRangeBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("value", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerInput("fromMin", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("fromMax", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("toMin", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("toMax", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector2);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector3);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Vector4);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MapRangeBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the fromMin input component
   */
  get fromMin() {
    return this._inputs[1];
  }
  /**
   * Gets the fromMax input component
   */
  get fromMax() {
    return this._inputs[2];
  }
  /**
   * Gets the toMin input component
   */
  get toMin() {
    return this._inputs[3];
  }
  /**
   * Gets the toMax input component
   */
  get toMax() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock() {
    if (!this.value.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    this.output._storedFunction = (state) => {
      const value = this.value.getConnectedValue(state);
      const fromMin = this.fromMin.getConnectedValue(state);
      const fromMax = this.fromMax.getConnectedValue(state);
      const toMin = this.toMin.getConnectedValue(state);
      const toMax = this.toMax.getConnectedValue(state);
      const result = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;
      if (this.output.type === NodeGeometryBlockConnectionPointTypes.Int) {
        return Math.floor(result);
      }
      return result;
    };
  }
};
RegisterClass("BABYLON.MapRangeBlock", MapRangeBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/conditionBlock.js
var ConditionBlockTests;
(function(ConditionBlockTests2) {
  ConditionBlockTests2[ConditionBlockTests2["Equal"] = 0] = "Equal";
  ConditionBlockTests2[ConditionBlockTests2["NotEqual"] = 1] = "NotEqual";
  ConditionBlockTests2[ConditionBlockTests2["LessThan"] = 2] = "LessThan";
  ConditionBlockTests2[ConditionBlockTests2["GreaterThan"] = 3] = "GreaterThan";
  ConditionBlockTests2[ConditionBlockTests2["LessOrEqual"] = 4] = "LessOrEqual";
  ConditionBlockTests2[ConditionBlockTests2["GreaterOrEqual"] = 5] = "GreaterOrEqual";
  ConditionBlockTests2[ConditionBlockTests2["Xor"] = 6] = "Xor";
  ConditionBlockTests2[ConditionBlockTests2["Or"] = 7] = "Or";
  ConditionBlockTests2[ConditionBlockTests2["And"] = 8] = "And";
})(ConditionBlockTests || (ConditionBlockTests = {}));
var ConditionBlock = class extends NodeGeometryBlock {
  /**
   * Create a new ConditionBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.test = ConditionBlockTests.Equal;
    this.registerInput("left", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerInput("right", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("ifTrue", NodeGeometryBlockConnectionPointTypes.AutoDetect, true, 1);
    this.registerInput("ifFalse", NodeGeometryBlockConnectionPointTypes.AutoDetect, true, 0);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[2];
    this._outputs[0]._defaultConnectionPointType = NodeGeometryBlockConnectionPointTypes.Float;
    this._inputs[0].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Int);
    this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Int);
    this._linkConnectionTypes(2, 3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ConditionBlock";
  }
  /**
   * Gets the left input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the ifTrue input component
   */
  get ifTrue() {
    return this._inputs[2];
  }
  /**
   * Gets the ifFalse input component
   */
  get ifFalse() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock() {
    if (!this.left.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    const func = (state) => {
      const left = this.left.getConnectedValue(state);
      const right = this.right.getConnectedValue(state);
      let condition = false;
      switch (this.test) {
        case ConditionBlockTests.Equal:
          condition = Scalar.WithinEpsilon(left, right, Epsilon);
          break;
        case ConditionBlockTests.NotEqual:
          condition = left !== right;
          break;
        case ConditionBlockTests.LessThan:
          condition = left < right;
          break;
        case ConditionBlockTests.GreaterThan:
          condition = left > right;
          break;
        case ConditionBlockTests.LessOrEqual:
          condition = left <= right;
          break;
        case ConditionBlockTests.GreaterOrEqual:
          condition = left >= right;
          break;
        case ConditionBlockTests.Xor:
          condition = !!left && !right || !left && !!right;
          break;
        case ConditionBlockTests.Or:
          condition = !!left || !!right;
          break;
        case ConditionBlockTests.And:
          condition = !!left && !!right;
          break;
      }
      return condition;
    };
    this.output._storedFunction = (state) => {
      if (func(state)) {
        return this.ifTrue.getConnectedValue(state);
      }
      return this.ifFalse.getConnectedValue(state);
    };
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.test = BABYLON.ConditionBlockTests.${ConditionBlockTests[this.test]};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.test = this.test;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.test = serializationObject.test;
  }
};
__decorate([
  editableInPropertyPage("Test", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "Equal", value: ConditionBlockTests.Equal },
      { label: "NotEqual", value: ConditionBlockTests.NotEqual },
      { label: "LessThan", value: ConditionBlockTests.LessThan },
      { label: "GreaterThan", value: ConditionBlockTests.GreaterThan },
      { label: "LessOrEqual", value: ConditionBlockTests.LessOrEqual },
      { label: "GreaterOrEqual", value: ConditionBlockTests.GreaterOrEqual },
      { label: "Xor", value: ConditionBlockTests.Xor },
      { label: "Or", value: ConditionBlockTests.Or },
      { label: "And", value: ConditionBlockTests.And }
    ]
  })
], ConditionBlock.prototype, "test", void 0);
RegisterClass("BABYLON.ConditionBlock", ConditionBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/randomBlock.js
var RandomBlockLocks;
(function(RandomBlockLocks2) {
  RandomBlockLocks2[RandomBlockLocks2["None"] = 0] = "None";
  RandomBlockLocks2[RandomBlockLocks2["LoopID"] = 1] = "LoopID";
  RandomBlockLocks2[RandomBlockLocks2["InstanceID"] = 2] = "InstanceID";
})(RandomBlockLocks || (RandomBlockLocks = {}));
var RandomBlock = class extends NodeGeometryBlock {
  /**
   * Create a new RandomBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._currentLockId = -1;
    this.lockMode = RandomBlockLocks.None;
    this.registerInput("min", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerInput("max", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RandomBlock";
  }
  /**
   * Gets the min input component
   */
  get min() {
    return this._inputs[0];
  }
  /**
   * Gets the max input component
   */
  get max() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.min.isConnected) {
      const minInput = new GeometryInputBlock("Min");
      minInput.value = 0;
      minInput.output.connectTo(this.min);
    }
    if (!this.max.isConnected) {
      const maxInput = new GeometryInputBlock("Max");
      maxInput.value = 1;
      maxInput.output.connectTo(this.max);
    }
  }
  _buildBlock() {
    let func = null;
    this._currentLockId = -1;
    switch (this.min.type) {
      case NodeGeometryBlockConnectionPointTypes.Int:
      case NodeGeometryBlockConnectionPointTypes.Float: {
        func = (state) => {
          const min = this.min.getConnectedValue(state) || 0;
          const max = this.max.getConnectedValue(state) || 0;
          return min + Math.random() * (max - min);
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector2: {
        func = (state) => {
          const min = this.min.getConnectedValue(state) || Vector2.Zero();
          const max = this.max.getConnectedValue(state) || Vector2.Zero();
          return new Vector2(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y));
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector3: {
        func = (state) => {
          const min = this.min.getConnectedValue(state) || Vector3.Zero();
          const max = this.max.getConnectedValue(state) || Vector3.Zero();
          return new Vector3(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y), min.z + Math.random() * (max.z - min.z));
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector4: {
        func = (state) => {
          const min = this.min.getConnectedValue(state) || Vector4.Zero();
          const max = this.max.getConnectedValue(state) || Vector4.Zero();
          return new Vector4(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y), min.z + Math.random() * (max.z - min.z), min.w + Math.random() * (max.w - min.w));
        };
        break;
      }
    }
    if (this.lockMode === RandomBlockLocks.None || !func) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = (state) => {
        let lockId = 0;
        switch (this.lockMode) {
          case RandomBlockLocks.InstanceID:
            lockId = state.getContextualValue(NodeGeometryContextualSources.InstanceID, true) || 0;
            break;
          case RandomBlockLocks.LoopID:
            lockId = state.getContextualValue(NodeGeometryContextualSources.LoopID, true) || 0;
            break;
        }
        if (this._currentLockId !== lockId || this.lockMode === RandomBlockLocks.None) {
          this._currentLockId = lockId;
          this.output._storedValue = func(state);
        }
        return this.output._storedValue;
      };
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.lockMode = BABYLON.RandomBlockLocks.${RandomBlockLocks[this.lockMode]};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.lockMode = this.lockMode;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.lockMode = serializationObject.lockMode;
  }
};
__decorate([
  editableInPropertyPage("LockMode", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "None", value: RandomBlockLocks.None },
      { label: "LoopID", value: RandomBlockLocks.LoopID },
      { label: "InstanceID", value: RandomBlockLocks.InstanceID }
    ]
  })
], RandomBlock.prototype, "lockMode", void 0);
RegisterClass("BABYLON.RandomBlock", RandomBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/noiseBlock.js
var NoiseBlock = class extends NodeGeometryBlock {
  /**
   * Create a new NoiseBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("offset", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scale", NodeGeometryBlockConnectionPointTypes.Float, true, 1);
    this.registerInput("octaves", NodeGeometryBlockConnectionPointTypes.Float, true, 2, 0, 16);
    this.registerInput("roughness", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5, 0, 1);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NoiseBlock";
  }
  /**
   * Gets the offset input component
   */
  get offset() {
    return this._inputs[0];
  }
  /**
   * Gets the scale input component
   */
  get scale() {
    return this._inputs[1];
  }
  /**
   * Gets the octaves input component
   */
  get octaves() {
    return this._inputs[2];
  }
  /**
   * Gets the roughtness input component
   */
  get roughness() {
    return this._inputs[3];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _negateIf(value, condition) {
    return condition !== 0 ? -value : value;
  }
  _noiseGrad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const vt = h === 12 || h == 14 ? x : z;
    const v = h < 4 ? y : vt;
    return this._negateIf(u, h & u) + this._negateIf(v, h & 2);
  }
  _fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }
  _hashBitRotate(x, k) {
    return x << k | x >> 32 - k;
  }
  _hash(kx, ky, kz) {
    let a, b, c;
    a = b = c = 3735928559 + (3 << 2) + 13;
    c += kz;
    b += ky;
    a += kx;
    c ^= b;
    c -= this._hashBitRotate(b, 14);
    a ^= c;
    a -= this._hashBitRotate(c, 11);
    b ^= a;
    b -= this._hashBitRotate(a, 25);
    c ^= b;
    c -= this._hashBitRotate(b, 16);
    a ^= c;
    a -= this._hashBitRotate(c, 4);
    b ^= a;
    b -= this._hashBitRotate(a, 14);
    c ^= b;
    c -= this._hashBitRotate(b, 24);
    return c;
  }
  _mix(v0, v1, v2, v3, v4, v5, v6, v7, x, y, z) {
    const x1 = 1 - x;
    const y1 = 1 - y;
    const z1 = 1 - z;
    return z1 * (y1 * (v0 * x1 + v1 * x) + y * (v2 * x1 + v3 * x)) + z * (y1 * (v4 * x1 + v5 * x) + y * (v6 * x1 + v7 * x));
  }
  _perlinNoise(position) {
    const X = (position.x | 0) - (position.x < 0 ? 1 : 0);
    const Y = (position.y | 0) - (position.y < 0 ? 1 : 0);
    const Z = (position.z | 0) - (position.z < 0 ? 1 : 0);
    const fx = position.x - X;
    const fy = position.y - Y;
    const fz = position.z - Z;
    const u = this._fade(fx);
    const v = this._fade(fy);
    const w = this._fade(fz);
    return this._mix(this._noiseGrad(this._hash(X, Y, Z), fx, fy, fz), this._noiseGrad(this._hash(X + 1, Y, Z), fx - 1, fy, fz), this._noiseGrad(this._hash(X, Y + 1, Z), fx, fy - 1, fz), this._noiseGrad(this._hash(X + 1, Y + 1, Z), fx - 1, fy - 1, fz), this._noiseGrad(this._hash(X, Y, Z + 1), fx, fy, fz - 1), this._noiseGrad(this._hash(X + 1, Y, Z + 1), fx - 1, fy, fz - 1), this._noiseGrad(this._hash(X, Y + 1, Z + 1), fx, fy - 1, fz - 1), this._noiseGrad(this._hash(X + 1, Y + 1, Z + 1), fx - 1, fy - 1, fz - 1), u, v, w);
  }
  _perlinSigned(position) {
    return this._perlinNoise(position) * 0.982;
  }
  _perlin(position) {
    return this._perlinSigned(position) / 2 + 0.5;
  }
  /**
   * Gets a perlin noise value
   * @param octaves
   * @param roughness
   * @param position
   * @returns a value between 0 and 1
   * @see Based on https://github.com/blender/blender/blob/main/source/blender/blenlib/intern/noise.cc#L533
   */
  noise(octaves, roughness, _position, offset, scale) {
    const position = new Vector3(_position.x * scale + offset.x, _position.y * scale + offset.y, _position.z * scale + offset.z);
    let fscale = 1;
    let amp = 1;
    let maxamp = 0;
    let sum = 0;
    octaves = Scalar.Clamp(octaves, 0, 15);
    const step = octaves | 0;
    for (let i = 0; i <= step; i++) {
      const t2 = this._perlin(position.scale(fscale));
      sum += t2 * amp;
      maxamp += amp;
      amp *= Scalar.Clamp(roughness, 0, 1);
      fscale *= 2;
    }
    const rmd = octaves - Math.floor(octaves);
    if (rmd == 0) {
      return sum / maxamp;
    }
    const t = this._perlin(position.scale(fscale));
    let sum2 = sum + t * amp;
    sum /= maxamp;
    sum2 /= maxamp + amp;
    return (1 - rmd) * sum + rmd * sum2;
  }
  _buildBlock() {
    this.output._storedFunction = (state) => {
      const position = state.getContextualValue(NodeGeometryContextualSources.Positions);
      const octaves = this.octaves.getConnectedValue(state);
      const roughness = this.roughness.getConnectedValue(state);
      const offset = this.offset.getConnectedValue(state);
      const scale = this.scale.getConnectedValue(state);
      return this.noise(octaves, roughness, position, offset, scale);
    };
  }
};
RegisterClass("BABYLON.NoiseBlock", NoiseBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/mergeGeometryBlock.js
var MergeGeometryBlock = class extends NodeGeometryBlock {
  /**
   * Create a new MergeGeometryBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.registerInput("geometry0", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("geometry1", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry2", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry3", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry4", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MergeGeometryBlock";
  }
  /**
   * Gets the geometry0 input component
   */
  get geometry0() {
    return this._inputs[0];
  }
  /**
   * Gets the geometry1 input component
   */
  get geometry1() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry2 input component
   */
  get geometry2() {
    return this._inputs[2];
  }
  /**
   * Gets the geometry3 input component
   */
  get geometry3() {
    return this._inputs[3];
  }
  /**
   * Gets the geometry4 input component
   */
  get geometry4() {
    return this._inputs[4];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      let vertexData = this.geometry0.getConnectedValue(state2);
      const additionalVertexData = [];
      if (vertexData) {
        vertexData = vertexData.clone();
      } else {
        return null;
      }
      if (this.geometry1.isConnected) {
        const data = this.geometry1.getConnectedValue(state2);
        if (data) {
          additionalVertexData.push(data);
        }
      }
      if (this.geometry2.isConnected) {
        const data = this.geometry2.getConnectedValue(state2);
        if (data) {
          additionalVertexData.push(data);
        }
      }
      if (this.geometry3.isConnected) {
        const data = this.geometry3.getConnectedValue(state2);
        if (data) {
          additionalVertexData.push(data);
        }
      }
      if (this.geometry4.isConnected) {
        const data = this.geometry4.getConnectedValue(state2);
        if (data) {
          additionalVertexData.push(data);
        }
      }
      if (additionalVertexData.length && vertexData) {
        vertexData = vertexData.merge(additionalVertexData, true, false, true, true);
      }
      return vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], MergeGeometryBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.MergeGeometryBlock", MergeGeometryBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryCollectionBlock.js
var GeometryCollectionBlock = class extends NodeGeometryBlock {
  /**
   * Create a new GeometryCollectionBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry0", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry1", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry2", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry3", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry4", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry5", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry6", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry7", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry8", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("geometry9", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryCollectionBlock";
  }
  /**
   * Gets the geometry0 input component
   */
  get geometry0() {
    return this._inputs[0];
  }
  /**
   * Gets the geometry1 input component
   */
  get geometry1() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry2 input component
   */
  get geometry2() {
    return this._inputs[2];
  }
  /**
   * Gets the geometry3 input component
   */
  get geometry3() {
    return this._inputs[3];
  }
  /**
   * Gets the geometry4 input component
   */
  get geometry4() {
    return this._inputs[4];
  }
  /**
   * Gets the geometry5 input component
   */
  get geometry5() {
    return this._inputs[5];
  }
  /**
   * Gets the geometry6 input component
   */
  get geometry6() {
    return this._inputs[6];
  }
  /**
   * Gets the geometry7 input component
   */
  get geometry7() {
    return this._inputs[7];
  }
  /**
   * Gets the geometry8 input component
   */
  get geometry8() {
    return this._inputs[8];
  }
  /**
   * Gets the geometry9 input component
   */
  get geometry9() {
    return this._inputs[9];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _storeGeometry(input, state, index, availables) {
    if (input.isConnected) {
      const vertexData = input.getConnectedValue(state);
      if (!vertexData) {
        return;
      }
      vertexData.metadata = vertexData.metadata || {};
      vertexData.metadata.collectionId = index;
      availables.push(vertexData);
    }
  }
  _buildBlock(state) {
    const func = (state2) => {
      const availables = [];
      this._storeGeometry(this.geometry0, state2, 0, availables);
      this._storeGeometry(this.geometry1, state2, 1, availables);
      this._storeGeometry(this.geometry2, state2, 2, availables);
      this._storeGeometry(this.geometry3, state2, 3, availables);
      this._storeGeometry(this.geometry4, state2, 4, availables);
      this._storeGeometry(this.geometry5, state2, 5, availables);
      this._storeGeometry(this.geometry6, state2, 6, availables);
      this._storeGeometry(this.geometry7, state2, 7, availables);
      this._storeGeometry(this.geometry8, state2, 8, availables);
      this._storeGeometry(this.geometry9, state2, 9, availables);
      if (!availables.length) {
        return null;
      }
      return availables[Math.round(Math.random() * (availables.length - 1))];
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryCollectionBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.GeometryCollectionBlock", GeometryCollectionBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryElbowBlock.js
var GeometryElbowBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new GeometryElbowBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("input", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the time spent to build this block (in ms)
   */
  get buildExecutionTime() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryElbowBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input = this._inputs[0];
    output._storedFunction = (state2) => {
      return input.getConnectedValue(state2);
    };
  }
};
RegisterClass("BABYLON.GeometryElbowBlock", GeometryElbowBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/computeNormalsBlock.js
var ComputeNormalsBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new ComputeNormalsBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ComputeNormalsBlock";
  }
  /**
   * Gets the geometry component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock() {
    this.output._storedFunction = (state) => {
      if (!this.geometry.isConnected) {
        return null;
      }
      const vertexData = this.geometry.getConnectedValue(state);
      if (!vertexData.normals) {
        vertexData.normals = [];
      }
      VertexData.ComputeNormals(vertexData.positions, vertexData.indices, vertexData.normals);
      return vertexData;
    };
  }
};
RegisterClass("BABYLON.ComputeNormalsBlock", ComputeNormalsBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/vectorConverterBlock.js
var VectorConverterBlock = class extends NodeGeometryBlock {
  /**
   * Create a new VectorConverterBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("xyzw ", NodeGeometryBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeGeometryBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeGeometryBlockConnectionPointTypes.Vector2, true);
    this.registerInput("zw ", NodeGeometryBlockConnectionPointTypes.Vector2, true);
    this.registerInput("x ", NodeGeometryBlockConnectionPointTypes.Float, true);
    this.registerInput("y ", NodeGeometryBlockConnectionPointTypes.Float, true);
    this.registerInput("z ", NodeGeometryBlockConnectionPointTypes.Float, true);
    this.registerInput("w ", NodeGeometryBlockConnectionPointTypes.Float, true);
    this.registerOutput("xyzw", NodeGeometryBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeGeometryBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeGeometryBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("z", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("w", NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VectorConverterBlock";
  }
  /**
   * Gets the xyzw component (input)
   */
  get xyzwIn() {
    return this._inputs[0];
  }
  /**
   * Gets the xyz component (input)
   */
  get xyzIn() {
    return this._inputs[1];
  }
  /**
   * Gets the xy component (input)
   */
  get xyIn() {
    return this._inputs[2];
  }
  /**
   * Gets the zw component (input)
   */
  get zwIn() {
    return this._inputs[3];
  }
  /**
   * Gets the x component (input)
   */
  get xIn() {
    return this._inputs[4];
  }
  /**
   * Gets the y component (input)
   */
  get yIn() {
    return this._inputs[5];
  }
  /**
   * Gets the z component (input)
   */
  get zIn() {
    return this._inputs[6];
  }
  /**
   * Gets the w component (input)
   */
  get wIn() {
    return this._inputs[7];
  }
  /**
   * Gets the xyzw component (output)
   */
  get xyzwOut() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component (output)
   */
  get xyzOut() {
    return this._outputs[1];
  }
  /**
   * Gets the xy component (output)
   */
  get xyOut() {
    return this._outputs[2];
  }
  /**
   * Gets the zw component (output)
   */
  get zwOut() {
    return this._outputs[3];
  }
  /**
   * Gets the x component (output)
   */
  get xOut() {
    return this._outputs[4];
  }
  /**
   * Gets the y component (output)
   */
  get yOut() {
    return this._outputs[5];
  }
  /**
   * Gets the z component (output)
   */
  get zOut() {
    return this._outputs[6];
  }
  /**
   * Gets the w component (output)
   */
  get wOut() {
    return this._outputs[7];
  }
  _inputRename(name52) {
    if (name52 === "xyzw ") {
      return "xyzwIn";
    }
    if (name52 === "xyz ") {
      return "xyzIn";
    }
    if (name52 === "xy ") {
      return "xyIn";
    }
    if (name52 === "zw ") {
      return "zwIn";
    }
    if (name52 === "x ") {
      return "xIn";
    }
    if (name52 === "y ") {
      return "yIn";
    }
    if (name52 === "z ") {
      return "zIn";
    }
    if (name52 === "w ") {
      return "wIn";
    }
    return name52;
  }
  _outputRename(name52) {
    switch (name52) {
      case "x":
        return "xOut";
      case "y":
        return "yOut";
      case "z":
        return "zOut";
      case "w":
        return "wOut";
      case "xy":
        return "xyOut";
      case "zw":
        return "zwOut";
      case "xyz":
        return "xyzOut";
      case "xyzw":
        return "xyzwOut";
      default:
        return name52;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const xInput = this.xIn;
    const yInput = this.yIn;
    const zInput = this.zIn;
    const wInput = this.wIn;
    const xyInput = this.xyIn;
    const zwInput = this.zwIn;
    const xyzInput = this.xyzIn;
    const xyzwInput = this.xyzwIn;
    const xyzwOutput = this.xyzwOut;
    const xyzOutput = this.xyzOut;
    const xyOutput = this.xyOut;
    const zwOutput = this.zwOut;
    const xOutput = this.xOut;
    const yOutput = this.yOut;
    const zOutput = this.zOut;
    const wOutput = this.wOut;
    const getData = (state2) => {
      if (xyzwInput.isConnected) {
        return xyzwInput.getConnectedValue(state2);
      }
      let x = 0;
      let y = 0;
      let z = 0;
      let w = 0;
      if (xInput.isConnected) {
        x = xInput.getConnectedValue(state2);
      }
      if (yInput.isConnected) {
        y = yInput.getConnectedValue(state2);
      }
      if (zInput.isConnected) {
        z = zInput.getConnectedValue(state2);
      }
      if (wInput.isConnected) {
        w = wInput.getConnectedValue(state2);
      }
      if (xyInput.isConnected) {
        const temp = xyInput.getConnectedValue(state2);
        if (temp) {
          x = temp.x;
          y = temp.y;
        }
      }
      if (zwInput.isConnected) {
        const temp = zwInput.getConnectedValue(state2);
        if (temp) {
          z = temp.x;
          w = temp.y;
        }
      }
      if (xyzInput.isConnected) {
        const temp = xyzInput.getConnectedValue(state2);
        if (temp) {
          x = temp.x;
          y = temp.y;
          z = temp.z;
        }
      }
      return new Vector4(x, y, z, w);
    };
    xyzwOutput._storedFunction = (state2) => getData(state2);
    xyzOutput._storedFunction = (state2) => {
      const data = getData(state2);
      return new Vector3(data.x, data.y, data.z);
    };
    xyOutput._storedFunction = (state2) => {
      const data = getData(state2);
      return new Vector2(data.x, data.y);
    };
    zwOutput._storedFunction = (state2) => {
      const data = getData(state2);
      return new Vector2(data.z, data.w);
    };
    xOutput._storedFunction = (state2) => getData(state2).x;
    yOutput._storedFunction = (state2) => getData(state2).y;
    zOutput._storedFunction = (state2) => getData(state2).z;
    wOutput._storedFunction = (state2) => getData(state2).w;
  }
};
RegisterClass("BABYLON.VectorConverterBlock", VectorConverterBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/normalizeVectorBlock.js
var NormalizeVectorBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new NormalizeVectorBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("input", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NormalizeVectorBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.output._storedFunction = null;
    if (!this.input.isConnected) {
      this.output._storedValue = null;
      return;
    }
    this.output._storedFunction = (state2) => this.input.getConnectedValue(state2).normalize();
  }
};
RegisterClass("BABYLON.NormalizeVectorBlock", NormalizeVectorBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Set/setMaterialIDBlock.js
var SetMaterialIDBlock = class extends NodeGeometryBlock {
  /**
   * Create a new SetMaterialIDBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("id", NodeGeometryBlockConnectionPointTypes.Int, true, 0);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.id.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SetMaterialIDBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the id input component
   */
  get id() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    if (!this.geometry.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    const func = (state2) => {
      const vertexData = this.geometry.getConnectedValue(state2);
      if (!vertexData || !vertexData.indices || !vertexData.positions) {
        return vertexData;
      }
      const materialInfo = new VertexDataMaterialInfo();
      materialInfo.materialIndex = this.id.getConnectedValue(state2) | 0;
      materialInfo.indexStart = 0;
      materialInfo.indexCount = vertexData.indices.length;
      materialInfo.verticesStart = 0;
      materialInfo.verticesCount = vertexData.positions.length / 3;
      vertexData.materialInfos = [materialInfo];
      return vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], SetMaterialIDBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.SetMaterialIDBlock", SetMaterialIDBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryTrigonometryBlock.js
var GeometryTrigonometryBlockOperations;
(function(GeometryTrigonometryBlockOperations2) {
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Round"] = 4] = "Round";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Floor"] = 5] = "Floor";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Ceiling"] = 6] = "Ceiling";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Sqrt"] = 7] = "Sqrt";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Log"] = 8] = "Log";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Tan"] = 9] = "Tan";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["ArcTan"] = 10] = "ArcTan";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["ArcCos"] = 11] = "ArcCos";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["ArcSin"] = 12] = "ArcSin";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Sign"] = 13] = "Sign";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Negate"] = 14] = "Negate";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["OneMinus"] = 15] = "OneMinus";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["Reciprocal"] = 16] = "Reciprocal";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["ToDegrees"] = 17] = "ToDegrees";
  GeometryTrigonometryBlockOperations2[GeometryTrigonometryBlockOperations2["ToRadians"] = 18] = "ToRadians";
})(GeometryTrigonometryBlockOperations || (GeometryTrigonometryBlockOperations = {}));
var GeometryTrigonometryBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new GeometryTrigonometryBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.operation = GeometryTrigonometryBlockOperations.Cos;
    this.registerInput("input", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryTrigonometryBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    let func = null;
    switch (this.operation) {
      case GeometryTrigonometryBlockOperations.Cos: {
        func = (value) => Math.cos(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Sin: {
        func = (value) => Math.sin(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Abs: {
        func = (value) => Math.abs(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Exp: {
        func = (value) => Math.exp(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Round: {
        func = (value) => Math.round(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Floor: {
        func = (value) => Math.floor(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Ceiling: {
        func = (value) => Math.ceil(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Sqrt: {
        func = (value) => Math.sqrt(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Log: {
        func = (value) => Math.log(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Tan: {
        func = (value) => Math.tan(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.ArcTan: {
        func = (value) => Math.atan(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.ArcCos: {
        func = (value) => Math.acos(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.ArcSin: {
        func = (value) => Math.asin(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Sign: {
        func = (value) => Math.sign(value);
        break;
      }
      case GeometryTrigonometryBlockOperations.Negate: {
        func = (value) => -value;
        break;
      }
      case GeometryTrigonometryBlockOperations.OneMinus: {
        func = (value) => 1 - value;
        break;
      }
      case GeometryTrigonometryBlockOperations.Reciprocal: {
        func = (value) => 1 / value;
        break;
      }
      case GeometryTrigonometryBlockOperations.ToRadians: {
        func = (value) => value * Math.PI / 180;
        break;
      }
      case GeometryTrigonometryBlockOperations.ToDegrees: {
        func = (value) => value * 180 / Math.PI;
        break;
      }
    }
    if (!func) {
      this.input._storedFunction = null;
      this.input._storedValue = null;
      return;
    }
    switch (this.input.type) {
      case NodeGeometryBlockConnectionPointTypes.Int:
      case NodeGeometryBlockConnectionPointTypes.Float: {
        this.output._storedFunction = (state2) => {
          const source = this.input.getConnectedValue(state2);
          return func(source);
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector2: {
        this.output._storedFunction = (state2) => {
          const source = this.input.getConnectedValue(state2);
          return new Vector2(func(source.x), func(source.y));
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector3: {
        this.output._storedFunction = (state2) => {
          const source = this.input.getConnectedValue(state2);
          return new Vector3(func(source.x), func(source.y), func(source.z));
        };
        break;
      }
      case NodeGeometryBlockConnectionPointTypes.Vector4: {
        this.output._storedFunction = (state2) => {
          const source = this.input.getConnectedValue(state2);
          return new Vector4(func(source.x), func(source.y), func(source.z), func(source.w));
        };
        break;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.operation = serializationObject.operation;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.GeometryTrigonometryBlockOperations.${GeometryTrigonometryBlockOperations[this.operation]};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Operation", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "Cos", value: GeometryTrigonometryBlockOperations.Cos },
      { label: "Sin", value: GeometryTrigonometryBlockOperations.Sin },
      { label: "Abs", value: GeometryTrigonometryBlockOperations.Abs },
      { label: "Exp", value: GeometryTrigonometryBlockOperations.Exp },
      { label: "Round", value: GeometryTrigonometryBlockOperations.Round },
      { label: "Floor", value: GeometryTrigonometryBlockOperations.Floor },
      { label: "Ceiling", value: GeometryTrigonometryBlockOperations.Ceiling },
      { label: "Sqrt", value: GeometryTrigonometryBlockOperations.Sqrt },
      { label: "Log", value: GeometryTrigonometryBlockOperations.Log },
      { label: "Tan", value: GeometryTrigonometryBlockOperations.Tan },
      { label: "ArcTan", value: GeometryTrigonometryBlockOperations.ArcTan },
      { label: "ArcCos", value: GeometryTrigonometryBlockOperations.ArcCos },
      { label: "ArcSin", value: GeometryTrigonometryBlockOperations.ArcSin },
      { label: "Sign", value: GeometryTrigonometryBlockOperations.Sign },
      { label: "Negate", value: GeometryTrigonometryBlockOperations.Negate },
      { label: "OneMinus", value: GeometryTrigonometryBlockOperations.OneMinus },
      { label: "Reciprocal", value: GeometryTrigonometryBlockOperations.Reciprocal },
      { label: "ToDegrees", value: GeometryTrigonometryBlockOperations.ToDegrees },
      { label: "ToRadians", value: GeometryTrigonometryBlockOperations.ToRadians }
    ]
  })
], GeometryTrigonometryBlock.prototype, "operation", void 0);
RegisterClass("BABYLON.GeometryTrigonometryBlock", GeometryTrigonometryBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryTransformBlock.js
var GeometryTransformBlock = class extends NodeGeometryBlock {
  /**
   * Create a new GeometryTransformBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._rotationMatrix = new Matrix();
    this._scalingMatrix = new Matrix();
    this._translationMatrix = new Matrix();
    this._scalingRotationMatrix = new Matrix();
    this._transformMatrix = new Matrix();
    this.evaluateContext = true;
    this.registerInput("value", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerInput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix, true);
    this.registerInput("translation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryTransformBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix input component
   */
  get matrix() {
    return this._inputs[1];
  }
  /**
   * Gets the translation input component
   */
  get translation() {
    return this._inputs[2];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[3];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    if (!this.value.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    const func = (state2) => {
      const value = this.value.getConnectedValue(state2);
      if (!value) {
        return null;
      }
      let matrix;
      if (this.matrix.isConnected) {
        matrix = this.matrix.getConnectedValue(state2);
      } else {
        const scaling = this.scaling.getConnectedValue(state2);
        const rotation = this.rotation.getConnectedValue(state2);
        const translation = this.translation.getConnectedValue(state2);
        Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);
        Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);
        Matrix.TranslationToRef(translation.x, translation.y, translation.z, this._translationMatrix);
        this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);
        this._scalingRotationMatrix.multiplyToRef(this._translationMatrix, this._transformMatrix);
        matrix = this._transformMatrix;
      }
      switch (this.value.type) {
        case NodeGeometryBlockConnectionPointTypes.Geometry: {
          const geometry = value.clone();
          geometry.transform(matrix);
          return geometry;
        }
        case NodeGeometryBlockConnectionPointTypes.Vector2:
          return Vector2.Transform(value, matrix);
        case NodeGeometryBlockConnectionPointTypes.Vector3:
          return Vector3.TransformCoordinates(value, matrix);
        case NodeGeometryBlockConnectionPointTypes.Vector4:
          return Vector4.TransformCoordinates(value, matrix);
      }
      return null;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryTransformBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.GeometryTransformBlock", GeometryTransformBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/rotationXBlock.js
var RotationXBlock = class extends NodeGeometryBlock {
  /**
   * Create a new RotationXBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("angle", NodeGeometryBlockConnectionPointTypes.Float, false, 0);
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RotationXBlock";
  }
  /**
   * Gets the angle input component
   */
  get angle() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.angle.isConnected) {
      const angleInput = new GeometryInputBlock("Angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      return Matrix.RotationX(this.angle.getConnectedValue(state2));
    };
  }
};
RegisterClass("BABYLON.RotationXBlock", RotationXBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/rotationYBlock.js
var RotationYBlock = class extends NodeGeometryBlock {
  /**
   * Create a new RotationYBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("angle", NodeGeometryBlockConnectionPointTypes.Float, false, 0);
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RotationYBlock";
  }
  /**
   * Gets the angle input component
   */
  get angle() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.angle.isConnected) {
      const angleInput = new GeometryInputBlock("Angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      return Matrix.RotationY(this.angle.getConnectedValue(state2));
    };
  }
};
RegisterClass("BABYLON.RotationYBlock", RotationYBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/rotationZBlock.js
var RotationZBlock = class extends NodeGeometryBlock {
  /**
   * Create a new RotationZBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("angle", NodeGeometryBlockConnectionPointTypes.Float, false, 0);
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RotationZBlock";
  }
  /**
   * Gets the angle input component
   */
  get angle() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.angle.isConnected) {
      const angleInput = new GeometryInputBlock("Angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      return Matrix.RotationZ(this.angle.getConnectedValue(state2));
    };
  }
};
RegisterClass("BABYLON.RotationZBlock", RotationZBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/scalingBlock.js
var ScalingBlock = class extends NodeGeometryBlock {
  /**
   * Create a new ScalingBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("scale", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.One());
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ScalingBlock";
  }
  /**
   * Gets the scale input component
   */
  get scale() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.scale.isConnected) {
      const scaleInput = new GeometryInputBlock("Scale");
      scaleInput.value = new Vector3(1, 1, 1);
      scaleInput.output.connectTo(this.scale);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      const value = this.scale.getConnectedValue(state2);
      return Matrix.Scaling(value.x, value.y, value.z);
    };
  }
};
RegisterClass("BABYLON.ScalingBlock", ScalingBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/alignBlock.js
var AlignBlock = class extends NodeGeometryBlock {
  /**
   * Create a new AlignBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("source", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Up());
    this.registerInput("target", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Left());
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "AlignBlock";
  }
  /**
   * Gets the source input component
   */
  get source() {
    return this._inputs[0];
  }
  /**
   * Gets the target input component
   */
  get target() {
    return this._inputs[1];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      const source = this.source.getConnectedValue(state2).clone();
      const target = this.target.getConnectedValue(state2).clone();
      const result = new Matrix();
      source.normalize();
      target.normalize();
      Matrix.RotationAlignToRef(source, target, result, true);
      return result;
    };
  }
};
RegisterClass("BABYLON.AlignBlock", AlignBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Matrices/translationBlock.js
var TranslationBlock = class extends NodeGeometryBlock {
  /**
   * Create a new TranslationBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("translation", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.Zero());
    this.registerOutput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TranslationBlock";
  }
  /**
   * Gets the translation input component
   */
  get translation() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix output component
   */
  get matrix() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.translation.isConnected) {
      const translationInput = new GeometryInputBlock("Translation");
      translationInput.value = new Vector3(0, 0, 0);
      translationInput.output.connectTo(this.translation);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this.matrix._storedFunction = (state2) => {
      const value = this.translation.getConnectedValue(state2);
      return Matrix.Translation(value.x, value.y, value.z);
    };
  }
};
RegisterClass("BABYLON.TranslationBlock", TranslationBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateOnVerticesBlock.js
var InstantiateOnVerticesBlock = class extends NodeGeometryBlock {
  /**
   * Create a new InstantiateOnVerticesBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._indexTranslation = null;
    this.evaluateContext = true;
    this.removeDuplicatedPositions = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("instance", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("density", NodeGeometryBlockConnectionPointTypes.Float, true, 1, 0, 1);
    this.registerInput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix, true);
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current instance index in the current flow
   * @returns the current index
   */
  getInstanceIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._indexTranslation ? this._indexTranslation[this._currentIndex] : this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateOnVerticesBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the instance input component
   */
  get instance() {
    return this._inputs[1];
  }
  /**
   * Gets the density input component
   */
  get density() {
    return this._inputs[2];
  }
  /**
   * Gets the matrix input component
   */
  get matrix() {
    return this._inputs[3];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[4];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[5];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions || !this.instance.isConnected) {
        state2.restoreExecutionContext();
        state2.restoreInstancingContext();
        state2.restoreGeometryContext();
        this.output._storedValue = null;
        return;
      }
      let vertexCount = this._vertexData.positions.length / 3;
      const additionalVertexData = [];
      const currentPosition = new Vector3();
      const alreadyDone = [];
      let vertices = this._vertexData.positions;
      this._currentLoopIndex = 0;
      if (this.removeDuplicatedPositions) {
        this._indexTranslation = {};
        for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
          const x = vertices[this._currentIndex * 3];
          const y = vertices[this._currentIndex * 3 + 1];
          const z = vertices[this._currentIndex * 3 + 2];
          let found = false;
          for (let index = 0; index < alreadyDone.length; index += 3) {
            if (Math.abs(alreadyDone[index] - x) < Epsilon && Math.abs(alreadyDone[index + 1] - y) < Epsilon && Math.abs(alreadyDone[index + 2] - z) < Epsilon) {
              found = true;
              break;
            }
          }
          if (found) {
            continue;
          }
          this._indexTranslation[alreadyDone.length / 3] = this._currentIndex;
          alreadyDone.push(x, y, z);
        }
        vertices = alreadyDone;
        vertexCount = vertices.length / 3;
      } else {
        this._indexTranslation = null;
      }
      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {
        const instanceGeometry = this.instance.getConnectedValue(state2);
        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
          continue;
        }
        const density = this.density.getConnectedValue(state2);
        if (density < 1) {
          if (Math.random() > density) {
            continue;
          }
        }
        currentPosition.fromArray(vertices, this._currentIndex * 3);
        const clone = instanceGeometry.clone();
        if (this.matrix.isConnected) {
          const transform = this.matrix.getConnectedValue(state2);
          state2._instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData);
        } else {
          const scaling = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
          const rotation = this.rotation.getConnectedValue(state2) || Vector3.ZeroReadOnly;
          state2._instantiate(clone, currentPosition, rotation, scaling, additionalVertexData);
        }
        this._currentLoopIndex++;
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      } else {
        return null;
      }
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions ? "true" : "false"};
`;
    codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.removeDuplicatedPositions = this.removeDuplicatedPositions;
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.removeDuplicatedPositions = serializationObject.removeDuplicatedPositions;
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], InstantiateOnVerticesBlock.prototype, "evaluateContext", void 0);
__decorate([
  editableInPropertyPage("Remove duplicated positions", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { update: true } })
], InstantiateOnVerticesBlock.prototype, "removeDuplicatedPositions", void 0);
RegisterClass("BABYLON.InstantiateOnVerticesBlock", InstantiateOnVerticesBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateOnFacesBlock.js
var InstantiateOnFacesBlock = class extends NodeGeometryBlock {
  /**
   * Create a new InstantiateOnFacesBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._currentPosition = new Vector3();
    this._currentUV = new Vector2();
    this._vertex0 = new Vector3();
    this._vertex1 = new Vector3();
    this._vertex2 = new Vector3();
    this._tempVector0 = new Vector3();
    this._tempVector1 = new Vector3();
    this._uv0 = new Vector2();
    this._uv1 = new Vector2();
    this._uv2 = new Vector2();
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("instance", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("count", NodeGeometryBlockConnectionPointTypes.Int, true, 256);
    this.registerInput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix, true);
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current instance index in the current flow
   * @returns the current index
   */
  getInstanceIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return 0;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return this._currentFaceIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the value associated with a contextual positions
   * @returns the value associated with the source
   */
  getOverridePositionsContextualValue() {
    return this._currentPosition;
  }
  /**
   * Gets the value associated with a contextual normals
   * @returns the value associated with the source
   */
  getOverrideNormalsContextualValue() {
    this._vertex1.subtractToRef(this._vertex0, this._tempVector0);
    this._vertex2.subtractToRef(this._vertex1, this._tempVector1);
    this._tempVector0.normalize();
    this._tempVector1.normalize();
    return Vector3.Cross(this._tempVector1, this._tempVector0);
  }
  /**
   * Gets the value associated with a contextual UV1 se
   * @returns the value associated with the source
   */
  getOverrideUVs1ContextualValue() {
    return this._currentUV;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateOnFacesBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the instance input component
   */
  get instance() {
    return this._inputs[1];
  }
  /**
   * Gets the count input component
   */
  get count() {
    return this._inputs[2];
  }
  /**
   * Gets the matrix input component
   */
  get matrix() {
    return this._inputs[3];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[4];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[5];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {
        state2.restoreExecutionContext();
        state2.restoreInstancingContext();
        state2.restoreGeometryContext();
        this.output._storedValue = null;
        return;
      }
      let instanceGeometry = null;
      const instanceCount = this.count.getConnectedValue(state2);
      const faceCount = this._vertexData.indices.length / 3;
      const instancePerFace = instanceCount / faceCount;
      let accumulatedCount = 0;
      const additionalVertexData = [];
      let totalDone = 0;
      this._currentLoopIndex = 0;
      for (this._currentFaceIndex = 0; this._currentFaceIndex < faceCount; this._currentFaceIndex++) {
        accumulatedCount += instancePerFace;
        const countPerFace = (accumulatedCount | 0) - totalDone;
        if (countPerFace < 1) {
          continue;
        }
        const faceID0 = this._vertexData.indices[this._currentFaceIndex * 3];
        const faceID1 = this._vertexData.indices[this._currentFaceIndex * 3 + 1];
        const faceID2 = this._vertexData.indices[this._currentFaceIndex * 3 + 2];
        this._vertex0.fromArray(this._vertexData.positions, faceID0 * 3);
        this._vertex1.fromArray(this._vertexData.positions, faceID1 * 3);
        this._vertex2.fromArray(this._vertexData.positions, faceID2 * 3);
        if (this._vertexData.uvs) {
          this._uv0.fromArray(this._vertexData.uvs, faceID0 * 2);
          this._uv1.fromArray(this._vertexData.uvs, faceID1 * 2);
          this._uv2.fromArray(this._vertexData.uvs, faceID2 * 2);
        }
        for (let faceDispatchCount = 0; faceDispatchCount < countPerFace; faceDispatchCount++) {
          if (totalDone >= instanceCount) {
            break;
          }
          let x = Math.random();
          let y = Math.random();
          if (x > y) {
            const temp = x;
            x = y;
            y = temp;
          }
          const s = x;
          const t = y - x;
          const u = 1 - s - t;
          this._currentPosition.set(s * this._vertex0.x + t * this._vertex1.x + u * this._vertex2.x, s * this._vertex0.y + t * this._vertex1.y + u * this._vertex2.y, s * this._vertex0.z + t * this._vertex1.z + u * this._vertex2.z);
          if (this._vertexData.uvs) {
            this._currentUV.set(s * this._uv0.x + t * this._uv1.x + u * this._uv2.x, s * this._uv0.y + t * this._uv1.y + u * this._uv2.y);
          }
          instanceGeometry = this.instance.getConnectedValue(state2);
          if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
            accumulatedCount -= instancePerFace;
            continue;
          }
          const clone = instanceGeometry.clone();
          if (this.matrix.isConnected) {
            const transform = this.matrix.getConnectedValue(state2);
            state2._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);
          } else {
            const scaling = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
            const rotation = this.rotation.getConnectedValue(state2) || Vector3.ZeroReadOnly;
            state2._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);
          }
          totalDone++;
          this._currentLoopIndex++;
        }
      }
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      }
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      state2.restoreGeometryContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], InstantiateOnFacesBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.InstantiateOnFacesBlock", InstantiateOnFacesBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateOnVolumeBlock.js
var InstantiateOnVolumeBlock = class extends NodeGeometryBlock {
  /**
   * Create a new InstantiateOnVolumeBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._currentPosition = new Vector3();
    this._vertex0 = new Vector3();
    this._vertex1 = new Vector3();
    this._vertex2 = new Vector3();
    this.evaluateContext = true;
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("instance", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("count", NodeGeometryBlockConnectionPointTypes.Int, true, 256);
    this.registerInput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix, true);
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current instance index in the current flow
   * @returns the current index
   */
  getInstanceIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return 0;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentLoopIndex;
  }
  /**
   * Gets the value associated with a contextual positions
   * @returns the value associated with the source
   */
  getOverridePositionsContextualValue() {
    return this._currentPosition;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateOnVolumeBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the instance input component
   */
  get instance() {
    return this._inputs[1];
  }
  /**
   * Gets the count input component
   */
  get count() {
    return this._inputs[2];
  }
  /**
   * Gets the matrix input component
   */
  get matrix() {
    return this._inputs[3];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[4];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[5];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      this._vertexData = this.geometry.getConnectedValue(state2);
      state2.pushGeometryContext(this._vertexData);
      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {
        state2.restoreExecutionContext();
        state2.restoreInstancingContext();
        state2.restoreGeometryContext();
        this.output._storedValue = null;
        return;
      }
      let instanceGeometry = null;
      const instanceCount = this.count.getConnectedValue(state2);
      const additionalVertexData = [];
      const boundingInfo = extractMinAndMax(this._vertexData.positions, 0, this._vertexData.positions.length / 3);
      const min = boundingInfo.minimum;
      const max = boundingInfo.maximum;
      const direction = new Vector3(1, 0, 0);
      const faceCount = this._vertexData.indices.length / 3;
      this._currentLoopIndex = 0;
      for (let index = 0; index < instanceCount; index++) {
        this._currentPosition.set(Math.random() * (max.x - min.x) + min.x, Math.random() * (max.y - min.y) + min.y, Math.random() * (max.z - min.z) + min.z);
        const ray = new Ray(this._currentPosition, direction);
        let intersectionCount = 0;
        for (let currentFaceIndex = 0; currentFaceIndex < faceCount; currentFaceIndex++) {
          this._vertex0.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3] * 3);
          this._vertex1.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 1] * 3);
          this._vertex2.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 2] * 3);
          const currentIntersectInfo = ray.intersectsTriangle(this._vertex0, this._vertex1, this._vertex2);
          if (currentIntersectInfo && currentIntersectInfo.distance > 0) {
            intersectionCount++;
          }
        }
        if (intersectionCount % 2 === 0) {
          index--;
          continue;
        }
        instanceGeometry = this.instance.getConnectedValue(state2);
        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
          continue;
        }
        const clone = instanceGeometry.clone();
        if (this.matrix.isConnected) {
          const transform = this.matrix.getConnectedValue(state2);
          state2._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);
        } else {
          const scaling = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
          const rotation = this.rotation.getConnectedValue(state2) || Vector3.ZeroReadOnly;
          state2._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);
        }
        this._currentLoopIndex++;
      }
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      }
      state2.restoreGeometryContext();
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], InstantiateOnVolumeBlock.prototype, "evaluateContext", void 0);
RegisterClass("BABYLON.InstantiateOnVolumeBlock", InstantiateOnVolumeBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateBaseBlock.js
var InstantiateBaseBlock = class extends NodeGeometryBlock {
  /**
   * Create a new InstantiateBaseBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = true;
    this.registerInput("instance", NodeGeometryBlockConnectionPointTypes.Geometry, true);
    this.registerInput("count", NodeGeometryBlockConnectionPointTypes.Int, true, 1);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current instance index in the current flow
   * @returns the current index
   */
  getInstanceIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateBaseBlock";
  }
  /**
   * Gets the instance input component
   */
  get instance() {
    return this._inputs[0];
  }
  /**
   * Gets the count input component
   */
  get count() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    if (serializationObject.evaluateContext !== void 0) {
      this.evaluateContext = serializationObject.evaluateContext;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], InstantiateBaseBlock.prototype, "evaluateContext", void 0);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateBlock.js
var InstantiateBlock = class extends InstantiateBaseBlock {
  /**
   * Create a new InstantiateBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("matrix", NodeGeometryBlockConnectionPointTypes.Matrix, true);
    this.registerInput("position", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current instance index in the current flow
   * @returns the current index
   */
  getInstanceIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current index in the current flow
   * @returns the current index
   */
  getExecutionIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current loop index in the current flow
   * @returns the current loop index
   */
  getExecutionLoopIndex() {
    return this._currentIndex;
  }
  /**
   * Gets the current face index in the current flow
   * @returns the current face index
   */
  getExecutionFaceIndex() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateBlock";
  }
  /**
   * Gets the matrix input component
   */
  get matrix() {
    return this._inputs[2];
  }
  /**
   * Gets the position input component
   */
  get position() {
    return this._inputs[3];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[4];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[5];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      const iterationCount = this.count.getConnectedValue(state2);
      const additionalVertexData = [];
      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {
        const instanceGeometry = this.instance.getConnectedValue(state2);
        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
          continue;
        }
        const clone = instanceGeometry.clone();
        if (this.matrix.isConnected) {
          const transform = this.matrix.getConnectedValue(state2);
          state2._instantiateWithMatrix(clone, transform, additionalVertexData);
        } else {
          const position = this.position.getConnectedValue(state2) || Vector3.ZeroReadOnly;
          const scaling = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
          const rotation = this.rotation.getConnectedValue(state2) || Vector3.ZeroReadOnly;
          state2._instantiate(clone, position, rotation, scaling, additionalVertexData);
        }
      }
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      }
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
};
RegisterClass("BABYLON.InstantiateBlock", InstantiateBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateLinearBlock.js
var InstantiateLinearBlock = class extends InstantiateBaseBlock {
  /**
   * Create a new Instantiate Linear Block
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("direction", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(1, 0, 0));
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateLinearBlock";
  }
  /**
   * Gets the direction input component
   */
  get direction() {
    return this._inputs[2];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[3];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[4];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      const iterationCount = this.count.getConnectedValue(state2);
      const additionalVertexData = [];
      const transformMatrix = Matrix.Identity();
      const transformOffset = Vector3.Zero();
      const rotationOffset = Vector3.Zero();
      const scaleOffset = Vector3.Zero();
      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {
        const instanceGeometry = this.instance.getConnectedValue(state2);
        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
          continue;
        }
        const clone = instanceGeometry.clone();
        const direction = this.direction.getConnectedValue(state2);
        const rotation = this.rotation.getConnectedValue(state2);
        const scale = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
        transformOffset.copyFrom(direction.clone().scale(this._currentIndex));
        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));
        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));
        scaleOffset.addInPlaceFromFloats(1, 1, 1);
        Matrix.ComposeToRef(scaleOffset, Quaternion.FromEulerAngles(rotationOffset.x, rotationOffset.y, rotationOffset.z), transformOffset, transformMatrix);
        state2._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);
      }
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      }
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
};
RegisterClass("BABYLON.InstantiateLinearBlock", InstantiateLinearBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Instances/instantiateRadialBlock.js
var InstantiateRadialBlock = class extends InstantiateBaseBlock {
  /**
   * Create a new InstantiateRadialBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("radius", NodeGeometryBlockConnectionPointTypes.Int, true, 0, 0);
    this.registerInput("angleStart", NodeGeometryBlockConnectionPointTypes.Float, true, 0);
    this.registerInput("angleEnd", NodeGeometryBlockConnectionPointTypes.Float, true, Math.PI * 2);
    this.registerInput("transform", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));
    this.registerInput("rotation", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));
    this.registerInput("scaling", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));
    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstantiateRadialBlock";
  }
  /**
   * Gets the direction input component
   */
  get radius() {
    return this._inputs[2];
  }
  /**
   * Gets the direction input component
   */
  get angleStart() {
    return this._inputs[3];
  }
  /**
   * Gets the direction input component
   */
  get angleEnd() {
    return this._inputs[4];
  }
  /**
   * Gets the transform input component
   */
  get transform() {
    return this._inputs[5];
  }
  /**
   * Gets the rotation input component
   */
  get rotation() {
    return this._inputs[6];
  }
  /**
   * Gets the scaling input component
   */
  get scaling() {
    return this._inputs[7];
  }
  _buildBlock(state) {
    const func = (state2) => {
      state2.pushExecutionContext(this);
      state2.pushInstancingContext(this);
      const iterationCount = this.count.getConnectedValue(state2);
      const additionalVertexData = [];
      const rotMatrix = Matrix.Identity();
      const radiusMatrix = Matrix.Identity();
      const transformMatrix = Matrix.Identity();
      const transformOffset = Vector3.Zero();
      const rotationOffset = Vector3.Zero();
      const scaleOffset = Vector3.Zero();
      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {
        const instanceGeometry = this.instance.getConnectedValue(state2);
        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {
          continue;
        }
        const clone = instanceGeometry.clone();
        const radius = this.radius.getConnectedValue(state2);
        const angleStart = this.angleStart.getConnectedValue(state2);
        const angleEnd = this.angleEnd.getConnectedValue(state2);
        const transform = this.transform.getConnectedValue(state2);
        const rotation = this.rotation.getConnectedValue(state2);
        const scale = state2.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);
        const pieSlice = angleEnd - angleStart;
        const rStep = pieSlice / iterationCount;
        const angle = angleStart + rStep * this._currentIndex;
        const angleQuat = Quaternion.FromEulerAngles(0, angle, 0);
        transformOffset.copyFrom(transform.clone().scale(this._currentIndex));
        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));
        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));
        scaleOffset.addInPlaceFromFloats(1, 1, 1);
        Matrix.RotationYawPitchRollToRef(rotationOffset.y, rotationOffset.x, rotationOffset.z, rotMatrix);
        radiusMatrix.setTranslationFromFloats(0, 0, radius);
        Matrix.ComposeToRef(scaleOffset, angleQuat, transformOffset, transformMatrix);
        rotMatrix.multiplyToRef(radiusMatrix, radiusMatrix);
        radiusMatrix.multiplyToRef(transformMatrix, transformMatrix);
        state2._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);
      }
      if (additionalVertexData.length) {
        if (additionalVertexData.length === 1) {
          this._vertexData = additionalVertexData[0];
        } else {
          const main = additionalVertexData.splice(0, 1)[0];
          this._vertexData = main.merge(additionalVertexData, true, false, true, true);
        }
      }
      state2.restoreExecutionContext();
      state2.restoreInstancingContext();
      return this._vertexData;
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
};
RegisterClass("BABYLON.InstantiateRadialBlock", InstantiateRadialBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/intFloatConverterBlock.js
var IntFloatConverterBlock = class extends NodeGeometryBlock {
  /**
   * Create a new IntFloatConverterBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("float ", NodeGeometryBlockConnectionPointTypes.Float, true);
    this.registerInput("int ", NodeGeometryBlockConnectionPointTypes.Int, true);
    this.registerOutput("float", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("int", NodeGeometryBlockConnectionPointTypes.Int);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "IntFloatConverterBlock";
  }
  /**
   * Gets the float input component
   */
  get floatIn() {
    return this._inputs[0];
  }
  /**
   * Gets the int input component
   */
  get intIn() {
    return this._inputs[1];
  }
  /**
   * Gets the float output component
   */
  get floatOut() {
    return this._outputs[0];
  }
  /**
   * Gets the int output component
   */
  get intOut() {
    return this._outputs[1];
  }
  _inputRename(name52) {
    if (name52 === "float ") {
      return "floatIn";
    }
    if (name52 === "int ") {
      return "intIn";
    }
    return name52;
  }
  _buildBlock() {
    this.floatOut._storedFunction = (state) => {
      if (this.floatIn.isConnected) {
        return this.floatIn.getConnectedValue(state);
      }
      if (this.intIn.isConnected) {
        return this.intIn.getConnectedValue(state);
      }
      return 0;
    };
    this.intOut._storedFunction = (state) => {
      if (this.floatIn.isConnected) {
        return Math.floor(this.floatIn.getConnectedValue(state));
      }
      if (this.intIn.isConnected) {
        return Math.floor(this.intIn.getConnectedValue(state));
      }
      return 0;
    };
  }
};
RegisterClass("BABYLON.IntFloatConverterBlock", IntFloatConverterBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/debugBlock.js
var DebugBlock = class extends NodeGeometryBlock {
  /**
   * Create a new DebugBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.log = [];
    this._isDebug = true;
    this.registerInput("input", NodeGeometryBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);
    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);
  }
  /**
   * Gets the time spent to build this block (in ms)
   */
  get buildExecutionTime() {
    return 0;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DebugBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    if (!this.input.isConnected) {
      this.output._storedFunction = null;
      this.output._storedValue = null;
      return;
    }
    this.log = [];
    const func = (state2) => {
      const input = this.input.getConnectedValue(state2);
      if (input === null || input === void 0) {
        this.log.push("null");
        return input;
      }
      this.log.push(input.toString());
      return input;
    };
    if (this.output.isConnected) {
      this.output._storedFunction = func;
    } else {
      this.output._storedValue = func(state);
    }
  }
};
RegisterClass("BABYLON.DebugBlock", DebugBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/geometryInfoBlock.js
var GeometryInfoBlock = class extends NodeGeometryBlock {
  /**
   * Create a new GeometryInfoBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("id", NodeGeometryBlockConnectionPointTypes.Int);
    this.registerOutput("collectionId", NodeGeometryBlockConnectionPointTypes.Int);
    this.registerOutput("verticesCount", NodeGeometryBlockConnectionPointTypes.Int);
    this.registerOutput("facesCount", NodeGeometryBlockConnectionPointTypes.Int);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryInfoBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the id output component
   */
  get id() {
    return this._outputs[1];
  }
  /**
   * Gets the collectionId output component
   */
  get collectionId() {
    return this._outputs[2];
  }
  /**
   * Gets the verticesCount output component
   */
  get verticesCount() {
    return this._outputs[3];
  }
  /**
   * Gets the facesCount output component
   */
  get facesCount() {
    return this._outputs[4];
  }
  _buildBlock() {
    if (!this.geometry.isConnected) {
      this.id._storedValue = 0;
      this.collectionId._storedValue = 0;
      this.verticesCount._storedValue = 0;
      this.facesCount._storedValue = 0;
      this.output._storedValue = 0;
      this.id._storedFunction = null;
      this.collectionId._storedFunction = null;
      this.verticesCount._storedFunction = null;
      this.facesCount._storedFunction = null;
      this.output._storedFunction = null;
      return;
    }
    this.output._storedFunction = (state) => {
      this._currentVertexData = this.geometry.getConnectedValue(state);
      return this._currentVertexData;
    };
    this.id._storedFunction = (state) => {
      this._currentVertexData = this._currentVertexData || this.geometry.getConnectedValue(state);
      return this._currentVertexData.uniqueId;
    };
    this.collectionId._storedFunction = (state) => {
      this._currentVertexData = this._currentVertexData || this.geometry.getConnectedValue(state);
      return this._currentVertexData.metadata ? this._currentVertexData.metadata.collectionId : 0;
    };
    this.verticesCount._storedFunction = (state) => {
      this._currentVertexData = this._currentVertexData || this.geometry.getConnectedValue(state);
      return this._currentVertexData.positions ? this._currentVertexData.positions.length / 3 : 0;
    };
    this.facesCount._storedFunction = (state) => {
      this._currentVertexData = this._currentVertexData || this.geometry.getConnectedValue(state);
      return this._currentVertexData.indices ? this._currentVertexData.indices.length / 3 : 0;
    };
  }
};
RegisterClass("BABYLON.GeometryInfoBlock", GeometryInfoBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/mappingBlock.js
var MappingTypes;
(function(MappingTypes2) {
  MappingTypes2[MappingTypes2["Spherical"] = 0] = "Spherical";
  MappingTypes2[MappingTypes2["Cylindrical"] = 1] = "Cylindrical";
  MappingTypes2[MappingTypes2["Cubic"] = 2] = "Cubic";
})(MappingTypes || (MappingTypes = {}));
var MappingBlock = class extends NodeGeometryBlock {
  /**
   * Create a new MappingBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.mapping = MappingTypes.Spherical;
    this.registerInput("position", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerInput("normal", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerInput("center", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
    this.registerOutput("uv", NodeGeometryBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MappingBlock";
  }
  /**
   * Gets the position input component
   */
  get position() {
    return this._inputs[0];
  }
  /**
   * Gets the normal input component
   */
  get normal() {
    return this._inputs[1];
  }
  /**
   * Gets the center input component
   */
  get center() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get uv() {
    return this._outputs[0];
  }
  _buildBlock() {
    if (!this.position.isConnected) {
      this.uv._storedFunction = null;
      this.uv._storedValue = null;
      return;
    }
    const tempDirection = Vector3.Zero();
    const func = (state) => {
      const position = this.position.getConnectedValue(state) || Vector3.Zero();
      const normal = this.normal.getConnectedValue(state) || Vector3.Zero();
      const center = this.center.getConnectedValue(state);
      const uv = Vector2.Zero();
      switch (this.mapping) {
        case MappingTypes.Spherical: {
          position.subtractToRef(center, tempDirection);
          const len = tempDirection.length();
          if (len > 0) {
            uv.x = Math.acos(tempDirection.y / len) / Math.PI;
            if (tempDirection.x !== 0 || tempDirection.z !== 0) {
              uv.y = Math.atan2(tempDirection.x, tempDirection.z) / (Math.PI * 2);
            }
          }
          break;
        }
        case MappingTypes.Cylindrical: {
          position.subtractToRef(center, tempDirection);
          const len = tempDirection.length();
          if (len > 0) {
            uv.x = Math.atan2(tempDirection.x / len, tempDirection.z / len) / (Math.PI * 2);
            uv.y = (tempDirection.y + 1) / 2;
          }
          break;
        }
        case MappingTypes.Cubic: {
          const absX = Math.abs(normal.x);
          const absY = Math.abs(normal.y);
          const absZ = Math.abs(normal.z);
          const maxDim = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));
          let u = 0, v = 0;
          if (absX >= absY && absX >= absZ) {
            u = position.y / maxDim - center.y;
            v = position.z / maxDim - center.z;
          } else if (absY >= absX && absY >= absZ) {
            u = position.x / maxDim - center.x;
            v = position.z / maxDim - center.z;
          } else {
            u = position.x / maxDim - center.x;
            v = position.y / maxDim - center.y;
          }
          uv.x = (u + 1) / 2;
          uv.y = (v + 1) / 2;
        }
      }
      return uv;
    };
    this.uv._storedFunction = (state) => {
      return func(state);
    };
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.mapping = BABYLON.MappingTypes.${MappingTypes[this.mapping]};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.mapping = this.mapping;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.mapping = serializationObject.mapping;
  }
};
__decorate([
  editableInPropertyPage("Mapping", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "Spherical", value: MappingTypes.Spherical },
      { label: "Cylindrical", value: MappingTypes.Cylindrical },
      { label: "Cubic", value: MappingTypes.Cubic }
    ]
  })
], MappingBlock.prototype, "mapping", void 0);
RegisterClass("BABYLON.MappingBlock", MappingBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/matrixComposeBlock.js
var MatrixComposeBlock = class extends NodeGeometryBlock {
  /**
   * Create a new MatrixComposeBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("matrix0", NodeGeometryBlockConnectionPointTypes.Matrix);
    this.registerInput("matrix1", NodeGeometryBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MatrixComposeBlock";
  }
  /**
   * Gets the matrix0 input component
   */
  get matrix0() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix1 input component
   */
  get matrix1() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock() {
    this.output._storedFunction = (state) => {
      if (!this.matrix0.isConnected || !this.matrix1.isConnected) {
        return null;
      }
      const matrix0 = this.matrix0.getConnectedValue(state);
      const matrix1 = this.matrix1.getConnectedValue(state);
      if (!matrix0 || !matrix1) {
        return null;
      }
      return matrix0.multiply(matrix1);
    };
  }
};
RegisterClass("BABYLON.MatrixComposeBlock", MatrixComposeBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Teleport/teleportInBlock.js
var TeleportInBlock = class extends NodeGeometryBlock {
  /** Gets the list of attached endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /**
   * Create a new TeleportInBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._endpoints = [];
    this._isTeleportIn = true;
    this.registerInput("input", NodeGeometryBlockConnectionPointTypes.AutoDetect);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TeleportInBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  _dumpCode(uniqueNames, alreadyDumped) {
    let codeString = super._dumpCode(uniqueNames, alreadyDumped);
    for (const endpoint of this.endpoints) {
      if (alreadyDumped.indexOf(endpoint) === -1) {
        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    return codeString;
  }
  /**
   * Checks if the current block is an ancestor of a given type
   * @param type defines the potential type to check
   * @returns true if block is a descendant
   */
  isAnAncestorOfType(type) {
    if (this.getClassName() === type) {
      return true;
    }
    for (const endpoint of this.endpoints) {
      if (endpoint.isAnAncestorOfType(type)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const endpoint of this.endpoints) {
      if (endpoint === block) {
        return true;
      }
      if (endpoint.isAnAncestorOf(block)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the first descendant using a predicate
   * @param predicate defines the predicate to check
   * @returns descendant or null if none found
   */
  getDescendantOfPredicate(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const endpoint of this.endpoints) {
      const descendant = endpoint.getDescendantOfPredicate(predicate);
      if (descendant) {
        return descendant;
      }
    }
    return null;
  }
  /**
   * Add an enpoint to this block
   * @param endpoint define the endpoint to attach to
   */
  attachToEndpoint(endpoint) {
    endpoint.detach();
    this._endpoints.push(endpoint);
    endpoint._entryPoint = this;
    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];
    endpoint._tempEntryPointUniqueId = null;
    endpoint.name = "> " + this.name;
  }
  /**
   * Remove enpoint from this block
   * @param endpoint define the endpoint to remove
   */
  detachFromEndpoint(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index !== -1) {
      this._endpoints.splice(index, 1);
      endpoint._outputs[0]._typeConnectionSource = null;
      endpoint._entryPoint = null;
    }
  }
  _buildBlock() {
    for (const endpoint of this._endpoints) {
      endpoint.output._storedFunction = (state) => {
        return this.input.getConnectedValue(state);
      };
    }
  }
};
RegisterClass("BABYLON.TeleportInBlock", TeleportInBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Teleport/teleportOutBlock.js
var TeleportOutBlock = class extends NodeGeometryBlock {
  /**
   * Create a new TeleportOutBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._entryPoint = null;
    this._tempEntryPointUniqueId = null;
    this._isTeleportOut = true;
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.BasedOnInput);
  }
  /**
   * Gets the entry point
   */
  get entryPoint() {
    return this._entryPoint;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TeleportOutBlock";
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /** Detach from entry point */
  detach() {
    if (!this._entryPoint) {
      return;
    }
    this._entryPoint.detachFromEndpoint(this);
  }
  _buildBlock() {
  }
  _customBuildStep(state) {
    if (this.entryPoint) {
      this.entryPoint.build(state);
    }
  }
  _dumpCode(uniqueNames, alreadyDumped) {
    let codeString = "";
    if (this.entryPoint) {
      if (alreadyDumped.indexOf(this.entryPoint) === -1) {
        codeString += this.entryPoint._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    return codeString + super._dumpCode(uniqueNames, alreadyDumped);
  }
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = super._dumpCodeForOutputConnections(alreadyDumped);
    if (this.entryPoint) {
      codeString += this.entryPoint._dumpCodeForOutputConnections(alreadyDumped);
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @returns a copy of the current block
   */
  clone() {
    const clone = super.clone();
    if (this.entryPoint) {
      this.entryPoint.attachToEndpoint(clone);
    }
    return clone;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.entryPoint) {
      codeString += `${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});
`;
    }
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    var _a, _b;
    const serializationObject = super.serialize();
    serializationObject.entryPoint = (_b = (_a = this.entryPoint) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : "";
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this._tempEntryPointUniqueId = serializationObject.entryPoint;
  }
};
RegisterClass("BABYLON.TeleportOutBlock", TeleportOutBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Textures/geometryTextureBlock.js
var GeometryTextureBlock = class extends NodeGeometryBlock {
  /**
   * Gets the texture data
   */
  get textureData() {
    return this._data;
  }
  /**
   * Gets the texture width
   */
  get textureWidth() {
    return this._width;
  }
  /**
   * Gets the texture height
   */
  get textureHeight() {
    return this._height;
  }
  /**
   * Creates a new GeometryTextureBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this._data = null;
    this.serializedCachedData = false;
    this.registerOutput("texture", NodeGeometryBlockConnectionPointTypes.Texture);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryTextureBlock";
  }
  /**
   * Gets the texture component
   */
  get texture() {
    return this._outputs[0];
  }
  _prepareImgToLoadAsync(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const pixels = imageData.data;
        const floatArray = new Float32Array(pixels.length);
        for (let i = 0; i < pixels.length; i++) {
          floatArray[i] = pixels[i] / 255;
        }
        this._data = floatArray;
        this._width = img.width;
        this._height = img.height;
        resolve();
      };
      img.onerror = () => {
        this._data = null;
        reject();
      };
      img.src = url;
    });
  }
  /**
   * Remove stored data
   */
  cleanData() {
    this._data = null;
  }
  /**
   * Load the texture data
   * @param imageFile defines the file to load data from
   * @returns a promise fulfilled when image data is loaded
   */
  loadTextureFromFileAsync(imageFile) {
    return this._prepareImgToLoadAsync(URL.createObjectURL(imageFile));
  }
  /**
   * Load the texture data
   * @param url defines the url to load data from
   * @returns a promise fulfilled when image data is loaded
   */
  loadTextureFromUrlAsync(url) {
    return this._prepareImgToLoadAsync(url);
  }
  /**
   * Load the texture data
   * @param url defines the url to load data from
   * @returns a promise fulfilled when image data is loaded
   */
  extractFromTextureAsync(texture) {
    return new Promise((resolve, reject) => {
      if (!texture.isReady()) {
        texture.onLoadObservable.addOnce(() => {
          return this.extractFromTextureAsync(texture).then(resolve).catch(reject);
        });
        return;
      }
      const size = texture.getSize();
      TextureTools.GetTextureDataAsync(texture, size.width, size.height).then(async (data) => {
        const floatArray = new Float32Array(data.length);
        for (let i = 0; i < data.length; i++) {
          floatArray[i] = data[i] / 255;
        }
        this._data = floatArray;
        this._width = size.width;
        this._height = size.height;
        resolve();
      }).catch(reject);
    });
  }
  _buildBlock() {
    if (!this._data) {
      this.texture._storedValue = null;
      return;
    }
    const textureData = {
      data: this._data,
      width: this._width,
      height: this._height
    };
    this.texture._storedValue = textureData;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.width = this._width;
    serializationObject.height = this._height;
    serializationObject.serializedCachedData = this.serializedCachedData;
    if (this._data && this.serializedCachedData) {
      serializationObject.data = Array.from(this._data);
    }
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this._width = serializationObject.width;
    this._height = serializationObject.height;
    if (serializationObject.data) {
      this._data = new Float32Array(serializationObject.data);
      this.serializedCachedData = true;
    } else {
      this.serializedCachedData = !!serializationObject.serializedCachedData;
    }
  }
};
__decorate([
  editableInPropertyPage("Serialize cached data", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryTextureBlock.prototype, "serializedCachedData", void 0);
RegisterClass("BABYLON.GeometryTextureBlock", GeometryTextureBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/Textures/geometryTextureFetchBlock.js
var GeometryTextureFetchBlock = class extends NodeGeometryBlock {
  /**
   * Creates a new GeometryTextureFetchBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.clampCoordinates = true;
    this.registerInput("texture", NodeGeometryBlockConnectionPointTypes.Texture);
    this.registerInput("coordinates", NodeGeometryBlockConnectionPointTypes.Vector2);
    this.registerOutput("rgba", NodeGeometryBlockConnectionPointTypes.Vector4);
    this.registerOutput("rgb", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerOutput("r", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("g", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("b", NodeGeometryBlockConnectionPointTypes.Float);
    this.registerOutput("a", NodeGeometryBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GeometryTextureFetchBlock";
  }
  /**
   * Gets the texture component
   */
  get texture() {
    return this.inputs[0];
  }
  /**
   * Gets the coordinates component
   */
  get coordinates() {
    return this.inputs[1];
  }
  /**
   * Gets the rgba component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a component
   */
  get a() {
    return this._outputs[5];
  }
  _repeatClamp(num) {
    if (num >= 0) {
      return num % 1;
    } else {
      return 1 - Math.abs(num) % 1;
    }
  }
  _buildBlock() {
    const func = (state) => {
      const textureData = this.texture.getConnectedValue(state);
      if (!textureData || !textureData.data) {
        return null;
      }
      const uv = this.coordinates.getConnectedValue(state);
      if (!uv) {
        return null;
      }
      const u = this.clampCoordinates ? Math.max(0, Math.min(uv.x, 1)) : this._repeatClamp(uv.x);
      const v = this.clampCoordinates ? Math.max(0, Math.min(uv.y, 1)) : this._repeatClamp(uv.y);
      const x = Math.floor(u * (textureData.width - 1));
      const y = Math.floor(v * (textureData.height - 1));
      const index = x + textureData.width * y;
      return Vector4.FromArray(textureData.data, index * 4);
    };
    this.rgba._storedFunction = (state) => {
      return func(state);
    };
    this.rgb._storedFunction = (state) => {
      const color = func(state);
      return color ? color.toVector3() : null;
    };
    this.r._storedFunction = (state) => {
      const color = func(state);
      return color ? color.x : null;
    };
    this.g._storedFunction = (state) => {
      const color = func(state);
      return color ? color.y : null;
    };
    this.b._storedFunction = (state) => {
      const color = func(state);
      return color ? color.z : null;
    };
    this.a._storedFunction = (state) => {
      const color = func(state);
      return color ? color.w : null;
    };
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.clampCoordinates = ${this.clampCoordinates};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.clampCoordinates = this.clampCoordinates;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.clampCoordinates = serializationObject.clampCoordinates;
  }
};
__decorate([
  editableInPropertyPage("Clamp Coordinates", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], GeometryTextureFetchBlock.prototype, "clampCoordinates", void 0);
RegisterClass("BABYLON.GeometryTextureFetchBlock", GeometryTextureFetchBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/boundingBlock.js
var BoundingBlock = class extends NodeGeometryBlock {
  /**
   * Create a new BoundingBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.registerInput("geometry", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("min", NodeGeometryBlockConnectionPointTypes.Vector3);
    this.registerOutput("max", NodeGeometryBlockConnectionPointTypes.Vector3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "BoundingBlock";
  }
  /**
   * Gets the geometry input component
   */
  get geometry() {
    return this._inputs[0];
  }
  /**
   * Gets the min output component
   */
  get min() {
    return this._outputs[0];
  }
  /**
   * Gets the max output component
   */
  get max() {
    return this._outputs[1];
  }
  _buildBlock() {
    this.min._storedFunction = (state) => {
      const geometry = this.geometry.getConnectedValue(state);
      if (!geometry) {
        return null;
      }
      const boundingInfo = extractMinAndMax(geometry.positions, 0, geometry.positions.length / 3);
      return boundingInfo.minimum;
    };
    this.max._storedFunction = (state) => {
      const geometry = this.geometry.getConnectedValue(state);
      if (!geometry) {
        return null;
      }
      const boundingInfo = extractMinAndMax(geometry.positions, 0, geometry.positions.length / 3);
      return boundingInfo.maximum;
    };
  }
};
RegisterClass("BABYLON.BoundingBlock", BoundingBlock);

// node_modules/@babylonjs/core/Meshes/Node/Blocks/booleanGeometryBlock.js
var BooleanGeometryOperations;
(function(BooleanGeometryOperations2) {
  BooleanGeometryOperations2[BooleanGeometryOperations2["Intersect"] = 0] = "Intersect";
  BooleanGeometryOperations2[BooleanGeometryOperations2["Subtract"] = 1] = "Subtract";
  BooleanGeometryOperations2[BooleanGeometryOperations2["Union"] = 2] = "Union";
})(BooleanGeometryOperations || (BooleanGeometryOperations = {}));
var BooleanGeometryBlock = class extends NodeGeometryBlock {
  /**
   * Create a new BooleanGeometryBlock
   * @param name defines the block name
   */
  constructor(name52) {
    super(name52);
    this.evaluateContext = false;
    this.operation = BooleanGeometryOperations.Intersect;
    this.registerInput("geometry0", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerInput("geometry1", NodeGeometryBlockConnectionPointTypes.Geometry);
    this.registerOutput("output", NodeGeometryBlockConnectionPointTypes.Geometry);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "BooleanGeometryBlock";
  }
  /**
   * Gets the geometry0 input component
   */
  get geometry0() {
    return this._inputs[0];
  }
  /**
   * Gets the geometry1 input component
   */
  get geometry1() {
    return this._inputs[1];
  }
  /**
   * Gets the geometry output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    const func = (state2) => {
      const vertexData0 = this.geometry0.getConnectedValue(state2);
      const vertexData1 = this.geometry1.getConnectedValue(state2);
      if (!vertexData0 || !vertexData1) {
        return null;
      }
      const vertexCount = vertexData0.positions.length / 3;
      if (!vertexData0.normals && vertexData1.normals) {
        vertexData0.normals = new Array(vertexData0.positions.length);
      }
      if (!vertexData1.normals && vertexData0.normals) {
        vertexData1.normals = new Array(vertexData1.positions.length);
      }
      if (!vertexData0.uvs && vertexData1.uvs) {
        vertexData0.uvs = new Array(vertexCount * 2);
      }
      if (!vertexData1.uvs && vertexData0.uvs) {
        vertexData1.uvs = new Array(vertexCount * 2);
      }
      if (!vertexData0.colors && vertexData1.colors) {
        vertexData0.colors = new Array(vertexCount * 4);
      }
      if (!vertexData1.colors && vertexData0.colors) {
        vertexData1.colors = new Array(vertexCount * 4);
      }
      const CSG0 = CSG.FromVertexData(vertexData0);
      const CSG1 = CSG.FromVertexData(vertexData1);
      let boolCSG;
      switch (this.operation) {
        case BooleanGeometryOperations.Intersect:
          boolCSG = CSG0.intersect(CSG1);
          break;
        case BooleanGeometryOperations.Subtract:
          boolCSG = CSG0.subtract(CSG1);
          break;
        case BooleanGeometryOperations.Union:
          boolCSG = CSG0.union(CSG1);
          break;
      }
      return boolCSG.toVertexData();
    };
    if (this.evaluateContext) {
      this.output._storedFunction = func;
    } else {
      this.output._storedFunction = null;
      this.output._storedValue = func(state);
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? "true" : "false"};
`;
    codeString += `${this._codeVariableName}.operation = BABYLON.BooleanGeometryOperations.${BooleanGeometryOperations[this.operation]};
`;
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.evaluateContext = this.evaluateContext;
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject) {
    super._deserialize(serializationObject);
    this.evaluateContext = serializationObject.evaluateContext;
    if (serializationObject.operation) {
      this.operation = serializationObject.operation;
    }
  }
};
__decorate([
  editableInPropertyPage("Evaluate context", PropertyTypeForEdition.Boolean, "ADVANCED", { notifiers: { rebuild: true } })
], BooleanGeometryBlock.prototype, "evaluateContext", void 0);
__decorate([
  editableInPropertyPage("Operation", PropertyTypeForEdition.List, "ADVANCED", {
    notifiers: { rebuild: true },
    options: [
      { label: "Intersect", value: BooleanGeometryOperations.Intersect },
      { label: "Subtract", value: BooleanGeometryOperations.Subtract },
      { label: "Union", value: BooleanGeometryOperations.Union }
    ]
  })
], BooleanGeometryBlock.prototype, "operation", void 0);
RegisterClass("BABYLON.BooleanGeometryBlock", BooleanGeometryBlock);

export {
  InstancedMesh,
  RawTexture,
  CreatePlaneVertexData,
  CreatePlane,
  PlaneBuilder,
  PropertyTypeForEdition,
  editableInPropertyPage,
  CreateIcoSphereVertexData,
  CreateIcoSphere,
  IcoSphereBuilder,
  CreateCylinderVertexData,
  CreateCylinder,
  CylinderBuilder,
  CreateBoxVertexData,
  CreateSegmentedBoxVertexData,
  CreateBox,
  BoxBuilder,
  CreateSphereVertexData,
  CreateSphere,
  SphereBuilder,
  CreateCapsuleVertexData,
  CreateCapsule,
  CapsuleBuilder,
  CreateRibbonVertexData,
  CreateRibbon,
  RibbonBuilder,
  CreateDiscVertexData,
  CreateDisc,
  DiscBuilder,
  CreateTiledPlaneVertexData,
  CreateTiledPlane,
  TiledPlaneBuilder,
  CreateTiledBoxVertexData,
  CreateTiledBox,
  TiledBoxBuilder,
  CreateTorusKnotVertexData,
  CreateTorusKnot,
  TorusKnotBuilder,
  ShaderMaterial,
  LinesMesh,
  InstancedLinesMesh,
  CreateLineSystemVertexData,
  CreateDashedLinesVertexData,
  CreateLineSystem,
  CreateLines,
  CreateDashedLines,
  LinesBuilder,
  Polygon,
  PolygonMeshBuilder,
  CreatePolygonVertexData,
  CreatePolygon,
  ExtrudePolygon,
  PolygonBuilder,
  ExtrudeShape,
  ExtrudeShapeCustom,
  ShapeBuilder,
  CreateLathe,
  LatheBuilder,
  CreateTube,
  TubeBuilder,
  CreatePolyhedronVertexData,
  CreatePolyhedron,
  PolyhedronBuilder,
  CreateDecal,
  DecalBuilder,
  _PrimaryIsoTriangle,
  PolyhedronData,
  GeodesicData,
  CreateGeodesic,
  GoldbergMesh,
  CreateGoldbergVertexData,
  CreateGoldberg,
  CreateTextShapePaths,
  CreateText,
  MeshBuilder,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  GetTextureDataAsync,
  TextureTools,
  RGBDTextureTools,
  CubeMapToSphericalPolynomialTools,
  WebGPUDataBuffer,
  CreateHemisphere,
  HemisphereBuilder,
  GetEnvironmentBRDFTexture,
  BRDFTextureTools,
  PBRBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  PBRMaterial,
  WorkerPool,
  AutoReleaseWorkerPool,
  GreasedLineMeshMaterialType,
  GreasedLineMeshColorMode,
  GreasedLineMeshColorDistributionType,
  GreasedLineMaterialDefaults,
  GreasedLineTools,
  MaterialGreasedLineDefines,
  GreasedLinePluginMaterial,
  GreasedLineSimpleMaterial,
  DracoCompression,
  MeshoptCompression,
  CSG,
  MeshUVSpaceRenderer,
  TrailMesh,
  SimplificationSettings,
  SimplificationQueue,
  SimplificationType,
  QuadraticErrorSimplification,
  SimplicationQueueSceneComponent,
  GreasedLineRibbonPointsMode,
  GreasedLineRibbonFacesMode,
  GreasedLineRibbonAutoDirectionMode,
  GreasedLineBaseMesh,
  GreasedLineMesh,
  GreasedLineRibbonMesh,
  GreasedLineMeshColorDistribution,
  GreasedLineMeshWidthDistribution,
  CreateGreasedLineMaterial,
  CreateGreasedLine,
  CompleteGreasedLineWidthTable,
  CompleteGreasedLineColorTable,
  NodeGeometryBlockConnectionPointTypes,
  NodeGeometryConnectionPointCompatibilityStates,
  NodeGeometryConnectionPointDirection,
  NodeGeometryConnectionPoint,
  NodeGeometryBlock,
  GeometryOutputBlock,
  NodeGeometryContextualSources,
  NodeGeometryBuildState,
  GeometryInputBlock,
  BoxBlock,
  NodeGeometry,
  GeometryOptimizeBlock,
  PlaneBlock,
  MeshBlock,
  IcoSphereBlock,
  SphereBlock,
  GridBlock,
  TorusBlock,
  CylinderBlock,
  CapsuleBlock,
  DiscBlock,
  NullBlock,
  SetPositionsBlock,
  SetNormalsBlock,
  SetUVsBlock,
  SetColorsBlock,
  SetTangentsBlock,
  MathBlockOperations,
  MathBlock,
  MapRangeBlock,
  ConditionBlockTests,
  ConditionBlock,
  RandomBlockLocks,
  RandomBlock,
  NoiseBlock,
  MergeGeometryBlock,
  GeometryCollectionBlock,
  GeometryElbowBlock,
  ComputeNormalsBlock,
  VectorConverterBlock,
  NormalizeVectorBlock,
  SetMaterialIDBlock,
  GeometryTrigonometryBlockOperations,
  GeometryTrigonometryBlock,
  GeometryTransformBlock,
  RotationXBlock,
  RotationYBlock,
  RotationZBlock,
  ScalingBlock,
  AlignBlock,
  TranslationBlock,
  InstantiateOnVerticesBlock,
  InstantiateOnFacesBlock,
  InstantiateOnVolumeBlock,
  InstantiateBlock,
  InstantiateLinearBlock,
  InstantiateRadialBlock,
  IntFloatConverterBlock,
  DebugBlock,
  GeometryInfoBlock,
  MappingTypes,
  MappingBlock,
  MatrixComposeBlock,
  TeleportInBlock,
  TeleportOutBlock,
  GeometryTextureBlock,
  GeometryTextureFetchBlock,
  BoundingBlock,
  BooleanGeometryOperations,
  BooleanGeometryBlock
};
//# sourceMappingURL=chunk-EONCXOF4.js.map
