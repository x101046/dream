{
  "version": 3,
  "sources": ["../../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../../dev/core/src/Gamepads/gamepad.ts", "../../../../dev/core/src/Cameras/Inputs/arcRotateCameraGamepadInput.ts", "../../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts", "../../../../dev/core/src/Cameras/Inputs/arcRotateCameraVRDeviceOrientationInput.ts", "../../../../dev/core/src/Cameras/Inputs/flyCameraKeyboardInput.ts", "../../../../dev/core/src/Cameras/Inputs/flyCameraMouseInput.ts", "../../../../dev/core/src/Cameras/Inputs/followCameraKeyboardMoveInput.ts", "../../../../dev/core/src/Cameras/Inputs/followCameraMouseWheelInput.ts", "../../../../dev/core/src/Cameras/Inputs/followCameraPointersInput.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraDeviceOrientationInput.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts", "../../../../dev/core/src/Misc/virtualJoystick.ts", "../../../../dev/core/src/Cameras/Inputs/freeCameraVirtualJoystickInput.ts", "../../../../dev/core/src/Cameras/targetCamera.ts", "../../../../dev/core/src/Cameras/freeCamera.ts", "../../../../dev/core/src/Cameras/touchCamera.ts", "../../../../dev/core/src/Behaviors/Cameras/autoRotationBehavior.ts", "../../../../dev/core/src/Animations/easing.ts", "../../../../dev/core/src/Animations/animationKey.ts", "../../../../dev/core/src/Animations/animationRange.ts", "../../../../dev/core/src/Animations/animation.ts", "../../../../dev/core/src/Behaviors/Cameras/bouncingBehavior.ts", "../../../../dev/core/src/Behaviors/Cameras/framingBehavior.ts", "../../../../dev/core/src/Cameras/arcRotateCamera.ts", "../../../../dev/core/src/Cameras/deviceOrientationCamera.ts", "../../../../dev/core/src/Cameras/flyCameraInputsManager.ts", "../../../../dev/core/src/Cameras/flyCamera.ts", "../../../../dev/core/src/Cameras/followCameraInputsManager.ts", "../../../../dev/core/src/Cameras/followCamera.ts", "../../../../dev/core/src/Gamepads/xboxGamepad.ts", "../../../../dev/core/src/Gamepads/dualShockGamepad.ts", "../../../../dev/core/src/Gamepads/gamepadManager.ts", "../../../../dev/core/src/Gamepads/gamepadSceneComponent.ts", "../../../../dev/core/src/Cameras/universalCamera.ts", "../../../../dev/core/src/Cameras/gamepadCamera.ts", "../../../../dev/core/src/Shaders/anaglyph.fragment.ts", "../../../../dev/core/src/PostProcesses/anaglyphPostProcess.ts", "../../../../dev/core/src/Cameras/RigModes/stereoscopicAnaglyphRigMode.ts", "../../../../dev/core/src/Cameras/Stereoscopic/anaglyphArcRotateCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/anaglyphFreeCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/anaglyphGamepadCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/anaglyphUniversalCamera.ts", "../../../../dev/core/src/Shaders/stereoscopicInterlace.fragment.ts", "../../../../dev/core/src/PostProcesses/stereoscopicInterlacePostProcess.ts", "../../../../dev/core/src/Cameras/RigModes/stereoscopicRigMode.ts", "../../../../dev/core/src/Cameras/Stereoscopic/stereoscopicArcRotateCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/stereoscopicFreeCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/stereoscopicGamepadCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/stereoscopicUniversalCamera.ts", "../../../../dev/core/src/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.ts", "../../../../dev/core/src/Cameras/virtualJoysticksCamera.ts", "../../../../dev/core/src/Cameras/VR/vrCameraMetrics.ts", "../../../../dev/core/src/Shaders/vrDistortionCorrection.fragment.ts", "../../../../dev/core/src/PostProcesses/vrDistortionCorrectionPostProcess.ts", "../../../../dev/core/src/Shaders/vrMultiviewToSingleview.fragment.ts", "../../../../dev/core/src/Materials/Textures/MultiviewRenderTarget.ts", "../../../../dev/core/src/Engines/Extensions/engine.multiview.ts", "../../../../dev/core/src/PostProcesses/vrMultiviewToSingleviewPostProcess.ts", "../../../../dev/core/src/Cameras/RigModes/vrRigMode.ts", "../../../../dev/core/src/Cameras/VR/vrDeviceOrientationArcRotateCamera.ts", "../../../../dev/core/src/Cameras/VR/vrDeviceOrientationFreeCamera.ts", "../../../../dev/core/src/Cameras/VR/vrDeviceOrientationGamepadCamera.ts", "../../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../../dev/core/src/Animations/runtimeAnimation.ts", "../../../../dev/core/src/Bones/bone.ts", "../../../../dev/core/src/Animations/animatable.ts", "../../../../dev/core/src/XR/webXRLayerWrapper.ts", "../../../../dev/core/src/XR/webXRRenderTargetTextureProvider.ts", "../../../../dev/core/src/XR/webXRWebGLLayer.ts", "../../../../dev/core/src/XR/webXRManagedOutputCanvas.ts", "../../../../dev/core/src/XR/native/nativeXRRenderTarget.ts", "../../../../dev/core/src/XR/webXRSessionManager.ts", "../../../../dev/core/src/XR/webXRTypes.ts", "../../../../dev/core/src/Cameras/VR/vrExperienceHelper.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA\r\n     * @param _pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Represents a gamepad control stick position\r\n */\r\nexport class StickValues {\r\n    /**\r\n     * Initializes the gamepad x and y control stick values\r\n     * @param x The x component of the gamepad control stick value\r\n     * @param y The y component of the gamepad control stick value\r\n     */\r\n    constructor(\r\n        /**\r\n         * The x component of the control stick\r\n         */\r\n        public x: number,\r\n        /**\r\n         * The y component of the control stick\r\n         */\r\n        public y: number\r\n    ) {}\r\n}\r\n\r\n/**\r\n * An interface which manages callbacks for gamepad button changes\r\n */\r\nexport interface GamepadButtonChanges {\r\n    /**\r\n     * Called when a gamepad has been changed\r\n     */\r\n    changed: boolean;\r\n    /**\r\n     * Called when a gamepad press event has been triggered\r\n     */\r\n    pressChanged: boolean;\r\n    /**\r\n     * Called when a touch event has been triggered\r\n     */\r\n    touchChanged: boolean;\r\n    /**\r\n     * Called when a value has changed\r\n     */\r\n    valueChanged: boolean;\r\n}\r\n\r\n/**\r\n * Represents a gamepad\r\n */\r\nexport class Gamepad {\r\n    /**\r\n     * Specifies what type of gamepad this represents\r\n     */\r\n    public type: number;\r\n\r\n    private _leftStick: StickValues = { x: 0, y: 0 };\r\n    private _rightStick: StickValues = { x: 0, y: 0 };\r\n\r\n    /** @internal */\r\n    public _isConnected = true;\r\n\r\n    private _leftStickAxisX: number;\r\n    private _leftStickAxisY: number;\r\n    private _rightStickAxisX: number;\r\n    private _rightStickAxisY: number;\r\n\r\n    /**\r\n     * Triggered when the left control stick has been changed\r\n     */\r\n    private _onleftstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Triggered when the right control stick has been changed\r\n     */\r\n    private _onrightstickchanged: (values: StickValues) => void;\r\n\r\n    /**\r\n     * Represents a gamepad controller\r\n     */\r\n    public static GAMEPAD = 0;\r\n    /**\r\n     * Represents a generic controller\r\n     */\r\n    public static GENERIC = 1;\r\n    /**\r\n     * Represents an XBox controller\r\n     */\r\n    public static XBOX = 2;\r\n    /**\r\n     * Represents a pose-enabled controller\r\n     */\r\n    public static POSE_ENABLED = 3;\r\n    /**\r\n     * Represents an Dual Shock controller\r\n     */\r\n    public static DUALSHOCK = 4;\r\n\r\n    /**\r\n     * Specifies whether the left control stick should be Y-inverted\r\n     */\r\n    protected _invertLeftStickY: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the gamepad has been connected\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this._isConnected;\r\n    }\r\n\r\n    /**\r\n     * Initializes the gamepad\r\n     * @param id The id of the gamepad\r\n     * @param index The index of the gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     * @param leftStickX The x component of the left joystick\r\n     * @param leftStickY The y component of the left joystick\r\n     * @param rightStickX The x component of the right joystick\r\n     * @param rightStickY The y component of the right joystick\r\n     */\r\n    constructor(\r\n        /**\r\n         * The id of the gamepad\r\n         */\r\n        public id: string,\r\n        /**\r\n         * The index of the gamepad\r\n         */\r\n        public index: number,\r\n        /**\r\n         * The browser gamepad\r\n         */\r\n        public browserGamepad: any,\r\n        leftStickX: number = 0,\r\n        leftStickY: number = 1,\r\n        rightStickX: number = 2,\r\n        rightStickY: number = 3\r\n    ) {\r\n        this.type = Gamepad.GAMEPAD;\r\n        this._leftStickAxisX = leftStickX;\r\n        this._leftStickAxisY = leftStickY;\r\n        this._rightStickAxisX = rightStickX;\r\n        this._rightStickAxisY = rightStickY;\r\n        if (this.browserGamepad.axes.length >= 2) {\r\n            this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n        }\r\n        if (this.browserGamepad.axes.length >= 4) {\r\n            this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the left joystick has changed\r\n     * @param callback\r\n     */\r\n    public onleftstickchanged(callback: (values: StickValues) => void) {\r\n        this._onleftstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the right joystick has changed\r\n     * @param callback\r\n     */\r\n    public onrightstickchanged(callback: (values: StickValues) => void) {\r\n        this._onrightstickchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left joystick\r\n     */\r\n    public get leftStick(): StickValues {\r\n        return this._leftStick;\r\n    }\r\n    /**\r\n     * Sets the left joystick values\r\n     */\r\n    public set leftStick(newValues: StickValues) {\r\n        if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {\r\n            this._onleftstickchanged(newValues);\r\n        }\r\n        this._leftStick = newValues;\r\n    }\r\n    /**\r\n     * Gets the right joystick\r\n     */\r\n    public get rightStick(): StickValues {\r\n        return this._rightStick;\r\n    }\r\n    /**\r\n     * Sets the right joystick value\r\n     */\r\n    public set rightStick(newValues: StickValues) {\r\n        if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {\r\n            this._onrightstickchanged(newValues);\r\n        }\r\n        this._rightStick = newValues;\r\n    }\r\n\r\n    /**\r\n     * Updates the gamepad joystick positions\r\n     */\r\n\r\n    public update() {\r\n        if (this._leftStick) {\r\n            this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\r\n            if (this._invertLeftStickY) {\r\n                this.leftStick.y *= -1;\r\n            }\r\n        }\r\n        if (this._rightStick) {\r\n            this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {}\r\n}\r\n\r\n/**\r\n * Represents a generic gamepad\r\n */\r\nexport class GenericPad extends Gamepad {\r\n    private _buttons: Array<number>;\r\n    private _onbuttondown: (buttonPressed: number) => void;\r\n    private _onbuttonup: (buttonReleased: number) => void;\r\n\r\n    /**\r\n     * Observable triggered when a button has been pressed\r\n     */\r\n    public onButtonDownObservable = new Observable<number>();\r\n    /**\r\n     * Observable triggered when a button has been released\r\n     */\r\n    public onButtonUpObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Callback triggered when a button has been pressed\r\n     * @param callback Called when a button has been pressed\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: number) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n    /**\r\n     * Callback triggered when a button has been released\r\n     * @param callback Called when a button has been released\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: number) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Initializes the generic gamepad\r\n     * @param id The id of the generic gamepad\r\n     * @param index The index of the generic gamepad\r\n     * @param browserGamepad The browser gamepad\r\n     */\r\n    constructor(id: string, index: number, browserGamepad: any) {\r\n        super(id, index, browserGamepad);\r\n        this.type = Gamepad.GENERIC;\r\n        this._buttons = new Array(browserGamepad.buttons.length);\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonIndex: number): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonIndex);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonIndex);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonIndex);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonIndex);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Updates the generic gamepad\r\n     */\r\n    public update() {\r\n        super.update();\r\n        for (let index = 0; index < this._buttons.length; index++) {\r\n            this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the generic gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n/**\r\n * Manage the gamepad inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the gamepad the input is gathering event from.\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadRotationSensibility = 80;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad) {\r\n            const camera = this.camera;\r\n            const rsValues = this.gamepad.rightStick;\r\n\r\n            if (rsValues) {\r\n                if (rsValues.x != 0) {\r\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\r\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\r\n                        camera.inertialAlphaOffset += normalizedRX;\r\n                    }\r\n                }\r\n\r\n                if (rsValues.y != 0) {\r\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\r\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\r\n                        camera.inertialBetaOffset += normalizedRY;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (lsValues && lsValues.y != 0) {\r\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\r\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\r\n                    this.camera.inertialRadiusOffset -= normalizedLY;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA\r\n     * @param pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n", "import type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { ArcRotateCameraInputsManager } from \"../../Cameras/arcRotateCameraInputsManager\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n// Module augmentation to abstract orientation inputs from camera.\r\ndeclare module \"../../Cameras/arcRotateCameraInputsManager\" {\r\n    export interface ArcRotateCameraInputsManager {\r\n        /**\r\n         * Add orientation input support to the input manager.\r\n         * @returns the current input manager\r\n         */\r\n        addVRDeviceOrientation(): ArcRotateCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Add orientation input support to the input manager.\r\n * @returns the current input manager\r\n */\r\nArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function (): ArcRotateCameraInputsManager {\r\n    this.add(new ArcRotateCameraVRDeviceOrientationInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Manage the device orientation inputs (gyroscope) to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines a correction factor applied on the alpha value retrieved from the orientation events.\r\n     */\r\n    public alphaCorrection = 1;\r\n\r\n    /**\r\n     * Defines a correction factor applied on the gamma value retrieved from the orientation events.\r\n     */\r\n    public gammaCorrection = 1;\r\n\r\n    private _alpha = 0;\r\n    private _gamma = 0;\r\n    private _dirty = false;\r\n\r\n    private _deviceOrientationHandler: (evt: DeviceOrientationEvent) => void;\r\n\r\n    /**\r\n     * Instantiate a new ArcRotateCameraVRDeviceOrientationInput.\r\n     */\r\n    constructor() {\r\n        this._deviceOrientationHandler = (evt: DeviceOrientationEvent) => this._onOrientationEvent(evt);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this.camera.attachControl(noPreventDefault);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            // check iOS 13+ support\r\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof (<any>DeviceOrientationEvent).requestPermission === \"function\") {\r\n                (<any>DeviceOrientationEvent)\r\n                    .requestPermission()\r\n                    .then((response: string) => {\r\n                        if (response === \"granted\") {\r\n                            hostWindow!.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\r\n                        } else {\r\n                            Tools.Warn(\"Permission not granted.\");\r\n                        }\r\n                    })\r\n                    .catch((error: any) => {\r\n                        Tools.Error(error);\r\n                    });\r\n            } else {\r\n                hostWindow.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onOrientationEvent(evt: DeviceOrientationEvent): void {\r\n        if (evt.alpha !== null) {\r\n            this._alpha = (+evt.alpha | 0) * this.alphaCorrection;\r\n        }\r\n\r\n        if (evt.gamma !== null) {\r\n            this._gamma = (+evt.gamma | 0) * this.gammaCorrection;\r\n        }\r\n        this._dirty = true;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n\r\n            if (this._gamma < 0) {\r\n                this._gamma = 180 + this._gamma;\r\n            }\r\n\r\n            this.camera.alpha = (((-this._alpha / 180.0) * Math.PI) % Math.PI) * 2;\r\n            this.camera.beta = (this._gamma / 180.0) * Math.PI;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        window.removeEventListener(\"deviceorientation\", this._deviceOrientationHandler);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraVRDeviceOrientationInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"VRDeviceOrientation\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraVRDeviceOrientationInput\"] = ArcRotateCameraVRDeviceOrientationInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Listen to keyboard events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraKeyboardInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysForward = [87];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysBackward = [83];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [69];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [81];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [68];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [65];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                if (\r\n                    this.keysForward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysRight.indexOf(evt.keyCode) !== -1\r\n                ) {\r\n                    const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                    if (index === -1) {\r\n                        this._keys.push(evt.keyCode);\r\n                    }\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n            } else {\r\n                if (\r\n                    this.keysForward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysRight.indexOf(evt.keyCode) !== -1\r\n                ) {\r\n                    const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                    if (index >= 0) {\r\n                        this._keys.splice(index, 1);\r\n                    }\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraKeyboardInput\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysForward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysBackward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraKeyboardInput\"] = FlyCameraKeyboardInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Pitch control.\r\n     */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Roll control.\r\n     */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n    private _noPreventDefault: boolean | undefined;\r\n    private _element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(\r\n            (p: any) => {\r\n                this._pointerInput(p);\r\n            },\r\n            PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE\r\n        );\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.camera.rollCorrect) {\r\n                this.camera.restoreRoll(this.camera.rollCorrect);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this._previousPosition = null;\r\n            this._noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any): void {\r\n        const e = <IPointerEvent>p.event;\r\n\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        const srcElement = <HTMLElement>e.target;\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN) {\r\n            try {\r\n                srcElement?.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n                this._element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        }\r\n        // Mouse up.\r\n        else if (p.type === PointerEventTypes.POINTERUP) {\r\n            try {\r\n                srcElement?.releasePointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.activeButton = -1;\r\n\r\n            this._previousPosition = null;\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        // Mouse move.\r\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._previousPosition) {\r\n                if (engine.isPointerLock) {\r\n                    this._onMouseMove(p.event);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            const offsetX = e.clientX - this._previousPosition.x;\r\n            const offsetY = e.clientY - this._previousPosition.y;\r\n\r\n            this._rotateCamera(offsetX, offsetY);\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock) {\r\n            return;\r\n        }\r\n\r\n        const offsetX = e.movementX;\r\n        const offsetY = e.movementY;\r\n\r\n        this._rotateCamera(offsetX, offsetY);\r\n\r\n        this._previousPosition = null;\r\n\r\n        if (!this._noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    private _rotateCamera(offsetX: number, offsetY: number): void {\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n\r\n        offsetX *= handednessMultiplier;\r\n\r\n        const x = offsetX / this.angularSensibility;\r\n        const y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\r\n        let rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (\r\n            this.buttonsPitch.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (\r\n            this.buttonsYaw.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (\r\n            this.buttonsRoll.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n", "import type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of a follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraKeyboardMoveInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetIncr = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetDecr = [40];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetIncr = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetDecr = [39];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-in action (decrease radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusIncr = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-out action (increase radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusDecr = [38];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierAlt: boolean = true;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the rate of change of heightOffset.\r\n     */\r\n    @serialize()\r\n    public heightSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of rotationOffset.\r\n     */\r\n    @serialize()\r\n    public rotationSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of radius.\r\n     */\r\n    @serialize()\r\n    public radiusSensibility: number = 1;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _shiftPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n                    this._shiftPressed = evt.shiftKey;\r\n\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            this._keys.forEach((keyCode) => {\r\n                if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset += this.heightSensibility;\r\n                } else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset -= this.heightSensibility;\r\n                } else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset += this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset -= this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius += this.radiusSensibility;\r\n                } else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius -= this.radiusSensibility;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the heightOffset value.\r\n     */\r\n    private _modifierHeightOffset(): boolean {\r\n        return (\r\n            this.keysHeightOffsetModifierAlt === this._altPressed &&\r\n            this.keysHeightOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysHeightOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the rotationOffset value.\r\n     */\r\n    private _modifierRotationOffset(): boolean {\r\n        return (\r\n            this.keysRotationOffsetModifierAlt === this._altPressed &&\r\n            this.keysRotationOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysRotationOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the radius value.\r\n     */\r\n    private _modifierRadius(): boolean {\r\n        return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraKeyboardMoveInput\"] = FollowCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraMouseWheelInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera moves in\r\n     * relation to mouseWheel events.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n\r\n            const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));\r\n            if (this.wheelDeltaPercentage) {\r\n                console.assert(\r\n                    <number>(<unknown>this.axisControlRadius) + <number>(<unknown>this.axisControlHeight) + <number>(<unknown>this.axisControlRotation) <= 1,\r\n                    \"wheelDeltaPercentage only usable when mouse wheel \" +\r\n                        \"controls ONE axis. \" +\r\n                        \"Currently enabled: \" +\r\n                        \"axisControlRadius: \" +\r\n                        this.axisControlRadius +\r\n                        \", axisControlHeightOffset: \" +\r\n                        this.axisControlHeight +\r\n                        \", axisControlRotationOffset: \" +\r\n                        this.axisControlRotation\r\n                );\r\n\r\n                if (this.axisControlRadius) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;\r\n                } else if (this.axisControlHeight) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;\r\n                } else if (this.axisControlRotation) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;\r\n                }\r\n            } else {\r\n                delta = wheelDelta * this.wheelPrecision;\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.axisControlRadius) {\r\n                    this.camera.radius += delta;\r\n                } else if (this.axisControlHeight) {\r\n                    this.camera.heightOffset -= delta;\r\n                } else if (this.axisControlRotation) {\r\n                    this.camera.rotationOffset -= delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraMouseWheelInput\"] = FollowCameraMouseWheelInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the X axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 10000.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRotation: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlHeight: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Log error messages if basic misconfiguration has occurred.\r\n     */\r\n    public warningEnable: boolean = true;\r\n\r\n    public onTouch(pointA: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        this._warning();\r\n\r\n        if (this.axisXControlRotation) {\r\n            this.camera.rotationOffset += offsetX / this.angularSensibilityX;\r\n        } else if (this.axisYControlRotation) {\r\n            this.camera.rotationOffset += offsetY / this.angularSensibilityX;\r\n        }\r\n\r\n        if (this.axisXControlHeight) {\r\n            this.camera.heightOffset += offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlHeight) {\r\n            this.camera.heightOffset += offsetY / this.angularSensibilityY;\r\n        }\r\n\r\n        if (this.axisXControlRadius) {\r\n            this.camera.radius -= offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlRadius) {\r\n            this.camera.radius -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / ((this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n\r\n        if (this.pinchDeltaPercentage) {\r\n            pinchDelta *= 0.01 * this.pinchDeltaPercentage;\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\r\n            }\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\r\n            }\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta * this.camera.radius;\r\n            }\r\n        } else {\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Check for obvious misconfiguration. */\r\n    private _warningCounter: number = 0;\r\n    private _warning(): void {\r\n        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\r\n            return;\r\n        }\r\n        const warn =\r\n            \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\r\n\r\n        console.assert(\r\n            <number>(<unknown>this.axisXControlRotation) + <number>(<unknown>this.axisXControlHeight) + <number>(<unknown>this.axisXControlRadius) <= 1,\r\n            warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisYControlRotation) + <number>(<unknown>this.axisYControlHeight) + <number>(<unknown>this.axisYControlRadius) <= 1,\r\n            warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisPinchControlRotation) + <number>(<unknown>this.axisPinchControlHeight) + <number>(<unknown>this.axisPinchControlRadius) <= 1,\r\n            warn +\r\n                \"axisPinchControlRotation: \" +\r\n                this.axisPinchControlRotation +\r\n                \", axisPinchControlHeight: \" +\r\n                this.axisPinchControlHeight +\r\n                \", axisPinchControlRadius: \" +\r\n                this.axisPinchControlRadius\r\n        );\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { FreeCameraInputsManager } from \"../../Cameras/freeCameraInputsManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n// Module augmentation to abstract orientation inputs from camera.\r\ndeclare module \"../../Cameras/freeCameraInputsManager\" {\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * @internal\r\n         */\r\n        _deviceOrientationInput: Nullable<FreeCameraDeviceOrientationInput>;\r\n        /**\r\n         * Add orientation input support to the input manager.\r\n         * @param smoothFactor deviceOrientation smoothing. 0: no smoothing, 1: new data ignored, 0.9 recommended for smoothing\r\n         * @returns the current input manager\r\n         */\r\n        addDeviceOrientation(smoothFactor?: number): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Add orientation input support to the input manager.\r\n * @param smoothFactor deviceOrientation smoothing. 0: no smoothing, 1: new data ignored, 0.9 recommended for smoothing\r\n * @returns the current input manager\r\n */\r\nFreeCameraInputsManager.prototype.addDeviceOrientation = function (smoothFactor?: number): FreeCameraInputsManager {\r\n    if (!this._deviceOrientationInput) {\r\n        this._deviceOrientationInput = new FreeCameraDeviceOrientationInput();\r\n        if (smoothFactor) {\r\n            this._deviceOrientationInput.smoothFactor = smoothFactor;\r\n        }\r\n        this.add(this._deviceOrientationInput);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.\r\n * Screen rotation is taken into account.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> {\r\n    private _camera: FreeCamera;\r\n\r\n    private _screenOrientationAngle: number = 0;\r\n\r\n    private _constantTranform: Quaternion;\r\n    private _screenQuaternion: Quaternion = new Quaternion();\r\n\r\n    private _alpha: number = 0;\r\n    private _beta: number = 0;\r\n    private _gamma: number = 0;\r\n\r\n    /** alpha+beta+gamma smoothing. 0: no smoothing, 1: new data ignored, 0.9 recommended for smoothing */\r\n    public smoothFactor: number = 0;\r\n\r\n    /**\r\n     * Can be used to detect if a device orientation sensor is available on a device\r\n     * @param timeout amount of time in milliseconds to wait for a response from the sensor (default: infinite)\r\n     * @returns a promise that will resolve on orientation change\r\n     */\r\n    public static WaitForOrientationChangeAsync(timeout?: number): Promise<void> {\r\n        return new Promise((res, rej) => {\r\n            let gotValue = false;\r\n            const eventHandler = () => {\r\n                window.removeEventListener(\"deviceorientation\", eventHandler);\r\n                gotValue = true;\r\n                res();\r\n            };\r\n\r\n            // If timeout is populated reject the promise\r\n            if (timeout) {\r\n                setTimeout(() => {\r\n                    if (!gotValue) {\r\n                        window.removeEventListener(\"deviceorientation\", eventHandler);\r\n                        rej(\"WaitForOrientationChangeAsync timed out\");\r\n                    }\r\n                }, timeout);\r\n            }\r\n\r\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof (<any>DeviceOrientationEvent).requestPermission === \"function\") {\r\n                (<any>DeviceOrientationEvent)\r\n                    .requestPermission()\r\n                    .then((response: string) => {\r\n                        if (response == \"granted\") {\r\n                            window.addEventListener(\"deviceorientation\", eventHandler);\r\n                        } else {\r\n                            Tools.Warn(\"Permission not granted.\");\r\n                        }\r\n                    })\r\n                    .catch((error: any) => {\r\n                        Tools.Error(error);\r\n                    });\r\n            } else {\r\n                window.addEventListener(\"deviceorientation\", eventHandler);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onDeviceOrientationChangedObservable = new Observable<void>();\r\n    /**\r\n     * Instantiates a new input\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     */\r\n    constructor() {\r\n        this._constantTranform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));\r\n        this._orientationChanged();\r\n    }\r\n\r\n    /**\r\n     * Define the camera controlled by the input.\r\n     */\r\n    public get camera(): FreeCamera {\r\n        return this._camera;\r\n    }\r\n\r\n    public set camera(camera: FreeCamera) {\r\n        this._camera = camera;\r\n        if (this._camera != null && !this._camera.rotationQuaternion) {\r\n            this._camera.rotationQuaternion = new Quaternion();\r\n        }\r\n        if (this._camera) {\r\n            this._camera.onDisposeObservable.add(() => {\r\n                this._onDeviceOrientationChangedObservable.clear();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            const eventHandler = () => {\r\n                hostWindow!.addEventListener(\"orientationchange\", this._orientationChanged);\r\n                hostWindow!.addEventListener(\"deviceorientation\", this._deviceOrientation);\r\n                //In certain cases, the attach control is called AFTER orientation was changed,\r\n                //So this is needed.\r\n                this._orientationChanged();\r\n            };\r\n            if (typeof DeviceOrientationEvent !== \"undefined\" && typeof (<any>DeviceOrientationEvent).requestPermission === \"function\") {\r\n                (<any>DeviceOrientationEvent)\r\n                    .requestPermission()\r\n                    .then((response: string) => {\r\n                        if (response === \"granted\") {\r\n                            eventHandler();\r\n                        } else {\r\n                            Tools.Warn(\"Permission not granted.\");\r\n                        }\r\n                    })\r\n                    .catch((error: any) => {\r\n                        Tools.Error(error);\r\n                    });\r\n            } else {\r\n                eventHandler();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _orientationChanged = () => {\r\n        this._screenOrientationAngle =\r\n            <any>window.orientation !== undefined\r\n                ? +(<any>window.orientation)\r\n                : (<any>window.screen).orientation && (<any>window.screen).orientation[\"angle\"]\r\n                  ? (<any>window.screen).orientation.angle\r\n                  : 0;\r\n        this._screenOrientationAngle = -Tools.ToRadians(this._screenOrientationAngle / 2);\r\n        this._screenQuaternion.copyFromFloats(0, Math.sin(this._screenOrientationAngle), 0, Math.cos(this._screenOrientationAngle));\r\n    };\r\n\r\n    private _deviceOrientation = (evt: DeviceOrientationEvent) => {\r\n        if (this.smoothFactor) {\r\n            this._alpha = evt.alpha !== null ? Tools.SmoothAngleChange(this._alpha, evt.alpha, this.smoothFactor) : 0;\r\n            this._beta = evt.beta !== null ? Tools.SmoothAngleChange(this._beta, evt.beta, this.smoothFactor) : 0;\r\n            this._gamma = evt.gamma !== null ? Tools.SmoothAngleChange(this._gamma, evt.gamma, this.smoothFactor) : 0;\r\n        } else {\r\n            this._alpha = evt.alpha !== null ? evt.alpha : 0;\r\n            this._beta = evt.beta !== null ? evt.beta : 0;\r\n            this._gamma = evt.gamma !== null ? evt.gamma : 0;\r\n        }\r\n\r\n        if (evt.alpha !== null) {\r\n            this._onDeviceOrientationChangedObservable.notifyObservers();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        window.removeEventListener(\"orientationchange\", this._orientationChanged);\r\n        window.removeEventListener(\"deviceorientation\", this._deviceOrientation);\r\n        this._alpha = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        //if no device orientation provided, don't update the rotation.\r\n        //Only testing against alpha under the assumption thatnorientation will never be so exact when set.\r\n        if (!this._alpha) {\r\n            return;\r\n        }\r\n        Quaternion.RotationYawPitchRollToRef(Tools.ToRadians(this._alpha), Tools.ToRadians(this._beta), -Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);\r\n        this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);\r\n        this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);\r\n        //Mirror on XY Plane\r\n        this._camera.rotationQuaternion.z *= -1;\r\n        this._camera.rotationQuaternion.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraDeviceOrientationInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"deviceOrientation\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraDeviceOrientationInput\"] = FreeCameraDeviceOrientationInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Manage the gamepad inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Define the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Define the Gamepad controlling the input\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadAngularSensibility = 200;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    /**\r\n     * Defines the minimum value at which any analog stick input is ignored.\r\n     * Note: This value should only be a value between 0 and 1.\r\n     */\r\n    public deadzoneDelta = 0.1;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    // private members\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _cameraTransform: Matrix = Matrix.Identity();\r\n    private _deltaTransform: Vector3 = Vector3.Zero();\r\n    private _vector3: Vector3 = Vector3.Zero();\r\n    private _vector2: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        // check if there are already other controllers connected\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad && this.gamepad.leftStick) {\r\n            const camera = this.camera;\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (this.gamepadMoveSensibility !== 0) {\r\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\r\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\r\n            }\r\n\r\n            let rsValues = this.gamepad.rightStick;\r\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\r\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\r\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\r\n            } else {\r\n                rsValues = { x: 0, y: 0 };\r\n            }\r\n\r\n            if (!camera.rotationQuaternion) {\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\r\n            } else {\r\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\r\n            }\r\n\r\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\r\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\r\n\r\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\r\n            camera.cameraDirection.addInPlace(this._deltaTransform);\r\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\r\n            camera.cameraRotation.addInPlace(this._vector2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\r\n", "import type { Nullable } from \"../types\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { StringDictionary } from \"./stringDictionary\";\r\n\r\n// Mainly based on these 2 articles :\r\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\r\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\r\n\r\n/**\r\n * Defines the potential axis of a Joystick\r\n */\r\nexport enum JoystickAxis {\r\n    /** X axis */\r\n    X,\r\n    /** Y axis */\r\n    Y,\r\n    /** Z axis */\r\n    Z,\r\n}\r\n\r\n/**\r\n * Represents the different customization options available\r\n * for VirtualJoystick\r\n */\r\ninterface VirtualJoystickCustomizations {\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    puckSize: number;\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    containerSize: number;\r\n    /**\r\n     * Color of the joystick && puck\r\n     */\r\n    color: string;\r\n    /**\r\n     * Image URL for the joystick's puck\r\n     */\r\n    puckImage?: string;\r\n    /**\r\n     * Image URL for the joystick's container\r\n     */\r\n    containerImage?: string;\r\n    /**\r\n     * Defines the unmoving position of the joystick container\r\n     */\r\n    position?: { x: number; y: number };\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    alwaysVisible: boolean;\r\n    /**\r\n     * Defines whether or not to limit the movement of the puck to the joystick's container\r\n     */\r\n    limitToContainer: boolean;\r\n}\r\n\r\n/**\r\n * Class used to define virtual joystick (used in touch mode)\r\n */\r\nexport class VirtualJoystick {\r\n    /**\r\n     * Gets or sets a boolean indicating that left and right values must be inverted\r\n     */\r\n    public reverseLeftRight: boolean;\r\n    /**\r\n     * Gets or sets a boolean indicating that up and down values must be inverted\r\n     */\r\n    public reverseUpDown: boolean;\r\n    /**\r\n     * Gets the offset value for the position (ie. the change of the position value)\r\n     */\r\n    public deltaPosition: Vector3;\r\n    /**\r\n     * Gets a boolean indicating if the virtual joystick was pressed\r\n     */\r\n    public pressed: boolean;\r\n    /**\r\n     * Canvas the virtual joystick will render onto, default z-index of this is 5\r\n     */\r\n    public static Canvas: Nullable<HTMLCanvasElement>;\r\n\r\n    /**\r\n     * boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area\r\n     */\r\n    public limitToContainer: boolean;\r\n\r\n    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\r\n    private static _GlobalJoystickIndex: number = 0;\r\n    private static _AlwaysVisibleSticks: number = 0;\r\n    private static _VJCanvasContext: CanvasRenderingContext2D;\r\n    private static _VJCanvasWidth: number;\r\n    private static _VJCanvasHeight: number;\r\n    private static _HalfWidth: number;\r\n    private static _GetDefaultOptions(): VirtualJoystickCustomizations {\r\n        return {\r\n            puckSize: 40,\r\n            containerSize: 60,\r\n            color: \"cyan\",\r\n            puckImage: undefined,\r\n            containerImage: undefined,\r\n            position: undefined,\r\n            alwaysVisible: false,\r\n            limitToContainer: false,\r\n        };\r\n    }\r\n\r\n    private _action: () => any;\r\n    private _axisTargetedByLeftAndRight: JoystickAxis;\r\n    private _axisTargetedByUpAndDown: JoystickAxis;\r\n    private _joystickSensibility: number;\r\n    private _inversedSensibility: number;\r\n    private _joystickPointerId: number;\r\n    private _joystickColor: string;\r\n    private _joystickPointerPos: Vector2;\r\n    private _joystickPreviousPointerPos: Vector2;\r\n    private _joystickPointerStartPos: Vector2;\r\n    private _deltaJoystickVector: Vector2;\r\n    private _leftJoystick: boolean;\r\n    private _touches: StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>;\r\n    private _joystickPosition: Nullable<Vector2>;\r\n    private _alwaysVisible: boolean;\r\n    private _puckImage: HTMLImageElement;\r\n    private _containerImage: HTMLImageElement;\r\n    private _released = false;\r\n\r\n    // size properties\r\n    private _joystickPuckSize: number;\r\n    private _joystickContainerSize: number;\r\n    private _clearPuckSize: number;\r\n    private _clearContainerSize: number;\r\n    private _clearPuckSizeOffset: number;\r\n    private _clearContainerSizeOffset: number;\r\n\r\n    private _onPointerDownHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerMoveHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerUpHandlerRef: (e: PointerEvent) => any;\r\n    private _onResize: (e: any) => any;\r\n\r\n    /**\r\n     * Creates a new virtual joystick\r\n     * @param leftJoystick defines that the joystick is for left hand (false by default)\r\n     * @param customizations Defines the options we want to customize the VirtualJoystick\r\n     */\r\n    constructor(leftJoystick?: boolean, customizations?: Partial<VirtualJoystickCustomizations>) {\r\n        const options = {\r\n            ...VirtualJoystick._GetDefaultOptions(),\r\n            ...customizations,\r\n        };\r\n\r\n        if (leftJoystick) {\r\n            this._leftJoystick = true;\r\n        } else {\r\n            this._leftJoystick = false;\r\n        }\r\n\r\n        VirtualJoystick._GlobalJoystickIndex++;\r\n\r\n        // By default left & right arrow keys are moving the X\r\n        // and up & down keys are moving the Y\r\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n\r\n        this.reverseLeftRight = false;\r\n        this.reverseUpDown = false;\r\n\r\n        // collections of pointers\r\n        this._touches = new StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>();\r\n        this.deltaPosition = Vector3.Zero();\r\n\r\n        this._joystickSensibility = 25;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n\r\n        this._onResize = () => {\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            if (VirtualJoystick.Canvas) {\r\n                VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\r\n                VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\r\n            }\r\n            VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\r\n        };\r\n\r\n        // injecting a canvas element on top of the canvas 3D game\r\n        if (!VirtualJoystick.Canvas) {\r\n            window.addEventListener(\"resize\", this._onResize, false);\r\n            VirtualJoystick.Canvas = document.createElement(\"canvas\");\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            VirtualJoystick.Canvas.width = window.innerWidth;\r\n            VirtualJoystick.Canvas.height = window.innerHeight;\r\n            VirtualJoystick.Canvas.style.width = \"100%\";\r\n            VirtualJoystick.Canvas.style.height = \"100%\";\r\n            VirtualJoystick.Canvas.style.position = \"absolute\";\r\n            VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\r\n            VirtualJoystick.Canvas.style.top = \"0px\";\r\n            VirtualJoystick.Canvas.style.left = \"0px\";\r\n            VirtualJoystick.Canvas.style.zIndex = \"5\";\r\n            VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\r\n            // Support for jQuery PEP polyfill\r\n            VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\r\n            const context = VirtualJoystick.Canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to create canvas for virtual joystick\");\r\n            }\r\n\r\n            VirtualJoystick._VJCanvasContext = context;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            document.body.appendChild(VirtualJoystick.Canvas);\r\n        }\r\n        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\r\n        this.pressed = false;\r\n        this.limitToContainer = options.limitToContainer;\r\n\r\n        // default joystick color\r\n        this._joystickColor = options.color;\r\n\r\n        // default joystick size\r\n        this.containerSize = options.containerSize;\r\n        this.puckSize = options.puckSize;\r\n\r\n        if (options.position) {\r\n            this.setPosition(options.position.x, options.position.y);\r\n        }\r\n        if (options.puckImage) {\r\n            this.setPuckImage(options.puckImage);\r\n        }\r\n        if (options.containerImage) {\r\n            this.setContainerImage(options.containerImage);\r\n        }\r\n        if (options.alwaysVisible) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n        }\r\n\r\n        // must come after position potentially set\r\n        this.alwaysVisible = options.alwaysVisible;\r\n\r\n        this._joystickPointerId = -1;\r\n        // current joystick position\r\n        this._joystickPointerPos = new Vector2(0, 0);\r\n        this._joystickPreviousPointerPos = new Vector2(0, 0);\r\n        // origin joystick position\r\n        this._joystickPointerStartPos = new Vector2(0, 0);\r\n        this._deltaJoystickVector = new Vector2(0, 0);\r\n\r\n        this._onPointerDownHandlerRef = (evt) => {\r\n            this._onPointerDown(evt);\r\n        };\r\n        this._onPointerMoveHandlerRef = (evt) => {\r\n            this._onPointerMove(evt);\r\n        };\r\n        this._onPointerUpHandlerRef = (evt) => {\r\n            this._onPointerUp(evt);\r\n        };\r\n\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\r\n            \"contextmenu\",\r\n            (evt) => {\r\n                evt.preventDefault(); // Disables system menu\r\n            },\r\n            false\r\n        );\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\r\n     * @param newJoystickSensibility defines the new sensibility\r\n     */\r\n    public setJoystickSensibility(newJoystickSensibility: number) {\r\n        this._joystickSensibility = newJoystickSensibility;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n    }\r\n\r\n    private _onPointerDown(e: PointerEvent) {\r\n        let positionOnScreenCondition: boolean;\r\n\r\n        e.preventDefault();\r\n\r\n        if (this._leftJoystick === true) {\r\n            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\r\n        } else {\r\n            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\r\n        }\r\n\r\n        if (positionOnScreenCondition && this._joystickPointerId < 0) {\r\n            // First contact will be dedicated to the virtual joystick\r\n            this._joystickPointerId = e.pointerId;\r\n\r\n            if (this._joystickPosition) {\r\n                this._joystickPointerStartPos = this._joystickPosition.clone();\r\n                this._joystickPointerPos = this._joystickPosition.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPosition.clone();\r\n\r\n                // in case the user only clicks down && doesn't move:\r\n                // this ensures the delta is properly set\r\n                this._onPointerMove(e);\r\n            } else {\r\n                this._joystickPointerStartPos.x = e.clientX;\r\n                this._joystickPointerStartPos.y = e.clientY;\r\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\r\n            }\r\n\r\n            this._deltaJoystickVector.x = 0;\r\n            this._deltaJoystickVector.y = 0;\r\n            this.pressed = true;\r\n            this._touches.add(e.pointerId.toString(), e);\r\n        } else {\r\n            // You can only trigger the action buttons with a joystick declared\r\n            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\r\n                this._action();\r\n                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerMove(e: PointerEvent) {\r\n        // If the current pointer is the one associated to the joystick (first touch contact)\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            // limit to container if need be\r\n            if (this.limitToContainer) {\r\n                const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\r\n                const distance = vector.length();\r\n\r\n                if (distance > this.containerSize) {\r\n                    vector.scaleInPlace(this.containerSize / distance);\r\n                }\r\n\r\n                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\r\n                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\r\n            } else {\r\n                this._joystickPointerPos.x = e.clientX;\r\n                this._joystickPointerPos.y = e.clientY;\r\n            }\r\n\r\n            // create delta vector\r\n            this._deltaJoystickVector = this._joystickPointerPos.clone();\r\n            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\r\n\r\n            // if a joystick is always visible, there will be clipping issues if\r\n            // you drag the puck from one over the container of the other\r\n            if (0 < VirtualJoystick._AlwaysVisibleSticks) {\r\n                if (this._leftJoystick) {\r\n                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                } else {\r\n                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                }\r\n            }\r\n\r\n            const directionLeftRight = this.reverseLeftRight ? -1 : 1;\r\n            const deltaJoystickX = (directionLeftRight * this._deltaJoystickVector.x) / this._inversedSensibility;\r\n            switch (this._axisTargetedByLeftAndRight) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n            }\r\n            const directionUpDown = this.reverseUpDown ? 1 : -1;\r\n            const deltaJoystickY = (directionUpDown * this._deltaJoystickVector.y) / this._inversedSensibility;\r\n            switch (this._axisTargetedByUpAndDown) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n            }\r\n        } else {\r\n            const data = this._touches.get(e.pointerId.toString());\r\n            if (data) {\r\n                (data as any).x = e.clientX;\r\n                (data as any).y = e.clientY;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerUp(e: PointerEvent) {\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            this._clearPreviousDraw();\r\n\r\n            this._joystickPointerId = -1;\r\n            this.pressed = false;\r\n        } else {\r\n            const touch = <{ x: number; y: number; prevX: number; prevY: number }>this._touches.get(e.pointerId.toString());\r\n            if (touch) {\r\n                VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\r\n            }\r\n        }\r\n        this._deltaJoystickVector.x = 0;\r\n        this._deltaJoystickVector.y = 0;\r\n\r\n        this._touches.remove(e.pointerId.toString());\r\n    }\r\n\r\n    /**\r\n     * Change the color of the virtual joystick\r\n     * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\r\n     */\r\n    public setJoystickColor(newColor: string) {\r\n        this._joystickColor = newColor;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    public set containerSize(newSize: number) {\r\n        this._joystickContainerSize = newSize;\r\n        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\r\n        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\r\n    }\r\n    public get containerSize() {\r\n        return this._joystickContainerSize;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    public set puckSize(newSize: number) {\r\n        this._joystickPuckSize = newSize;\r\n        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\r\n        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\r\n    }\r\n    public get puckSize() {\r\n        return this._joystickPuckSize;\r\n    }\r\n\r\n    /**\r\n     * Clears the set position of the joystick\r\n     */\r\n    public clearPosition() {\r\n        this.alwaysVisible = false;\r\n\r\n        this._joystickPosition = null;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    public set alwaysVisible(value: boolean) {\r\n        if (this._alwaysVisible === value) {\r\n            return;\r\n        }\r\n\r\n        if (value && this._joystickPosition) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n\r\n            this._alwaysVisible = true;\r\n        } else {\r\n            VirtualJoystick._AlwaysVisibleSticks--;\r\n\r\n            this._alwaysVisible = false;\r\n        }\r\n    }\r\n    public get alwaysVisible() {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the constant position of the Joystick container\r\n     * @param x X axis coordinate\r\n     * @param y Y axis coordinate\r\n     */\r\n    public setPosition(x: number, y: number) {\r\n        // just in case position is moved while the container is visible\r\n        if (this._joystickPointerStartPos) {\r\n            this._clearPreviousDraw();\r\n        }\r\n\r\n        this._joystickPosition = new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Defines a callback to call when the joystick is touched\r\n     * @param action defines the callback\r\n     */\r\n    public setActionOnTouch(action: () => any) {\r\n        this._action = action;\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for left & right\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForLeftRight(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByLeftAndRight = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for up & down\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForUpDown(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByUpAndDown = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the canvas from the previous puck / container draw\r\n     */\r\n    private _clearPreviousDraw() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        // clear container pixels\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            jp.x - this._clearContainerSizeOffset,\r\n            jp.y - this._clearContainerSizeOffset,\r\n            this._clearContainerSize,\r\n            this._clearContainerSize\r\n        );\r\n\r\n        // clear puck pixels + 1 pixel for the change made before it moved\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1,\r\n            this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1,\r\n            this._clearPuckSize + 2,\r\n            this._clearPuckSize + 2\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the container's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setContainerImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._containerImage = image);\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the puck's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setPuckImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._puckImage = image);\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's container\r\n     */\r\n    private _drawContainer() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        this._clearPreviousDraw();\r\n\r\n        if (this._containerImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\r\n        } else {\r\n            // outer container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n\r\n            // inner container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's puck\r\n     */\r\n    private _drawPuck() {\r\n        if (this._puckImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(\r\n                this._puckImage,\r\n                this._joystickPointerPos.x - this.puckSize,\r\n                this._joystickPointerPos.y - this.puckSize,\r\n                this.puckSize * 2,\r\n                this.puckSize * 2\r\n            );\r\n        } else {\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    private _drawVirtualJoystick() {\r\n        // canvas released? don't continue iterating\r\n        if (this._released) {\r\n            return;\r\n        }\r\n        if (this.alwaysVisible) {\r\n            this._drawContainer();\r\n        }\r\n\r\n        if (this.pressed) {\r\n            this._touches.forEach((key, touch) => {\r\n                if ((<PointerEvent>touch).pointerId === this._joystickPointerId) {\r\n                    if (!this.alwaysVisible) {\r\n                        this._drawContainer();\r\n                    }\r\n\r\n                    this._drawPuck();\r\n\r\n                    // store current pointer for next clear\r\n                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\r\n                } else {\r\n                    VirtualJoystick._VJCanvasContext.clearRect((<any>touch).prevX - 44, (<any>touch).prevY - 44, 88, 88);\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\r\n                    VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n                    VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\r\n                    VirtualJoystick._VJCanvasContext.stroke();\r\n                    VirtualJoystick._VJCanvasContext.closePath();\r\n                    (<any>touch).prevX = touch.x;\r\n                    (<any>touch).prevY = touch.y;\r\n                }\r\n            });\r\n        }\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release internal HTML canvas\r\n     */\r\n    public releaseCanvas() {\r\n        if (VirtualJoystick.Canvas) {\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\r\n            window.removeEventListener(\"resize\", this._onResize);\r\n            document.body.removeChild(VirtualJoystick.Canvas);\r\n            VirtualJoystick.Canvas = null;\r\n        }\r\n        this._released = true;\r\n    }\r\n}\r\n", "import { VirtualJoystick, JoystickAxis } from \"../../Misc/virtualJoystick\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { FreeCameraInputsManager } from \"../../Cameras/freeCameraInputsManager\";\r\n\r\n// Module augmentation to abstract virtual joystick from camera.\r\ndeclare module \"../../Cameras/freeCameraInputsManager\" {\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * Add virtual joystick input support to the input manager.\r\n         * @returns the current input manager\r\n         */\r\n        addVirtualJoystick(): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Add virtual joystick input support to the input manager.\r\n * @returns the current input manager\r\n */\r\nFreeCameraInputsManager.prototype.addVirtualJoystick = function (): FreeCameraInputsManager {\r\n    this.add(new FreeCameraVirtualJoystickInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Manage the Virtual Joystick inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    private _leftjoystick: VirtualJoystick;\r\n    private _rightjoystick: VirtualJoystick;\r\n\r\n    /**\r\n     * Gets the left stick of the virtual joystick.\r\n     * @returns The virtual Joystick\r\n     */\r\n    public getLeftJoystick(): VirtualJoystick {\r\n        return this._leftjoystick;\r\n    }\r\n\r\n    /**\r\n     * Gets the right stick of the virtual joystick.\r\n     * @returns The virtual Joystick\r\n     */\r\n    public getRightJoystick(): VirtualJoystick {\r\n        return this._rightjoystick;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs() {\r\n        if (this._leftjoystick) {\r\n            const camera = this.camera;\r\n            const speed = camera._computeLocalCameraSpeed() * 50;\r\n            const cameraTransform = Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);\r\n            const deltaTransform = Vector3.TransformCoordinates(\r\n                new Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed),\r\n                cameraTransform\r\n            );\r\n            camera.cameraDirection = camera.cameraDirection.add(deltaTransform);\r\n            camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);\r\n\r\n            if (!this._leftjoystick.pressed) {\r\n                this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);\r\n            }\r\n            if (!this._rightjoystick.pressed) {\r\n                this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        this._leftjoystick = new VirtualJoystick(true);\r\n        this._leftjoystick.setAxisForUpDown(JoystickAxis.Z);\r\n        this._leftjoystick.setAxisForLeftRight(JoystickAxis.X);\r\n        this._leftjoystick.setJoystickSensibility(0.15);\r\n        this._rightjoystick = new VirtualJoystick(false);\r\n        this._rightjoystick.setAxisForUpDown(JoystickAxis.X);\r\n        this._rightjoystick.setAxisForLeftRight(JoystickAxis.Y);\r\n        this._rightjoystick.reverseUpDown = true;\r\n        this._rightjoystick.setJoystickSensibility(0.05);\r\n        this._rightjoystick.setJoystickColor(\"yellow\");\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this._leftjoystick.releaseCanvas();\r\n        this._rightjoystick.releaseCanvas();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraVirtualJoystickInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"virtualJoystick\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraVirtualJoystickInput\"] = FreeCameraVirtualJoystickInput;\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\r\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera controlled by touch.\r\n * This is like a universal camera minus the Gamepad controls.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class TouchCamera extends FreeCamera {\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    public get touchAngularSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchAngularSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    public get touchMoveSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchMoveSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new touch camera.\r\n     * This represents a FPS type of camera controlled by touch.\r\n     * This is like a universal camera minus the Gamepad controls.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addTouch();\r\n\r\n        this._setupInputs();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TouchCamera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.touchEnabled = false;\r\n        } else {\r\n            touch.allowMouse = true;\r\n        }\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n", "import { BezierCurve } from \"../Maths/math.path\";\r\n\r\n/**\r\n * This represents the main contract an easing function should follow.\r\n * Easing functions are used throughout the animation system.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport interface IEasingFunction {\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * The link below provides some of the most common examples of easing functions.\r\n     * @see https://easings.net/\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    ease(gradient: number): number;\r\n}\r\n\r\n/**\r\n * Base class used for every default easing function.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Interpolation follows the mathematical formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEIN = 0;\r\n\r\n    /**\r\n     * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.\r\n     */\r\n    public static readonly EASINGMODE_EASEOUT = 1;\r\n\r\n    /**\r\n     * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.\r\n     */\r\n    public static readonly EASINGMODE_EASEINOUT = 2;\r\n\r\n    private _easingMode = EasingFunction.EASINGMODE_EASEIN;\r\n\r\n    /**\r\n     * Sets the easing mode of the current function.\r\n     * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)\r\n     */\r\n    public setEasingMode(easingMode: number) {\r\n        const n = Math.min(Math.max(easingMode, 0), 2);\r\n        this._easingMode = n;\r\n    }\r\n    /**\r\n     * Gets the current easing mode.\r\n     * @returns the easing mode\r\n     */\r\n    public getEasingMode(): number {\r\n        return this._easingMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public easeInCore(gradient: number): number {\r\n        throw new Error(\"You must implement this method\");\r\n    }\r\n\r\n    /**\r\n     * Given an input gradient between 0 and 1, this returns the corresponding value\r\n     * of the easing function.\r\n     * @param gradient Defines the value between 0 and 1 we want the easing value for\r\n     * @returns the corresponding value on the curve defined by the easing function\r\n     */\r\n    public ease(gradient: number): number {\r\n        switch (this._easingMode) {\r\n            case EasingFunction.EASINGMODE_EASEIN:\r\n                return this.easeInCore(gradient);\r\n            case EasingFunction.EASINGMODE_EASEOUT:\r\n                return 1 - this.easeInCore(1 - gradient);\r\n        }\r\n\r\n        if (gradient >= 0.5) {\r\n            return (1 - this.easeInCore((1 - gradient) * 2)) * 0.5 + 0.5;\r\n        }\r\n\r\n        return this.easeInCore(gradient * 2) * 0.5;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a circle shape (see link below).\r\n * @see https://easings.net/#easeInCirc\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CircleEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        gradient = Math.max(0, Math.min(1, gradient));\r\n        return 1.0 - Math.sqrt(1.0 - gradient * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a ease back shape (see link below).\r\n * @see https://easings.net/#easeInBack\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BackEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a back ease easing\r\n     * @see https://easings.net/#easeInBack\r\n     * @param amplitude Defines the amplitude of the function\r\n     */\r\n    constructor(\r\n        /** Defines the amplitude of the function */\r\n        public amplitude: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const num = Math.max(0, this.amplitude);\r\n        return Math.pow(gradient, 3.0) - gradient * num * Math.sin(3.1415926535897931 * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bouncing shape (see link below).\r\n * @see https://easings.net/#easeInBounce\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BounceEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bounce easing\r\n     * @see https://easings.net/#easeInBounce\r\n     * @param bounces Defines the number of bounces\r\n     * @param bounciness Defines the amplitude of the bounce\r\n     */\r\n    constructor(\r\n        /** Defines the number of bounces */\r\n        public bounces: number = 3,\r\n        /** Defines the amplitude of the bounce */\r\n        public bounciness: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.bounces);\r\n        let bounciness = this.bounciness;\r\n        if (bounciness <= 1.0) {\r\n            bounciness = 1.001;\r\n        }\r\n        const num9 = Math.pow(bounciness, y);\r\n        const num5 = 1.0 - bounciness;\r\n        const num4 = (1.0 - num9) / num5 + num9 * 0.5;\r\n        const num15 = gradient * num4;\r\n        const num65 = Math.log(-num15 * (1.0 - bounciness) + 1.0) / Math.log(bounciness);\r\n        const num3 = Math.floor(num65);\r\n        const num13 = num3 + 1.0;\r\n        const num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\r\n        const num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\r\n        const num7 = (num8 + num12) * 0.5;\r\n        const num6 = gradient - num7;\r\n        const num2 = num7 - num8;\r\n        return (-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2) * (num6 + num2);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 3 shape (see link below).\r\n * @see https://easings.net/#easeInCubic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class CubicEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an elastic shape (see link below).\r\n * @see https://easings.net/#easeInElastic\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ElasticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an elastic easing function\r\n     * @see https://easings.net/#easeInElastic\r\n     * @param oscillations Defines the number of oscillations\r\n     * @param springiness Defines the amplitude of the oscillations\r\n     */\r\n    constructor(\r\n        /** Defines the number of oscillations*/\r\n        public oscillations: number = 3,\r\n        /** Defines the amplitude of the oscillations*/\r\n        public springiness: number = 3\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        let num2;\r\n        const num3 = Math.max(0.0, this.oscillations);\r\n        const num = Math.max(0.0, this.springiness);\r\n\r\n        if (num == 0) {\r\n            num2 = gradient;\r\n        } else {\r\n            num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\r\n        }\r\n        return num2 * Math.sin((6.2831853071795862 * num3 + 1.5707963267948966) * gradient);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with an exponential shape (see link below).\r\n * @see https://easings.net/#easeInExpo\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class ExponentialEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an exponential easing function\r\n     * @see https://easings.net/#easeInExpo\r\n     * @param exponent Defines the exponent of the function\r\n     */\r\n    constructor(\r\n        /** Defines the exponent of the function */\r\n        public exponent: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        if (this.exponent <= 0) {\r\n            return gradient;\r\n        }\r\n\r\n        return (Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class PowerEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates an power base easing function\r\n     * @see https://easings.net/#easeInQuad\r\n     * @param power Defines the power of the function\r\n     */\r\n    constructor(\r\n        /** Defines the power of the function */\r\n        public power: number = 2\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        const y = Math.max(0.0, this.power);\r\n        return Math.pow(gradient, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 2 shape (see link below).\r\n * @see https://easings.net/#easeInQuad\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuadraticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 4 shape (see link below).\r\n * @see https://easings.net/#easeInQuart\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuarticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a power of 5 shape (see link below).\r\n * @see https://easings.net/#easeInQuint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class QuinticEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return gradient * gradient * gradient * gradient * gradient;\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a sin shape (see link below).\r\n * @see https://easings.net/#easeInSine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class SineEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return 1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient));\r\n    }\r\n}\r\n\r\n/**\r\n * Easing function with a bezier shape (see link below).\r\n * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#easing-functions\r\n */\r\nexport class BezierCurveEase extends EasingFunction implements IEasingFunction {\r\n    /**\r\n     * Instantiates a bezier function\r\n     * @see http://cubic-bezier.com/#.17,.67,.83,.67\r\n     * @param x1 Defines the x component of the start tangent in the bezier curve\r\n     * @param y1 Defines the y component of the start tangent in the bezier curve\r\n     * @param x2 Defines the x component of the end tangent in the bezier curve\r\n     * @param y2 Defines the y component of the end tangent in the bezier curve\r\n     */\r\n    constructor(\r\n        /** Defines the x component of the start tangent in the bezier curve */\r\n        public x1: number = 0,\r\n        /** Defines the y component of the start tangent in the bezier curve */\r\n        public y1: number = 0,\r\n        /** Defines the x component of the end tangent in the bezier curve */\r\n        public x2: number = 1,\r\n        /** Defines the y component of the end tangent in the bezier curve */\r\n        public y2: number = 1\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public easeInCore(gradient: number): number {\r\n        return BezierCurve.Interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\r\n    }\r\n}\r\n", "import type { IEasingFunction } from \"./easing\";\r\n\r\n/**\r\n * Defines an interface which represents an animation key frame\r\n */\r\nexport interface IAnimationKey {\r\n    /**\r\n     * Frame of the key frame\r\n     */\r\n    frame: number;\r\n    /**\r\n     * Value at the specifies key frame\r\n     */\r\n    value: any;\r\n    /**\r\n     * The input tangent for the cubic hermite spline\r\n     */\r\n    inTangent?: any;\r\n    /**\r\n     * The output tangent for the cubic hermite spline\r\n     */\r\n    outTangent?: any;\r\n    /**\r\n     * The animation interpolation type\r\n     */\r\n    interpolation?: AnimationKeyInterpolation;\r\n    /**\r\n     * Property defined by UI tools to link (or not ) the tangents\r\n     */\r\n    lockedTangent?: boolean;\r\n    /**\r\n     * The easing function associated with the key frame (optional). If not defined, the easing function defined at the animation level (if any) will be used instead\r\n     */\r\n    easingFunction?: IEasingFunction;\r\n}\r\n\r\n/**\r\n * Enum for the animation key frame interpolation type\r\n */\r\nexport enum AnimationKeyInterpolation {\r\n    /**\r\n     * Use tangents to interpolate between start and end values.\r\n     */\r\n    NONE = 0,\r\n    /**\r\n     * Do not interpolate between keys and use the start key value only. Tangents are ignored\r\n     */\r\n    STEP = 1,\r\n}\r\n", "/**\r\n * Represents the range of an animation\r\n */\r\nexport class AnimationRange {\r\n    /**\r\n     * Initializes the range of an animation\r\n     * @param name The name of the animation range\r\n     * @param from The starting frame of the animation\r\n     * @param to The ending frame of the animation\r\n     */\r\n    constructor(\r\n        /**The name of the animation range**/\r\n        public name: string,\r\n        /**The starting frame of the animation */\r\n        public from: number,\r\n        /**The ending frame of the animation*/\r\n        public to: number\r\n    ) {}\r\n\r\n    /**\r\n     * Makes a copy of the animation range\r\n     * @returns A copy of the animation range\r\n     */\r\n    public clone(): AnimationRange {\r\n        return new AnimationRange(this.name, this.from, this.to);\r\n    }\r\n}\r\n", "import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport type { DeepImmutable, Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nexport const _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nexport const _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nexport const _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nexport const _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nexport const _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n// Color4\r\nexport const _staticOffsetValueColor4: DeepImmutable<Color4> = Object.freeze(new Color4(0, 0, 0, 0));\r\n\r\n/**\r\n * Options to be used when creating an additive animation\r\n */\r\nexport interface IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * The frame that the animation should be relative to (if not provided, 0 will be used)\r\n     */\r\n    referenceFrame?: number;\r\n    /**\r\n     * The name of the animation range to convert to additive. If not provided, fromFrame / toFrame will be used\r\n     * If fromFrame / toFrame are not provided either, the whole animation will be converted to additive\r\n     */\r\n    range?: string;\r\n    /**\r\n     * If true, the original animation will be cloned and converted to additive. If false, the original animation will be converted to additive (default is false)\r\n     */\r\n    cloneOriginalAnimation?: boolean;\r\n    /**\r\n     * The name of the cloned animation if cloneOriginalAnimation is true. If not provided, use the original animation name\r\n     */\r\n    clonedAnimationName?: string;\r\n    /**\r\n     * Together with toFrame, defines the range of the animation to convert to additive. Will only be used if range is not provided\r\n     * If range and fromFrame / toFrame are not provided, the whole animation will be converted to additive\r\n     */\r\n    fromFrame?: number;\r\n    /**\r\n     * Together with fromFrame, defines the range of the animation to convert to additive.\r\n     */\r\n    toFrame?: number;\r\n    /**\r\n     * If true, the key frames will be clipped to the range specified by range or fromFrame / toFrame (default is false)\r\n     */\r\n    clipKeys?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\nconst evaluateAnimationState: _IAnimationState = {\r\n    key: 0,\r\n    repeatCount: 0,\r\n    loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/,\r\n};\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): Animation;\r\n\r\n    /**\r\n     * Convert the keyframes of an animation to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param options defines the options to use when converting ey keyframes\r\n     * @returns a new Animation if options.cloneOriginalAnimation is true or the original Animation if options.cloneOriginalAnimation is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, options?: IMakeAnimationAdditiveOptions): Animation;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimation: Animation,\r\n        referenceFrameOrOptions?: number | IMakeAnimationAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): Animation {\r\n        let options: IMakeAnimationAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions ?? 0,\r\n                range: range,\r\n                cloneOriginalAnimation: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animation = sourceAnimation;\r\n\r\n        if (options.cloneOriginalAnimation) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = options.clonedAnimationName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (options.range) {\r\n            const rangeValue = animation.getRange(options.range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        } else {\r\n            from = options.fromFrame ?? from;\r\n            to = options.toFrame ?? to;\r\n        }\r\n\r\n        if (from !== firstKey.frame) {\r\n            startIndex = animation.createKeyForFrame(from);\r\n        }\r\n\r\n        if (to !== lastKey.frame) {\r\n            endIndex = animation.createKeyForFrame(to);\r\n        }\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Interpolate the reference value from the animation\r\n        else {\r\n            evaluateAnimationState.key = 0;\r\n            const value = animation._interpolate(referenceFrame, evaluateAnimationState);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        let startFrame = Number.MAX_VALUE;\r\n        const clippedKeys: Nullable<IAnimationKey[]> = options.clipKeys ? [] : null;\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            let key = animation._keys[index];\r\n\r\n            if (clippedKeys) {\r\n                key = {\r\n                    frame: key.frame,\r\n                    value: key.value.clone ? key.value.clone() : key.value,\r\n                    inTangent: key.inTangent,\r\n                    outTangent: key.outTangent,\r\n                    interpolation: key.interpolation,\r\n                    lockedTangent: key.lockedTangent,\r\n                };\r\n                if (startFrame === Number.MAX_VALUE) {\r\n                    startFrame = key.frame;\r\n                }\r\n                key.frame -= startFrame;\r\n                clippedKeys.push(key);\r\n            }\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        if (clippedKeys) {\r\n            animation.setKeys(clippedKeys, true);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        evaluateAnimationState.key = 0;\r\n        return this._interpolate(currentFrame, evaluateAnimationState);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState, searchClosestKeyOnly = false): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n\r\n        if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\r\n            return undefined;\r\n        }\r\n\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = startKey.easingFunction || this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return (state.offsetValue ?? 0) * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\r\n                        return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                    case Animation.ANIMATIONLOOPMODE_YOYO: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>, dontClone = false): void {\r\n        this._keys = !dontClone ? values.slice(0) : values;\r\n    }\r\n\r\n    /**\r\n     * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\r\n     * @param frame Frame number\r\n     * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\r\n     */\r\n    public createKeyForFrame(frame: number) {\r\n        // Find the key corresponding to frame\r\n        evaluateAnimationState.key = 0;\r\n        const value = this._interpolate(frame, evaluateAnimationState, true);\r\n\r\n        if (!value) {\r\n            // A key corresponding to this frame already exists\r\n            return evaluateAnimationState.key === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\r\n        }\r\n\r\n        // The frame is between two keys, so create a new key\r\n        const newKey: IAnimationKey = {\r\n            frame,\r\n            value: value.clone ? value.clone() : value,\r\n        };\r\n\r\n        this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\r\n\r\n        return evaluateAnimationState.key + 1;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n    /**\r\n     * Yoyo Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_YOYO = 4;\r\n    /**\r\n     * Relative Loop Mode (add to current value of animated object, unlike ANIMATIONLOOPMODE_RELATIVE)\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs: Animation[] = [];\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                const diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     * @returns true if the zoom was done\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): boolean {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport type { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport type { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\r\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera\r\n */\r\nexport class ArcRotateCamera extends TargetCamera {\r\n    /**\r\n     * Defines the rotation angle of the camera along the longitudinal axis.\r\n     */\r\n    @serialize()\r\n    public alpha: number;\r\n\r\n    /**\r\n     * Defines the rotation angle of the camera along the latitudinal axis.\r\n     */\r\n    @serialize()\r\n    public beta: number;\r\n\r\n    /**\r\n     * Defines the radius of the camera from it s target point.\r\n     */\r\n    @serialize()\r\n    public radius: number;\r\n\r\n    /**\r\n     * Defines an override value to use as the parameter to setTarget.\r\n     * This allows the parameter to be specified when animating the target (e.g. using FramingBehavior).\r\n     */\r\n    @serialize()\r\n    public overrideCloneAlphaBetaRadius: Nullable<boolean>;\r\n\r\n    @serializeAsVector3(\"target\")\r\n    protected _target: Vector3;\r\n    @serializeAsMeshReference(\"targetHost\")\r\n    protected _targetHost: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this._target;\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Defines the target mesh of the camera.\r\n     * The camera looks towards it from the radius distance.\r\n     * Please note that setting a target host will disable panning.\r\n     */\r\n    public get targetHost(): Nullable<AbstractMesh> {\r\n        return this._targetHost;\r\n    }\r\n    public set targetHost(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            this.setTarget(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this.target;\r\n    }\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this.setPosition(newPosition);\r\n    }\r\n\r\n    protected _upToYMatrix: Matrix;\r\n    protected _yToUpMatrix: Matrix;\r\n\r\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\r\n    set upVector(vec: Vector3) {\r\n        if (!this._upToYMatrix) {\r\n            this._yToUpMatrix = new Matrix();\r\n            this._upToYMatrix = new Matrix();\r\n\r\n            this._upVector = Vector3.Zero();\r\n        }\r\n\r\n        vec.normalize();\r\n        this._upVector.copyFrom(vec);\r\n        this.setMatUp();\r\n    }\r\n\r\n    get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    public setMatUp() {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);\r\n\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    }\r\n\r\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialAlphaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialBetaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialRadiusOffset = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerBetaLimit: Nullable<number> = 0.01;\r\n\r\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperBetaLimit: Nullable<number> = Math.PI - 0.01;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningX: number = 0;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningY: number = 0;\r\n\r\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\r\n    @serialize()\r\n    public pinchToPanMaxDistance: number = 20;\r\n\r\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the camera always in your scene.\r\n     */\r\n    @serialize()\r\n    public panningDistanceLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the target of the camera before panning.\r\n     */\r\n    @serializeAsVector3()\r\n    public panningOriginTarget: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no deceleration at all.\r\n     */\r\n    @serialize()\r\n    public panningInertia = 0.9;\r\n\r\n    //-- begin properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityX(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityX;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityX(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityX = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityY(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityY;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityY(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityY = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    public get pinchPrecision(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchPrecision(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get pinchDeltaPercentage(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchDeltaPercentage(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\r\n    public get useNaturalPinchZoom(): boolean {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.useNaturalPinchZoom;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set useNaturalPinchZoom(value: boolean) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.useNaturalPinchZoom = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    public get panningSensibility(): number {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.panningSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set panningSensibility(value: number) {\r\n        const pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.panningSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    public get wheelPrecision(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public get zoomToMouseLocation(): boolean {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.zoomToMouseLocation;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set zoomToMouseLocation(value: boolean) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.zoomToMouseLocation = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get wheelDeltaPercentage(): number {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelDeltaPercentage(value: number) {\r\n        const mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    //-- end properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Defines how much the radius should be scaled while zooming on a particular mesh (through the zoomOn function)\r\n     */\r\n    @serialize()\r\n    public zoomOnFactor = 1;\r\n\r\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\r\n    @serializeAsVector2()\r\n    public targetScreenOffset = Vector2.Zero();\r\n\r\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\r\n    @serialize()\r\n    public allowUpsideDown = true;\r\n\r\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\r\n    @serialize()\r\n    public useInputToRestoreState = true;\r\n\r\n    /** @internal */\r\n    public _viewMatrix = new Matrix();\r\n    /** @internal */\r\n    public _useCtrlForPanning: boolean;\r\n    /** @internal */\r\n    public _panningMouseButton: number;\r\n\r\n    /**\r\n     * Defines the input associated to the camera.\r\n     */\r\n    public inputs: ArcRotateCameraInputsManager;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\r\n    public panningAxis: Vector3 = new Vector3(1, 1, 0);\r\n    protected _transformedDirection: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * Defines if camera will eliminate transform on y axis.\r\n     */\r\n    public mapPanning: boolean = false;\r\n\r\n    // Behaviors\r\n    private _bouncingBehavior: Nullable<BouncingBehavior>;\r\n\r\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get bouncingBehavior(): Nullable<BouncingBehavior> {\r\n        return this._bouncingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n     */\r\n    public get useBouncingBehavior(): boolean {\r\n        return this._bouncingBehavior != null;\r\n    }\r\n\r\n    public set useBouncingBehavior(value: boolean) {\r\n        if (value === this.useBouncingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._bouncingBehavior = new BouncingBehavior();\r\n            this.addBehavior(this._bouncingBehavior);\r\n        } else if (this._bouncingBehavior) {\r\n            this.removeBehavior(this._bouncingBehavior);\r\n            this._bouncingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _framingBehavior: Nullable<FramingBehavior>;\r\n\r\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get framingBehavior(): Nullable<FramingBehavior> {\r\n        return this._framingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n     */\r\n    public get useFramingBehavior(): boolean {\r\n        return this._framingBehavior != null;\r\n    }\r\n\r\n    public set useFramingBehavior(value: boolean) {\r\n        if (value === this.useFramingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._framingBehavior = new FramingBehavior();\r\n            this.addBehavior(this._framingBehavior);\r\n        } else if (this._framingBehavior) {\r\n            this.removeBehavior(this._framingBehavior);\r\n            this._framingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _autoRotationBehavior: Nullable<AutoRotationBehavior>;\r\n\r\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get autoRotationBehavior(): Nullable<AutoRotationBehavior> {\r\n        return this._autoRotationBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n     */\r\n    public get useAutoRotationBehavior(): boolean {\r\n        return this._autoRotationBehavior != null;\r\n    }\r\n\r\n    public set useAutoRotationBehavior(value: boolean) {\r\n        if (value === this.useAutoRotationBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._autoRotationBehavior = new AutoRotationBehavior();\r\n            this.addBehavior(this._autoRotationBehavior);\r\n        } else if (this._autoRotationBehavior) {\r\n            this.removeBehavior(this._autoRotationBehavior);\r\n            this._autoRotationBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable triggered when the mesh target has been changed on the camera.\r\n     */\r\n    public onMeshTargetChangedObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /**\r\n     * Event raised when the camera is colliding with a mesh.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#how-can-i-do-this-\r\n     */\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    public collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    protected _collider: Collider;\r\n    protected _previousPosition = Vector3.Zero();\r\n    protected _collisionVelocity = Vector3.Zero();\r\n    protected _newPosition = Vector3.Zero();\r\n    protected _previousAlpha: number;\r\n    protected _previousBeta: number;\r\n    protected _previousRadius: number;\r\n    //due to async collision inspection\r\n    protected _collisionTriggered: boolean;\r\n\r\n    protected _targetBoundingCenter: Nullable<Vector3>;\r\n\r\n    private _computationVector: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the longitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._target = Vector3.Zero();\r\n        if (target) {\r\n            this.setTarget(target);\r\n        }\r\n\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.radius = radius;\r\n\r\n        this.getViewMatrix();\r\n        this.inputs = new ArcRotateCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _initCache(): void {\r\n        super._initCache();\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    }\r\n\r\n    protected _getTargetPosition(): Vector3 {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            const pos: Vector3 = this._targetHost.getAbsolutePosition();\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            } else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    private _storedAlpha: number;\r\n    private _storedBeta: number;\r\n    private _storedRadius: number;\r\n    private _storedTarget: Vector3;\r\n    private _storedTargetScreenOffset: Vector2;\r\n\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._cache._target.equals(this._getTargetPosition()) &&\r\n            this._cache.alpha === this.alpha &&\r\n            this._cache.beta === this.beta &&\r\n            this._cache.radius === this.radius &&\r\n            this._cache.targetScreenOffset.equals(this.targetScreenOffset)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean, panningMouseButton: number): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean, useCtrlForPanning: boolean | number = true, panningMouseButton: number = 2): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        const args = arguments;\r\n\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);\r\n        this._useCtrlForPanning = useCtrlForPanning as boolean;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof args[0] === \"boolean\") {\r\n            if (args.length > 1) {\r\n                this._useCtrlForPanning = args[1];\r\n            }\r\n            if (args.length > 2) {\r\n                this._panningMouseButton = args[2];\r\n            }\r\n        }\r\n\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n            this.inertialAlphaOffset = 0;\r\n            this.inertialBetaOffset = 0;\r\n            this.inertialRadiusOffset = 0;\r\n            this.inertialPanningX = 0;\r\n            this.inertialPanningY = 0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            const directionModifier = this.invertRotation ? -1 : 1;\r\n            const handednessMultiplier = this._calculateHandednessMultiplier();\r\n            let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;\r\n\r\n            if (this.beta <= 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n\r\n            this.alpha += inertialAlphaOffset * directionModifier;\r\n            this.beta += this.inertialBetaOffset * directionModifier;\r\n\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            localDirection.multiplyInPlace(this.panningAxis);\r\n            Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n\r\n            // If mapPanning is enabled, we need to take the upVector into account and\r\n            // make sure we're not panning in the y direction\r\n            if (this.mapPanning) {\r\n                const up = this.upVector;\r\n                const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);\r\n                Vector3.CrossToRef(up, right, this._transformedDirection);\r\n            } else if (!this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                } else {\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n\r\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n\r\n        // Limits\r\n        this._checkLimits();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _checkLimits() {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    public rebuildAnglesAndRadius(): void {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n\r\n        this.radius = this._computationVector.length();\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        // Alpha\r\n        const previousAlpha = this.alpha;\r\n        if (this._computationVector.x === 0 && this._computationVector.z === 0) {\r\n            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\r\n        } else {\r\n            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\r\n        }\r\n\r\n        if (this._computationVector.z < 0) {\r\n            this.alpha = 2 * Math.PI - this.alpha;\r\n        }\r\n\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n\r\n        // Beta\r\n        this.beta = Math.acos(this._computationVector.y / this.radius);\r\n\r\n        this._checkLimits();\r\n    }\r\n\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    public setPosition(position: Vector3): void {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * Please note that setting a target as a mesh will disable panning.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target\r\n     */\r\n    public setTarget(target: AbstractMesh | Vector3, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false): void {\r\n        cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;\r\n\r\n        if ((<any>target).getBoundingInfo) {\r\n            if (toBoundingCenter) {\r\n                this._targetBoundingCenter = (<any>target).getBoundingInfo().boundingBox.centerWorld.clone();\r\n            } else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            (<AbstractMesh>target).computeWorldMatrix();\r\n            this._targetHost = <AbstractMesh>target;\r\n            this._target = this._getTargetPosition();\r\n\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        } else {\r\n            const newTarget = <Vector3>target;\r\n            const currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n\r\n        if (!cloneAlphaBetaRadius) {\r\n            this.rebuildAnglesAndRadius();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        // Compute\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);\r\n        }\r\n\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            const coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        } else {\r\n            this._position.copyFrom(this._newPosition);\r\n\r\n            let up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n\r\n            this._computeViewMatrix(this._position, target, up);\r\n\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget = target;\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        if (!collidedMesh) {\r\n            this._previousPosition.copyFrom(this._position);\r\n        } else {\r\n            this.setPosition(newPosition);\r\n\r\n            if (this.onCollide) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n\r\n        // Recompute because of constraints\r\n        const cosa = Math.cos(this.alpha);\r\n        const sina = Math.sin(this.alpha);\r\n        const cosb = Math.cos(this.beta);\r\n        let sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        const target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        this._position.copyFrom(this._newPosition);\r\n\r\n        let up = this.upVector;\r\n        if (this.allowUpsideDown && this.beta < 0) {\r\n            up = up.clone();\r\n            up = up.negate();\r\n        }\r\n\r\n        this._computeViewMatrix(this._position, target, up);\r\n        this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n        this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n\r\n        this._collisionTriggered = false;\r\n    };\r\n\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ = false): void {\r\n        meshes = meshes || this.getScene().meshes;\r\n\r\n        const minMaxVector = Mesh.MinMax(meshes);\r\n        let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);\r\n\r\n        // If there are defined limits, we need to take them into account\r\n        distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);\r\n        this.radius = distance * this.zoomOnFactor;\r\n\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    }\r\n\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | { min: Vector3; max: Vector3; distance: number }, doNotUpdateMaxZ = false): void {\r\n        let meshesOrMinMaxVector: { min: Vector3; max: Vector3 };\r\n        let distance: number;\r\n\r\n        if ((<any>meshesOrMinMaxVectorAndDistance).min === undefined) {\r\n            // meshes\r\n            const meshes = <AbstractMesh[]>meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        } else {\r\n            //minMaxVector and distance\r\n            const minMaxVectorAndDistance = <any>meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     */\r\n    public createRigCamera(name: string, cameraIndex: number): Camera {\r\n        let alphaShift: number = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        const rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n\r\n        rigCam.mode = this.mode;\r\n        rigCam.orthoLeft = this.orthoLeft;\r\n        rigCam.orthoRight = this.orthoRight;\r\n        rigCam.orthoBottom = this.orthoBottom;\r\n        rigCam.orthoTop = this.orthoTop;\r\n\r\n        return rigCam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <ArcRotateCamera>this._rigCameras[0];\r\n        const camRight = <ArcRotateCamera>this._rigCameras[1];\r\n\r\n        camLeft.beta = camRight.beta = this.beta;\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3, radiusScale: number = 1): number {\r\n        const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);\r\n\r\n        // Get aspect ratio in order to calculate frustum slope\r\n        const engine = this.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(this);\r\n        const frustumSlopeY = Math.tan(this.fov / 2);\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeX * frustumSlopeX));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlopeY * frustumSlopeY));\r\n        return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCamera\";\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nimport \"./Inputs/freeCameraDeviceOrientationInput\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n\r\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\r\n    return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// We're mainly based on the logic defined into the FreeCamera code\r\n/**\r\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\r\n * being tilted forward or back and left or right.\r\n */\r\nexport class DeviceOrientationCamera extends FreeCamera {\r\n    private _initialQuaternion: Quaternion;\r\n    private _quaternionCache: Quaternion;\r\n    private _tmpDragQuaternion = new Quaternion();\r\n    private _disablePointerInputWhenUsingDeviceOrientation = true;\r\n\r\n    /**\r\n     * Creates a new device orientation camera\r\n     * @param name The name of the camera\r\n     * @param position The start position camera\r\n     * @param scene The scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this._quaternionCache = new Quaternion();\r\n        this.inputs.addDeviceOrientation();\r\n\r\n        // When the orientation sensor fires it's first event, disable mouse input\r\n        if (this.inputs._deviceOrientationInput) {\r\n            this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\r\n                if (this._disablePointerInputWhenUsingDeviceOrientation) {\r\n                    if (this.inputs._mouseInput) {\r\n                        this.inputs._mouseInput._allowCameraRotation = false;\r\n                        this.inputs._mouseInput.onPointerMovedObservable.add((e) => {\r\n                            if (this._dragFactor != 0) {\r\n                                if (!this._initialQuaternion) {\r\n                                    this._initialQuaternion = new Quaternion();\r\n                                }\r\n                                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\r\n                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\r\n                                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\r\n     */\r\n    public get disablePointerInputWhenUsingDeviceOrientation() {\r\n        return this._disablePointerInputWhenUsingDeviceOrientation;\r\n    }\r\n\r\n    public set disablePointerInputWhenUsingDeviceOrientation(value: boolean) {\r\n        this._disablePointerInputWhenUsingDeviceOrientation = value;\r\n    }\r\n\r\n    private _dragFactor = 0;\r\n    /**\r\n     * Enabled turning on the y axis when the orientation sensor is active\r\n     * @param dragFactor the factor that controls the turn speed (default: 1/300)\r\n     */\r\n    public enableHorizontalDragging(dragFactor = 1 / 300) {\r\n        this._dragFactor = dragFactor;\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"DeviceOrientationCamera\").\r\n     * This helps avoiding instanceof at run time.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DeviceOrientationCamera\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Checks and applies the current values of the inputs to the camera. (Internal use only)\r\n     */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._quaternionCache.copyFrom(this.rotationQuaternion);\r\n        if (this._initialQuaternion) {\r\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the camera to its default orientation on the specified axis only.\r\n     * @param axis The axis to reset\r\n     */\r\n    public resetToCurrentRotation(axis: Axis = Axis.Y): void {\r\n        //can only work if this camera has a rotation quaternion already.\r\n        if (!this.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        if (!this._initialQuaternion) {\r\n            this._initialQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\r\n\r\n        [\"x\", \"y\", \"z\"].forEach((axisName) => {\r\n            if (!(<any>axis)[axisName]) {\r\n                (<any>this._initialQuaternion)[axisName] = 0;\r\n            } else {\r\n                (<any>this._initialQuaternion)[axisName] *= -1;\r\n            }\r\n        });\r\n        this._initialQuaternion.normalize();\r\n        //force rotation update\r\n        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n    }\r\n}\r\n", "import type { FlyCamera } from \"./flyCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput\";\r\nimport { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput\";\r\n\r\n/**\r\n * Default Inputs manager for the FlyCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraInputsManager extends CameraInputsManager<FlyCamera> {\r\n    /**\r\n     * Instantiates a new FlyCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to.\r\n     */\r\n    constructor(camera: FlyCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the new FlyCameraKeyboardMoveInput().\r\n     */\r\n    addKeyboard(): FlyCameraInputsManager {\r\n        this.add(new FlyCameraKeyboardInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @returns the new FlyCameraMouseInput().\r\n     */\r\n    addMouse(): FlyCameraInputsManager {\r\n        this.add(new FlyCameraMouseInput());\r\n        return this;\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Quaternion } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager\";\r\nimport type { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput\";\r\nimport type { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n * such as in a 3D Space Shooter or a Flight Simulator.\r\n */\r\nexport class FlyCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful for simulating a camera body, like a player's body.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful if the camera is attached away from the player's body center,\r\n     * such as at its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to.\r\n     */\r\n    public cameraDirection = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current local rotation of the camera as a quaternion to prevent Gimbal lock.\r\n     * This overrides and empties cameraRotation.\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Track Roll to maintain the wanted Rolling when looking around.\r\n     */\r\n    public _trackRoll: number = 0;\r\n\r\n    /**\r\n     * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\r\n     */\r\n    public rollCorrect: number = 100;\r\n\r\n    /**\r\n     * Mimic a banked turn, Rolling the camera when Yawing.\r\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\r\n     */\r\n    public bankedTurn: boolean = false;\r\n\r\n    /**\r\n     * Limit in radians for how much Roll banking will add. (Default: 90°)\r\n     */\r\n    public bankedTurnLimit: number = Math.PI / 2;\r\n\r\n    /**\r\n     * Value of 0 disables the banked Roll.\r\n     * Value of 1 is equal to the Yaw angle in radians.\r\n     */\r\n    public bankedTurnMultiplier: number = 1;\r\n\r\n    /**\r\n     * The inputs manager loads all the input sources, such as keyboard and mouse.\r\n     */\r\n    public inputs: FlyCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement forward.\r\n     */\r\n    public get keysForward(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysForward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement forward.\r\n     */\r\n    public set keysForward(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysForward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement backward.\r\n     */\r\n    public get keysBackward(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysBackward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysBackward(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysBackward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement up.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement up.\r\n     */\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement down.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement down.\r\n     */\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement left.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement left.\r\n     */\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collides with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a FlyCamera.\r\n     * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n     * such as in a 3D Space Shooter or a Flight Simulator.\r\n     * @param name Define the name of the camera in the scene.\r\n     * @param position Define the starting position of the camera in the scene.\r\n     * @param scene Define the scene the camera belongs to.\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active, if no other camera has been defined as active.\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FlyCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach a control from the HTML DOM element.\r\n     * The camera will stop reacting to that input.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n    }\r\n\r\n    // Collisions.\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Get the mask that the camera ignores in collision events.\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    /**\r\n     * Set the mask that the camera ignores in collision events.\r\n     */\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        // No need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        // Add gravity to direction to prevent dual-collision checking.\r\n        if (this.applyGravity) {\r\n            // This prevents mending with cameraDirection, a global variable of the fly camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        const updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore the Roll to its target value at the rate specified.\r\n     * @param rate - Higher means slower restoring.\r\n     * @internal\r\n     */\r\n    public restoreRoll(rate: number): void {\r\n        const limit = this._trackRoll; // Target Roll.\r\n        const z = this.rotation.z; // Current Roll.\r\n        const delta = limit - z; // Difference in Roll.\r\n\r\n        const minRad = 0.001; // Tenth of a radian is a barely noticable difference.\r\n\r\n        // If the difference is noticable, restore the Roll.\r\n        if (Math.abs(delta) >= minRad) {\r\n            // Change Z rotation towards the target Roll.\r\n            this.rotation.z += delta / rate;\r\n\r\n            // Match when near enough.\r\n            if (Math.abs(limit - this.rotation.z) <= minRad) {\r\n                this.rotation.z = limit;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources held by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Get the current object class name.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCamera\";\r\n    }\r\n}\r\n", "import { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport type { FollowCamera } from \"./followCamera\";\r\nimport { FollowCameraKeyboardMoveInput } from \"./Inputs/followCameraKeyboardMoveInput\";\r\nimport { FollowCameraMouseWheelInput } from \"./Inputs/followCameraMouseWheelInput\";\r\nimport { FollowCameraPointersInput } from \"./Inputs/followCameraPointersInput\";\r\n\r\n/**\r\n * Default Inputs manager for the FollowCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraInputsManager extends CameraInputsManager<FollowCamera> {\r\n    /**\r\n     * Instantiates a new FollowCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FollowCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add orientation input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addVRDeviceOrientation(): FollowCameraInputsManager {\r\n        console.warn(\"DeviceOrientation support not yet implemented for FollowCamera.\");\r\n        return this;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager\";\r\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\r\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\r\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\r\n});\r\n\r\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n */\r\nexport class FollowCamera extends TargetCamera {\r\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\r\n    @serialize()\r\n    public radius: number = 12;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\r\n    @serialize()\r\n    public rotationOffset: number = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chasing a plane)\r\n     */\r\n    @serialize()\r\n    public heightOffset: number = 4;\r\n\r\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\r\n    @serialize()\r\n    public cameraAcceleration: number = 0.05;\r\n\r\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\r\n    @serialize()\r\n    public maxCameraSpeed: number = 20;\r\n\r\n    /**\r\n     * Define the target of the camera.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the input associated with the camera.\r\n     */\r\n    public inputs: FollowCameraInputsManager;\r\n\r\n    /**\r\n     * Instantiates the follow camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the position of the camera\r\n     * @param scene Define the scene the camera belong to\r\n     * @param lockedTarget Define the target of the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, lockedTarget: Nullable<AbstractMesh> = null) {\r\n        super(name, position, scene);\r\n\r\n        this.lockedTarget = lockedTarget;\r\n        this.inputs = new FollowCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        // Uncomment the following line when the relevant handlers have been implemented.\r\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\r\n    }\r\n\r\n    private _follow(cameraTarget: AbstractMesh) {\r\n        if (!cameraTarget) {\r\n            return;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\r\n        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\r\n\r\n        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\r\n        const targetPosition = cameraTarget.getAbsolutePosition();\r\n        const targetX: number = targetPosition.x + Math.sin(radians) * this.radius;\r\n\r\n        const targetZ: number = targetPosition.z + Math.cos(radians) * this.radius;\r\n        const dx: number = targetX - this.position.x;\r\n        const dy: number = targetPosition.y + this.heightOffset - this.position.y;\r\n        const dz: number = targetZ - this.position.z;\r\n        let vx: number = dx * this.cameraAcceleration * 2; //this is set to .05\r\n        let vy: number = dy * this.cameraAcceleration;\r\n        let vz: number = dz * this.cameraAcceleration * 2;\r\n\r\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\r\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\r\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\r\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {};\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        this._checkLimits();\r\n        super._checkInputs();\r\n        if (this.lockedTarget) {\r\n            this._follow(this.lockedTarget);\r\n        }\r\n    }\r\n\r\n    private _checkLimits() {\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n        }\r\n\r\n        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\r\n            this.heightOffset = this.lowerHeightOffsetLimit;\r\n        }\r\n        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\r\n            this.heightOffset = this.upperHeightOffsetLimit;\r\n        }\r\n\r\n        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\r\n            this.rotationOffset = this.lowerRotationOffsetLimit;\r\n        }\r\n        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\r\n            this.rotationOffset = this.upperRotationOffsetLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCamera\";\r\n    }\r\n}\r\n\r\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n */\r\nexport class ArcFollowCamera extends TargetCamera {\r\n    private _cartesianCoordinates: Vector3 = Vector3.Zero();\r\n\r\n    /** Define the camera target (the mesh it should follow) */\r\n    private _meshTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Instantiates a new ArcFollowCamera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n     * @param name Define the name of the camera\r\n     * @param alpha Define the rotation angle of the camera around the longitudinal axis\r\n     * @param beta Define the rotation angle of the camera around the elevation axis\r\n     * @param radius Define the radius of the camera from its target point\r\n     * @param target Define the target of the camera\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(\r\n        name: string,\r\n        /** The longitudinal angle of the camera */\r\n        public alpha: number,\r\n        /** The latitudinal angle of the camera */\r\n        public beta: number,\r\n        /** The radius of the camera from its target */\r\n        public radius: number,\r\n        /** Define the camera target (the mesh it should follow) */\r\n        target: Nullable<AbstractMesh>,\r\n        scene: Scene\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this.setMeshTarget(target);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to follow with this camera.\r\n     * @param target the target to follow\r\n     */\r\n    public setMeshTarget(target: Nullable<AbstractMesh>) {\r\n        this._meshTarget = target;\r\n        this._follow();\r\n    }\r\n\r\n    private _follow(): void {\r\n        if (!this._meshTarget) {\r\n            return;\r\n        }\r\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\r\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\r\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\r\n\r\n        const targetPosition = this._meshTarget.getAbsolutePosition();\r\n        this.position = targetPosition.add(this._cartesianCoordinates);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._follow();\r\n    }\r\n\r\n    /**\r\n     * Returns the class name of the object.\r\n     * It is mostly used internally for serialization purposes.\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcFollowCamera\";\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"../Gamepads/gamepad\";\r\n/**\r\n * Defines supported buttons for XBox360 compatible gamepads\r\n */\r\nexport enum Xbox360Button {\r\n    /** A */\r\n    A = 0,\r\n    /** B */\r\n    B = 1,\r\n    /** X */\r\n    X = 2,\r\n    /** Y */\r\n    Y = 3,\r\n    /** Left button */\r\n    LB = 4,\r\n    /** Right button */\r\n    RB = 5,\r\n    /** Back */\r\n    Back = 8,\r\n    /** Start */\r\n    Start = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for XBox360 DPad  */\r\nexport enum Xbox360Dpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a XBox360 gamepad\r\n */\r\nexport class Xbox360Pad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: Xbox360Button) => void;\r\n    private _onbuttonup: (buttonReleased: Xbox360Button) => void;\r\n    private _ondpaddown: (dPadPressed: Xbox360Dpad) => void;\r\n    private _ondpadup: (dPadReleased: Xbox360Dpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<Xbox360Button>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<Xbox360Dpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<Xbox360Dpad>();\r\n\r\n    private _buttonA: number = 0;\r\n    private _buttonB: number = 0;\r\n    private _buttonX: number = 0;\r\n    private _buttonY: number = 0;\r\n    private _buttonBack: number = 0;\r\n    private _buttonStart: number = 0;\r\n    private _buttonLB: number = 0;\r\n    private _buttonRB: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    private _isXboxOnePad: boolean = false;\r\n\r\n    /**\r\n     * Creates a new XBox360 gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     * @param xboxOne defines if it is a XBox One gamepad\r\n     */\r\n    constructor(id: string, index: number, gamepad: any, xboxOne: boolean = false) {\r\n        super(id, index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.XBOX;\r\n        this._isXboxOnePad = xboxOne;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: Xbox360Button) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: Xbox360Button) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: Xbox360Dpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: Xbox360Button): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: Xbox360Dpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `A` button\r\n     */\r\n    public get buttonA(): number {\r\n        return this._buttonA;\r\n    }\r\n    /**\r\n     * Sets the value of the `A` button\r\n     */\r\n    public set buttonA(value) {\r\n        this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `B` button\r\n     */\r\n    public get buttonB(): number {\r\n        return this._buttonB;\r\n    }\r\n    /**\r\n     * Sets the value of the `B` button\r\n     */\r\n    public set buttonB(value) {\r\n        this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `X` button\r\n     */\r\n    public get buttonX(): number {\r\n        return this._buttonX;\r\n    }\r\n    /**\r\n     * Sets the value of the `X` button\r\n     */\r\n    public set buttonX(value) {\r\n        this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Y` button\r\n     */\r\n    public get buttonY(): number {\r\n        return this._buttonY;\r\n    }\r\n    /**\r\n     * Sets the value of the `Y` button\r\n     */\r\n    public set buttonY(value) {\r\n        this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Start` button\r\n     */\r\n    public get buttonStart(): number {\r\n        return this._buttonStart;\r\n    }\r\n    /**\r\n     * Sets the value of the `Start` button\r\n     */\r\n    public set buttonStart(value) {\r\n        this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Back` button\r\n     */\r\n    public get buttonBack(): number {\r\n        return this._buttonBack;\r\n    }\r\n    /**\r\n     * Sets the value of the `Back` button\r\n     */\r\n    public set buttonBack(value) {\r\n        this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Left` button\r\n     */\r\n    public get buttonLB(): number {\r\n        return this._buttonLB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Left` button\r\n     */\r\n    public set buttonLB(value) {\r\n        this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Right` button\r\n     */\r\n    public get buttonRB(): number {\r\n        return this._buttonRB;\r\n    }\r\n    /**\r\n     * Sets the value of the `Right` button\r\n     */\r\n    public set buttonRB(value) {\r\n        this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this._isXboxOnePad) {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        } else {\r\n            this.buttonA = this.browserGamepad.buttons[0].value;\r\n            this.buttonB = this.browserGamepad.buttons[1].value;\r\n            this.buttonX = this.browserGamepad.buttons[2].value;\r\n            this.buttonY = this.browserGamepad.buttons[3].value;\r\n            this.buttonLB = this.browserGamepad.buttons[4].value;\r\n            this.buttonRB = this.browserGamepad.buttons[5].value;\r\n            this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n            this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n            this.buttonBack = this.browserGamepad.buttons[8].value;\r\n            this.buttonStart = this.browserGamepad.buttons[9].value;\r\n            this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n            this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n            this.dPadUp = this.browserGamepad.buttons[12].value;\r\n            this.dPadDown = this.browserGamepad.buttons[13].value;\r\n            this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n            this.dPadRight = this.browserGamepad.buttons[15].value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { Gamepad } from \"./gamepad\";\r\n\r\n/**\r\n * Defines supported buttons for DualShock compatible gamepads\r\n */\r\nexport enum DualShockButton {\r\n    /** Cross */\r\n    Cross = 0,\r\n    /** Circle */\r\n    Circle = 1,\r\n    /** Square */\r\n    Square = 2,\r\n    /** Triangle */\r\n    Triangle = 3,\r\n    /** L1 */\r\n    L1 = 4,\r\n    /** R1 */\r\n    R1 = 5,\r\n    /** Share */\r\n    Share = 8,\r\n    /** Options */\r\n    Options = 9,\r\n    /** Left stick */\r\n    LeftStick = 10,\r\n    /** Right stick */\r\n    RightStick = 11,\r\n}\r\n\r\n/** Defines values for DualShock DPad  */\r\nexport enum DualShockDpad {\r\n    /** Up */\r\n    Up = 12,\r\n    /** Down */\r\n    Down = 13,\r\n    /** Left */\r\n    Left = 14,\r\n    /** Right */\r\n    Right = 15,\r\n}\r\n\r\n/**\r\n * Defines a DualShock gamepad\r\n */\r\nexport class DualShockPad extends Gamepad {\r\n    private _leftTrigger: number = 0;\r\n    private _rightTrigger: number = 0;\r\n\r\n    private _onlefttriggerchanged: (value: number) => void;\r\n    private _onrighttriggerchanged: (value: number) => void;\r\n\r\n    private _onbuttondown: (buttonPressed: DualShockButton) => void;\r\n    private _onbuttonup: (buttonReleased: DualShockButton) => void;\r\n    private _ondpaddown: (dPadPressed: DualShockDpad) => void;\r\n    private _ondpadup: (dPadReleased: DualShockDpad) => void;\r\n\r\n    /** Observable raised when a button is pressed */\r\n    public onButtonDownObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a button is released */\r\n    public onButtonUpObservable = new Observable<DualShockButton>();\r\n    /** Observable raised when a pad is pressed */\r\n    public onPadDownObservable = new Observable<DualShockDpad>();\r\n    /** Observable raised when a pad is released */\r\n    public onPadUpObservable = new Observable<DualShockDpad>();\r\n\r\n    private _buttonCross: number = 0;\r\n    private _buttonCircle: number = 0;\r\n    private _buttonSquare: number = 0;\r\n    private _buttonTriangle: number = 0;\r\n    private _buttonShare: number = 0;\r\n    private _buttonOptions: number = 0;\r\n    private _buttonL1: number = 0;\r\n    private _buttonR1: number = 0;\r\n\r\n    private _buttonLeftStick: number = 0;\r\n    private _buttonRightStick: number = 0;\r\n    private _dPadUp: number = 0;\r\n    private _dPadDown: number = 0;\r\n    private _dPadLeft: number = 0;\r\n    private _dPadRight: number = 0;\r\n\r\n    /**\r\n     * Creates a new DualShock gamepad object\r\n     * @param id defines the id of this gamepad\r\n     * @param index defines its index\r\n     * @param gamepad defines the internal HTML gamepad object\r\n     */\r\n    constructor(id: string, index: number, gamepad: any) {\r\n        super(id.replace(\"STANDARD GAMEPAD\", \"SONY PLAYSTATION DUALSHOCK\"), index, gamepad, 0, 1, 2, 3);\r\n        this.type = Gamepad.DUALSHOCK;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when left trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onlefttriggerchanged(callback: (value: number) => void) {\r\n        this._onlefttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when right trigger is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onrighttriggerchanged(callback: (value: number) => void) {\r\n        this._onrighttriggerchanged = callback;\r\n    }\r\n\r\n    /**\r\n     * Gets the left trigger value\r\n     */\r\n    public get leftTrigger(): number {\r\n        return this._leftTrigger;\r\n    }\r\n    /**\r\n     * Sets the left trigger value\r\n     */\r\n    public set leftTrigger(newValue: number) {\r\n        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\r\n            this._onlefttriggerchanged(newValue);\r\n        }\r\n        this._leftTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the right trigger value\r\n     */\r\n    public get rightTrigger(): number {\r\n        return this._rightTrigger;\r\n    }\r\n    /**\r\n     * Sets the right trigger value\r\n     */\r\n    public set rightTrigger(newValue: number) {\r\n        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\r\n            this._onrighttriggerchanged(newValue);\r\n        }\r\n        this._rightTrigger = newValue;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttondown(callback: (buttonPressed: DualShockButton) => void) {\r\n        this._onbuttondown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a button is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public onbuttonup(callback: (buttonReleased: DualShockButton) => void) {\r\n        this._onbuttonup = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is pressed\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpaddown(callback: (dPadPressed: DualShockDpad) => void) {\r\n        this._ondpaddown = callback;\r\n    }\r\n\r\n    /**\r\n     * Defines the callback to call when a pad is released\r\n     * @param callback defines the callback to use\r\n     */\r\n    public ondpadup(callback: (dPadReleased: DualShockDpad) => void) {\r\n        this._ondpadup = callback;\r\n    }\r\n\r\n    private _setButtonValue(newValue: number, currentValue: number, buttonType: DualShockButton): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._onbuttondown) {\r\n                    this._onbuttondown(buttonType);\r\n                }\r\n\r\n                this.onButtonDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._onbuttonup) {\r\n                    this._onbuttonup(buttonType);\r\n                }\r\n\r\n                this.onButtonUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    private _setDPadValue(newValue: number, currentValue: number, buttonType: DualShockDpad): number {\r\n        if (newValue !== currentValue) {\r\n            if (newValue === 1) {\r\n                if (this._ondpaddown) {\r\n                    this._ondpaddown(buttonType);\r\n                }\r\n\r\n                this.onPadDownObservable.notifyObservers(buttonType);\r\n            }\r\n            if (newValue === 0) {\r\n                if (this._ondpadup) {\r\n                    this._ondpadup(buttonType);\r\n                }\r\n\r\n                this.onPadUpObservable.notifyObservers(buttonType);\r\n            }\r\n        }\r\n        return newValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Cross` button\r\n     */\r\n    public get buttonCross(): number {\r\n        return this._buttonCross;\r\n    }\r\n    /**\r\n     * Sets the value of the `Cross` button\r\n     */\r\n    public set buttonCross(value) {\r\n        this._buttonCross = this._setButtonValue(value, this._buttonCross, DualShockButton.Cross);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Circle` button\r\n     */\r\n    public get buttonCircle(): number {\r\n        return this._buttonCircle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Circle` button\r\n     */\r\n    public set buttonCircle(value) {\r\n        this._buttonCircle = this._setButtonValue(value, this._buttonCircle, DualShockButton.Circle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Square` button\r\n     */\r\n    public get buttonSquare(): number {\r\n        return this._buttonSquare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Square` button\r\n     */\r\n    public set buttonSquare(value) {\r\n        this._buttonSquare = this._setButtonValue(value, this._buttonSquare, DualShockButton.Square);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Triangle` button\r\n     */\r\n    public get buttonTriangle(): number {\r\n        return this._buttonTriangle;\r\n    }\r\n    /**\r\n     * Sets the value of the `Triangle` button\r\n     */\r\n    public set buttonTriangle(value) {\r\n        this._buttonTriangle = this._setButtonValue(value, this._buttonTriangle, DualShockButton.Triangle);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Options` button\r\n     */\r\n    public get buttonOptions(): number {\r\n        return this._buttonOptions;\r\n    }\r\n    /**\r\n     * Sets the value of the `Options` button\r\n     */\r\n    public set buttonOptions(value) {\r\n        this._buttonOptions = this._setButtonValue(value, this._buttonOptions, DualShockButton.Options);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `Share` button\r\n     */\r\n    public get buttonShare(): number {\r\n        return this._buttonShare;\r\n    }\r\n    /**\r\n     * Sets the value of the `Share` button\r\n     */\r\n    public set buttonShare(value) {\r\n        this._buttonShare = this._setButtonValue(value, this._buttonShare, DualShockButton.Share);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `L1` button\r\n     */\r\n    public get buttonL1(): number {\r\n        return this._buttonL1;\r\n    }\r\n    /**\r\n     * Sets the value of the `L1` button\r\n     */\r\n    public set buttonL1(value) {\r\n        this._buttonL1 = this._setButtonValue(value, this._buttonL1, DualShockButton.L1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the `R1` button\r\n     */\r\n    public get buttonR1(): number {\r\n        return this._buttonR1;\r\n    }\r\n    /**\r\n     * Sets the value of the `R1` button\r\n     */\r\n    public set buttonR1(value) {\r\n        this._buttonR1 = this._setButtonValue(value, this._buttonR1, DualShockButton.R1);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Left joystick\r\n     */\r\n    public get buttonLeftStick(): number {\r\n        return this._buttonLeftStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Left joystick\r\n     */\r\n    public set buttonLeftStick(value) {\r\n        this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, DualShockButton.LeftStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the Right joystick\r\n     */\r\n    public get buttonRightStick(): number {\r\n        return this._buttonRightStick;\r\n    }\r\n    /**\r\n     * Sets the value of the Right joystick\r\n     */\r\n    public set buttonRightStick(value) {\r\n        this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, DualShockButton.RightStick);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad up\r\n     */\r\n    public get dPadUp(): number {\r\n        return this._dPadUp;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad up\r\n     */\r\n    public set dPadUp(value) {\r\n        this._dPadUp = this._setDPadValue(value, this._dPadUp, DualShockDpad.Up);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad down\r\n     */\r\n    public get dPadDown(): number {\r\n        return this._dPadDown;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad down\r\n     */\r\n    public set dPadDown(value) {\r\n        this._dPadDown = this._setDPadValue(value, this._dPadDown, DualShockDpad.Down);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad left\r\n     */\r\n    public get dPadLeft(): number {\r\n        return this._dPadLeft;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad left\r\n     */\r\n    public set dPadLeft(value) {\r\n        this._dPadLeft = this._setDPadValue(value, this._dPadLeft, DualShockDpad.Left);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of D-pad right\r\n     */\r\n    public get dPadRight(): number {\r\n        return this._dPadRight;\r\n    }\r\n    /**\r\n     * Sets the value of D-pad right\r\n     */\r\n    public set dPadRight(value) {\r\n        this._dPadRight = this._setDPadValue(value, this._dPadRight, DualShockDpad.Right);\r\n    }\r\n\r\n    /**\r\n     * Force the gamepad to synchronize with device values\r\n     */\r\n    public update() {\r\n        super.update();\r\n        this.buttonCross = this.browserGamepad.buttons[0].value;\r\n        this.buttonCircle = this.browserGamepad.buttons[1].value;\r\n        this.buttonSquare = this.browserGamepad.buttons[2].value;\r\n        this.buttonTriangle = this.browserGamepad.buttons[3].value;\r\n        this.buttonL1 = this.browserGamepad.buttons[4].value;\r\n        this.buttonR1 = this.browserGamepad.buttons[5].value;\r\n        this.leftTrigger = this.browserGamepad.buttons[6].value;\r\n        this.rightTrigger = this.browserGamepad.buttons[7].value;\r\n        this.buttonShare = this.browserGamepad.buttons[8].value;\r\n        this.buttonOptions = this.browserGamepad.buttons[9].value;\r\n        this.buttonLeftStick = this.browserGamepad.buttons[10].value;\r\n        this.buttonRightStick = this.browserGamepad.buttons[11].value;\r\n        this.dPadUp = this.browserGamepad.buttons[12].value;\r\n        this.dPadDown = this.browserGamepad.buttons[13].value;\r\n        this.dPadLeft = this.browserGamepad.buttons[14].value;\r\n        this.dPadRight = this.browserGamepad.buttons[15].value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onButtonDownObservable.clear();\r\n        this.onButtonUpObservable.clear();\r\n        this.onPadDownObservable.clear();\r\n        this.onPadUpObservable.clear();\r\n    }\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            this._checkGamepadsStatus();\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { GamepadManager } from \"./gamepadManager\";\r\n\r\nimport { FreeCameraInputsManager } from \"../Cameras/freeCameraInputsManager\";\r\nimport { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { ArcRotateCameraGamepadInput } from \"../Cameras/Inputs/arcRotateCameraGamepadInput\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _gamepadManager: Nullable<GamepadManager>;\r\n\r\n        /**\r\n         * Gets the gamepad manager associated with the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/input/gamepads\r\n         */\r\n        gamepadManager: GamepadManager;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"gamepadManager\", {\r\n    get: function (this: Scene) {\r\n        if (!this._gamepadManager) {\r\n            this._gamepadManager = new GamepadManager(this);\r\n            let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD) as GamepadSystemSceneComponent;\r\n            if (!component) {\r\n                component = new GamepadSystemSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n\r\n        return this._gamepadManager;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../Cameras/freeCameraInputsManager\" {\r\n    /**\r\n     * Interface representing a free camera inputs manager\r\n     */\r\n    export interface FreeCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the FreeCameraInputsManager.\r\n         * @returns the FreeCameraInputsManager\r\n         */\r\n        addGamepad(): FreeCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the free camera inputs manager\r\n */\r\nFreeCameraInputsManager.prototype.addGamepad = function (): FreeCameraInputsManager {\r\n    this.add(new FreeCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\ndeclare module \"../Cameras/arcRotateCameraInputsManager\" {\r\n    /**\r\n     * Interface representing an arc rotate camera inputs manager\r\n     */\r\n    export interface ArcRotateCameraInputsManager {\r\n        /**\r\n         * Adds gamepad input support to the ArcRotateCamera InputManager.\r\n         * @returns the camera inputs manager\r\n         */\r\n        addGamepad(): ArcRotateCameraInputsManager;\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a gamepad to the arc rotate camera inputs manager\r\n */\r\nArcRotateCameraInputsManager.prototype.addGamepad = function (): ArcRotateCameraInputsManager {\r\n    this.add(new ArcRotateCameraGamepadInput());\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the gamepad scene component responsible to manage gamepads in a given scene\r\n */\r\nexport class GamepadSystemSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GAMEPAD;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for gamepads\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n        if (gamepadManager) {\r\n            gamepadManager.dispose();\r\n            this.scene._gamepadManager = null;\r\n        }\r\n    }\r\n\r\n    private _beforeCameraUpdate(): void {\r\n        const gamepadManager = this.scene._gamepadManager;\r\n\r\n        if (gamepadManager && gamepadManager._isMonitoring) {\r\n            gamepadManager._checkGamepadsStatus();\r\n        }\r\n    }\r\n}\r\n", "import { TouchCamera } from \"./touchCamera\";\r\nimport { Node } from \"../node\";\r\nimport type { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"./camera\";\r\n\r\nimport \"../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\r\n    // Forcing to use the Universal camera\r\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n * which still works and will still be found in many Playgrounds.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class UniversalCamera extends TouchCamera {\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadAngularSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadAngularSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadMoveSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadMoveSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n     * which still works and will still be found in many Playgrounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"UniversalCamera\";\r\n    }\r\n}\r\n\r\nCamera._CreateDefaultParsedCamera = (name: string, scene: Scene) => {\r\n    return new UniversalCamera(name, Vector3.Zero(), scene);\r\n};\r\n", "import { UniversalCamera } from \"./universalCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nNode.AddNodeConstructor(\"GamepadCamera\", (name, scene) => {\r\n    return () => new GamepadCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera. This is only here for back compat purpose.\r\n * Please use the UniversalCamera instead as both are identical.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class GamepadCamera extends UniversalCamera {\r\n    /**\r\n     * Instantiates a new Gamepad Camera\r\n     * This represents a FPS type of camera. This is only here for back compat purpose.\r\n     * Please use the UniversalCamera instead as both are identical.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GamepadCamera\";\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"anaglyphPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D leftSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 leftFrag=texture2D(leftSampler,vUV);leftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);vec4 rightFrag=texture2D(textureSampler,vUV);rightFrag=vec4(rightFrag.r,1.0,1.0,1.0);gl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const anaglyphPixelShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/anaglyph.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * Postprocess used to generate anaglyphic rendering\r\n */\r\nexport class AnaglyphPostProcess extends PostProcess {\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"AnaglyphPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new AnaglyphPostProcess\r\n     * @param name defines postprocess name\r\n     * @param options defines creation options or target ratio scale\r\n     * @param rigCameras defines cameras using this postprocess\r\n     * @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param engine defines hosting engine\r\n     * @param reusable defines if the postprocess will be reused multiple times per frame\r\n     */\r\n    constructor(name: string, options: number | PostProcessOptions, rigCameras: Camera[], samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"anaglyph\", null, [\"leftSampler\"], options, rigCameras[1], samplingMode, engine, reusable);\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"leftSampler\", this._passedProcess);\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnaglyphPostProcess\", AnaglyphPostProcess);\r\n", "import type { Camera } from \"../camera\";\r\nimport { PassPostProcess } from \"../../PostProcesses/passPostProcess\";\r\nimport { AnaglyphPostProcess } from \"../../PostProcesses/anaglyphPostProcess\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setStereoscopicAnaglyphRigMode(camera: Camera) {\r\n    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\r\n    camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + \"_anaglyph\", 1.0, camera._rigCameras);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode\";\r\n\r\nNode.AddNodeConstructor(\"AnaglyphArcRotateCamera\", (name, scene, options) => {\r\n    return () => new AnaglyphArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\r\n */\r\nexport class AnaglyphArcRotateCamera extends ArcRotateCamera {\r\n    /**\r\n     * Creates a new AnaglyphArcRotateCamera\r\n     * @param name defines camera name\r\n     * @param alpha defines alpha angle (in radians)\r\n     * @param beta defines beta angle (in radians)\r\n     * @param radius defines radius\r\n     * @param target defines camera target\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, scene?: Scene) {\r\n        super(name, alpha, beta, radius, target, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns AnaglyphArcRotateCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphArcRotateCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicAnaglyphRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode\";\r\n\r\nNode.AddNodeConstructor(\"AnaglyphFreeCamera\", (name, scene, options) => {\r\n    return () => new AnaglyphFreeCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate anaglyphic rendering (based on FreeCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\r\n */\r\nexport class AnaglyphFreeCamera extends FreeCamera {\r\n    /**\r\n     * Creates a new AnaglyphFreeCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns AnaglyphFreeCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphFreeCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicAnaglyphRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { GamepadCamera } from \"../../Cameras/gamepadCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode\";\r\n\r\nNode.AddNodeConstructor(\"AnaglyphGamepadCamera\", (name, scene, options) => {\r\n    return () => new AnaglyphGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate anaglyphic rendering (based on GamepadCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\r\n */\r\nexport class AnaglyphGamepadCamera extends GamepadCamera {\r\n    /**\r\n     * Creates a new AnaglyphGamepadCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns AnaglyphGamepadCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphGamepadCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicAnaglyphRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { UniversalCamera } from \"../../Cameras/universalCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\n\r\nimport { setStereoscopicAnaglyphRigMode } from \"../RigModes/stereoscopicAnaglyphRigMode\";\r\n\r\nNode.AddNodeConstructor(\"AnaglyphUniversalCamera\", (name, scene, options) => {\r\n    return () => new AnaglyphUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate anaglyphic rendering (based on UniversalCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#anaglyph-cameras\r\n */\r\nexport class AnaglyphUniversalCamera extends UniversalCamera {\r\n    /**\r\n     * Creates a new AnaglyphUniversalCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns AnaglyphUniversalCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphUniversalCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicAnaglyphRigMode(this);\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"stereoscopicInterlacePixelShader\";\nconst shader = `const vec3 TWO=vec3(2.0,2.0,2.0);varying vec2 vUV;uniform sampler2D camASampler;uniform sampler2D textureSampler;uniform vec2 stepSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{bool useCamA;bool useCamB;vec2 texCoord1;vec2 texCoord2;vec3 frag1;vec3 frag2;\n#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;useCamA=!useCamB;texCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);texCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\n#else\n#ifdef IS_STEREOSCOPIC_INTERLACED\nfloat rowNum=floor(vUV.y/stepSize.y);useCamA=mod(rowNum,2.0)==1.0;useCamB=mod(rowNum,2.0)==0.0;texCoord1=vec2(vUV.x,vUV.y);texCoord2=vec2(vUV.x,vUV.y);\n#else\nuseCamB=vUV.y>0.5;useCamA=!useCamB;texCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);texCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\n#endif\n#endif\nif (useCamB){frag1=texture2D(textureSampler,texCoord1).rgb;frag2=texture2D(textureSampler,texCoord2).rgb;}else if (useCamA){frag1=texture2D(camASampler ,texCoord1).rgb;frag2=texture2D(camASampler ,texCoord2).rgb;}else {discard;}\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const stereoscopicInterlacePixelShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Shaders/stereoscopicInterlace.fragment\";\r\n\r\n/**\r\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\r\n */\r\nexport class StereoscopicInterlacePostProcessI extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcessI\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcessI\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcessI\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be applied to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n     * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, isStereoscopicInterlaced: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(\r\n            name,\r\n            \"stereoscopicInterlace\",\r\n            [\"stepSize\"],\r\n            [\"camASampler\"],\r\n            1,\r\n            rigCameras[1],\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined\r\n        );\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}\r\n/**\r\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\r\n */\r\nexport class StereoscopicInterlacePostProcess extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcess\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be applied to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(\r\n            name,\r\n            \"stereoscopicInterlace\",\r\n            [\"stepSize\"],\r\n            [\"camASampler\"],\r\n            1,\r\n            rigCameras[1],\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined\r\n        );\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}\r\n", "import { Camera } from \"../camera\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport { PassPostProcess } from \"../../PostProcesses/passPostProcess\";\r\nimport { StereoscopicInterlacePostProcessI } from \"../../PostProcesses/stereoscopicInterlacePostProcess\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setStereoscopicRigMode(camera: Camera): void {\r\n    const isStereoscopicHoriz =\r\n        camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    const isCrossEye = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    const isInterlaced = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_INTERLACED;\r\n    // Use post-processors for interlacing\r\n    if (isInterlaced) {\r\n        camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\r\n        camera._rigCameras[1]._rigPostProcess = new StereoscopicInterlacePostProcessI(camera.name + \"_stereoInterlace\", camera._rigCameras, false, true);\r\n    }\r\n    // Otherwise, create appropriate viewports\r\n    else {\r\n        camera._rigCameras[isCrossEye ? 1 : 0].viewport = new Viewport(0, 0, isStereoscopicHoriz ? 0.5 : 1.0, isStereoscopicHoriz ? 1.0 : 0.5);\r\n        camera._rigCameras[isCrossEye ? 0 : 1].viewport = new Viewport(\r\n            isStereoscopicHoriz ? 0.5 : 0,\r\n            isStereoscopicHoriz ? 0 : 0.5,\r\n            isStereoscopicHoriz ? 0.5 : 1.0,\r\n            isStereoscopicHoriz ? 1.0 : 0.5\r\n        );\r\n    }\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode\";\r\n\r\nNode.AddNodeConstructor(\"StereoscopicArcRotateCamera\", (name, scene, options) => {\r\n    return () => new StereoscopicArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicArcRotateCamera extends ArcRotateCamera {\r\n    /**\r\n     * Creates a new StereoscopicArcRotateCamera\r\n     * @param name defines camera name\r\n     * @param alpha defines alpha angle (in radians)\r\n     * @param beta defines beta angle (in radians)\r\n     * @param radius defines radius\r\n     * @param target defines camera target\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene?: Scene) {\r\n        super(name, alpha, beta, radius, target, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\r\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\r\n            interaxialDistance: interaxialDistance,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicArcRotateCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicArcRotateCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode\";\r\n\r\nNode.AddNodeConstructor(\"StereoscopicFreeCamera\", (name, scene, options) => {\r\n    return () => new StereoscopicFreeCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering (based on FreeCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicFreeCamera extends FreeCamera {\r\n    /**\r\n     * Creates a new StereoscopicFreeCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\r\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\r\n            interaxialDistance: interaxialDistance,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicFreeCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicFreeCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { GamepadCamera } from \"../../Cameras/gamepadCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode\";\r\n\r\nNode.AddNodeConstructor(\"StereoscopicGamepadCamera\", (name, scene, options) => {\r\n    return () => new StereoscopicGamepadCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering (based on GamepadCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicGamepadCamera extends GamepadCamera {\r\n    /**\r\n     * Creates a new StereoscopicGamepadCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\r\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\r\n            interaxialDistance: interaxialDistance,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicGamepadCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicGamepadCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { UniversalCamera } from \"../../Cameras/universalCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setStereoscopicRigMode } from \"../RigModes/stereoscopicRigMode\";\r\n\r\nNode.AddNodeConstructor(\"StereoscopicFreeCamera\", (name, scene, options) => {\r\n    return () => new StereoscopicUniversalCamera(name, Vector3.Zero(), options.interaxial_distance, options.isStereoscopicSideBySide, scene);\r\n});\r\n/**\r\n * Camera used to simulate stereoscopic rendering (based on UniversalCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicUniversalCamera extends UniversalCamera {\r\n    /**\r\n     * Creates a new StereoscopicUniversalCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param interaxialDistance defines distance between each color axis\r\n     * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.interaxialDistance = interaxialDistance;\r\n        this.isStereoscopicSideBySide = isStereoscopicSideBySide;\r\n        this.setCameraRigMode(isStereoscopicSideBySide ? Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\r\n            interaxialDistance: interaxialDistance,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicUniversalCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicUniversalCamera\";\r\n    }\r\n\r\n    protected _setRigMode = () => setStereoscopicRigMode(this);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { UniversalCamera } from \"../../Cameras/universalCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { TargetCamera } from \"../targetCamera\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicScreenUniversalCamera extends UniversalCamera {\r\n    private _distanceToProjectionPlane: number;\r\n    private _distanceBetweenEyes: number;\r\n\r\n    public set distanceBetweenEyes(newValue: number) {\r\n        this._distanceBetweenEyes = newValue;\r\n    }\r\n\r\n    /**\r\n     * distance between the eyes\r\n     */\r\n    public get distanceBetweenEyes(): number {\r\n        return this._distanceBetweenEyes;\r\n    }\r\n\r\n    public set distanceToProjectionPlane(newValue: number) {\r\n        this._distanceToProjectionPlane = newValue;\r\n    }\r\n\r\n    /**\r\n     * Distance to projection plane (should be the same units the like distance between the eyes)\r\n     */\r\n    public get distanceToProjectionPlane(): number {\r\n        return this._distanceToProjectionPlane;\r\n    }\r\n    /**\r\n     * Creates a new StereoscopicScreenUniversalCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param scene defines the hosting scene\r\n     * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\r\n     * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, distanceToProjectionPlane: number = 1, distanceBetweenEyes: number = 0.065) {\r\n        super(name, position, scene);\r\n        this._distanceBetweenEyes = distanceBetweenEyes;\r\n        this._distanceToProjectionPlane = distanceToProjectionPlane;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\r\n            stereoHalfAngle: 0,\r\n        });\r\n        this._cameraRigParams.stereoHalfAngle = 0;\r\n        this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicScreenUniversalCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicUniversalCamera\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRigCamera(name: string): Nullable<Camera> {\r\n        const camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\r\n        const transform = new TransformNode(\"tm_\" + name, this.getScene());\r\n        camera.parent = transform;\r\n        transform.setPivotMatrix(Matrix.Identity(), false);\r\n        camera.isRigCamera = true;\r\n        camera.rigParent = this;\r\n        return camera;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            const cam = this._rigCameras[cameraIndex] as TargetCamera;\r\n            cam.minZ = this.minZ;\r\n            cam.maxZ = this.maxZ;\r\n            cam.fov = this.fov;\r\n            cam.upVector.copyFrom(this.upVector);\r\n            if (cam.rotationQuaternion) {\r\n                cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n            } else {\r\n                cam.rotation.copyFrom(this.rotation);\r\n            }\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n\r\n    private _updateCamera(camera: TargetCamera, cameraIndex: number) {\r\n        const b = this.distanceBetweenEyes / 2;\r\n        const z = b / this.distanceToProjectionPlane;\r\n        camera.position.copyFrom(this.position);\r\n        camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\r\n        const transform = camera.parent as TransformNode;\r\n        const m = transform.getPivotMatrix();\r\n        m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\r\n        m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\r\n        transform.setPivotMatrix(m, false);\r\n    }\r\n\r\n    protected _setRigMode() {\r\n        this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\r\n        this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n}\r\n", "import { FreeCamera } from \"./freeCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nimport \"./Inputs/freeCameraVirtualJoystickInput\";\r\n\r\nNode.AddNodeConstructor(\"VirtualJoysticksCamera\", (name, scene) => {\r\n    return () => new VirtualJoysticksCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * It is identical to the Free Camera and simply adds by default a virtual joystick.\r\n * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#virtual-joysticks-camera\r\n */\r\nexport class VirtualJoysticksCamera extends FreeCamera {\r\n    /**\r\n     * Instantiates a VirtualJoysticksCamera. It can be useful in First Person Shooter game for instance.\r\n     * It is identical to the Free Camera and simply adds by default a virtual joystick.\r\n     * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#virtual-joysticks-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addVirtualJoystick();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"VirtualJoysticksCamera\";\r\n    }\r\n}\r\n", "import { Matrix } from \"../../Maths/math.vector\";\r\n/**\r\n * This represents all the required metrics to create a VR camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#device-orientation-camera\r\n */\r\nexport class VRCameraMetrics {\r\n    /**\r\n     * Define the horizontal resolution off the screen.\r\n     */\r\n    public hResolution: number;\r\n    /**\r\n     * Define the vertical resolution off the screen.\r\n     */\r\n    public vResolution: number;\r\n    /**\r\n     * Define the horizontal screen size.\r\n     */\r\n    public hScreenSize: number;\r\n    /**\r\n     * Define the vertical screen size.\r\n     */\r\n    public vScreenSize: number;\r\n    /**\r\n     * Define the vertical screen center position.\r\n     */\r\n    public vScreenCenter: number;\r\n    /**\r\n     * Define the distance of the eyes to the screen.\r\n     */\r\n    public eyeToScreenDistance: number;\r\n    /**\r\n     * Define the distance between both lenses\r\n     */\r\n    public lensSeparationDistance: number;\r\n    /**\r\n     * Define the distance between both viewer's eyes.\r\n     */\r\n    public interpupillaryDistance: number;\r\n    /**\r\n     * Define the distortion factor of the VR postprocess.\r\n     * Please, touch with care.\r\n     */\r\n    public distortionK: number[];\r\n    /**\r\n     * Define the chromatic aberration correction factors for the VR post process.\r\n     */\r\n    public chromaAbCorrection: number[];\r\n    /**\r\n     * Define the scale factor of the post process.\r\n     * The smaller the better but the slower.\r\n     */\r\n    public postProcessScaleFactor: number;\r\n    /**\r\n     * Define an offset for the lens center.\r\n     */\r\n    public lensCenterOffset: number;\r\n    /**\r\n     * Define if the current vr camera should compensate the distortion of the lens or not.\r\n     */\r\n    public compensateDistortion = true;\r\n\r\n    /**\r\n     * Defines if multiview should be enabled when rendering (Default: false)\r\n     */\r\n    public multiviewEnabled = false;\r\n\r\n    /**\r\n     * Gets the rendering aspect ratio based on the provided resolutions.\r\n     */\r\n    public get aspectRatio(): number {\r\n        return this.hResolution / (2 * this.vResolution);\r\n    }\r\n\r\n    /**\r\n     * Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.\r\n     */\r\n    public get aspectRatioFov(): number {\r\n        return 2 * Math.atan((this.postProcessScaleFactor * this.vScreenSize) / (2 * this.eyeToScreenDistance));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get leftHMatrix(): Matrix {\r\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\r\n        const h = (4 * meters) / this.hScreenSize;\r\n\r\n        return Matrix.Translation(h, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get rightHMatrix(): Matrix {\r\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\r\n        const h = (4 * meters) / this.hScreenSize;\r\n\r\n        return Matrix.Translation(-h, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get leftPreViewMatrix(): Matrix {\r\n        return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get rightPreViewMatrix(): Matrix {\r\n        return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Get the default VRMetrics based on the most generic setup.\r\n     * @returns the default vr metrics\r\n     */\r\n    public static GetDefault(): VRCameraMetrics {\r\n        const result = new VRCameraMetrics();\r\n\r\n        result.hResolution = 1280;\r\n        result.vResolution = 800;\r\n        result.hScreenSize = 0.149759993;\r\n        result.vScreenSize = 0.0935999975;\r\n        result.vScreenCenter = 0.0467999987;\r\n        result.eyeToScreenDistance = 0.0410000011;\r\n        result.lensSeparationDistance = 0.063500002;\r\n        result.interpupillaryDistance = 0.064000003;\r\n        result.distortionK = [1.0, 0.219999999, 0.239999995, 0.0];\r\n        result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0.0];\r\n        result.postProcessScaleFactor = 1.714605507808412;\r\n        result.lensCenterOffset = 0.151976421;\r\n\r\n        return result;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"vrDistortionCorrectionPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 LensCenter;uniform vec2 Scale;uniform vec2 ScaleIn;uniform vec4 HmdWarpParam;vec2 HmdWarp(vec2 in01) {vec2 theta=(in01-LensCenter)*ScaleIn; \nfloat rSq=theta.x*theta.x+theta.y*theta.y;vec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);return LensCenter+Scale*rvector;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 tc=HmdWarp(vUV);if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);else{gl_FragColor=texture2D(textureSampler,tc);}}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const vrDistortionCorrectionPixelShader = { name, shader };\n", "import { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { VRCameraMetrics } from \"../Cameras/VR/vrCameraMetrics\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { PostProcess } from \"./postProcess\";\r\n\r\nimport \"../Shaders/vrDistortionCorrection.fragment\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * VRDistortionCorrectionPostProcess used for mobile VR\r\n */\r\nexport class VRDistortionCorrectionPostProcess extends PostProcess {\r\n    private _isRightEye: boolean;\r\n    private _distortionFactors: number[];\r\n    private _postProcessScaleFactor: number;\r\n    private _lensCenterOffset: number;\r\n    private _scaleIn: Vector2;\r\n    private _scaleFactor: Vector2;\r\n    private _lensCenter: Vector2;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"VRDistortionCorrectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDistortionCorrectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes the VRDistortionCorrectionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param isRightEye If this is for the right eye distortion\r\n     * @param vrMetrics All the required metrics for the VR camera\r\n     */\r\n    constructor(name: string, camera: Nullable<Camera>, isRightEye: boolean, vrMetrics: VRCameraMetrics) {\r\n        super(name, \"vrDistortionCorrection\", [\"LensCenter\", \"Scale\", \"ScaleIn\", \"HmdWarpParam\"], null, vrMetrics.postProcessScaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);\r\n\r\n        this._isRightEye = isRightEye;\r\n        this._distortionFactors = vrMetrics.distortionK;\r\n        this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;\r\n        this._lensCenterOffset = vrMetrics.lensCenterOffset;\r\n        this.adaptScaleToCurrentViewport = true;\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._scaleIn = new Vector2(2, 2 / this.aspectRatio);\r\n            this._scaleFactor = new Vector2(0.5 * (1 / this._postProcessScaleFactor), 0.5 * (1 / this._postProcessScaleFactor) * this.aspectRatio);\r\n            this._lensCenter = new Vector2(this._isRightEye ? 0.5 - this._lensCenterOffset * 0.5 : 0.5 + this._lensCenterOffset * 0.5, 0.5);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"LensCenter\", this._lensCenter.x, this._lensCenter.y);\r\n            effect.setFloat2(\"Scale\", this._scaleFactor.x, this._scaleFactor.y);\r\n            effect.setFloat2(\"ScaleIn\", this._scaleIn.x, this._scaleIn.y);\r\n            effect.setFloat4(\"HmdWarpParam\", this._distortionFactors[0], this._distortionFactors[1], this._distortionFactors[2], this._distortionFactors[3]);\r\n        });\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"vrMultiviewToSingleviewPixelShader\";\nconst shader = `precision mediump sampler2DArray;varying vec2 vUV;uniform sampler2DArray multiviewSampler;uniform int imageIndex;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{gl_FragColor=texture2D(multiviewSampler,vec3(vUV,imageIndex));}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const vrMultiviewToSingleviewPixelShader = { name, shader };\n", "import { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Renders to multiple views with a single draw call\r\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\r\n */\r\nexport class MultiviewRenderTarget extends RenderTargetTexture {\r\n    public set samples(value: number) {\r\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\r\n        this._samples = value;\r\n    }\r\n\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Creates a multiview render target\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"multiview rtt\", size, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!.getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n        this.samples = this._getEngine()!.getCaps().maxSamples || this.samples;\r\n        this._texture.samples = this._samples;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindMultiviewFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Scene } from \"../../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget\";\r\nimport { Frustum } from \"../../Maths/math.frustum\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Creates a new multiview render target\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @returns the created multiview render target wrapper\r\n         */\r\n        createMultiviewRenderTargetTexture(width: number, height: number, colorTexture?: WebGLTexture, depthStencilTexture?: WebGLTexture): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Binds a multiview render target wrapper to be drawn to\r\n         * @param multiviewTexture render target wrapper to bind\r\n         */\r\n        bindMultiviewFramebuffer(multiviewTexture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Binds a Space Warp render target wrapper to be drawn to\r\n         * @param spaceWarpTexture render target wrapper to bind\r\n         */\r\n        bindSpaceWarpFramebuffer(spaceWarpTexture: RenderTargetWrapper): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.createMultiviewRenderTargetTexture = function (width: number, height: number, colorTexture?: WebGLTexture, depthStencilTexture?: WebGLTexture) {\r\n    const gl = this._gl;\r\n\r\n    if (!this.getCaps().multiview) {\r\n        throw \"Multiview is not supported\";\r\n    }\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, { width, height }) as WebGLRenderTargetWrapper;\r\n\r\n    rtWrapper._framebuffer = gl.createFramebuffer();\r\n\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.isMultiview = true;\r\n\r\n    if (!colorTexture) {\r\n        colorTexture = gl.createTexture() as WebGLTexture;\r\n        gl.bindTexture(gl.TEXTURE_2D_ARRAY, colorTexture);\r\n        (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\r\n    }\r\n\r\n    rtWrapper._colorTextureArray = colorTexture;\r\n\r\n    if (!depthStencilTexture) {\r\n        depthStencilTexture = gl.createTexture() as WebGLTexture;\r\n        gl.bindTexture(gl.TEXTURE_2D_ARRAY, depthStencilTexture);\r\n        (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, (gl as any).DEPTH24_STENCIL8, width, height, 2);\r\n    }\r\n\r\n    rtWrapper._depthStencilTextureArray = depthStencilTexture;\r\n\r\n    internalTexture.isReady = true;\r\n\r\n    rtWrapper.setTextures(internalTexture);\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture: RenderTargetWrapper) {\r\n    const multiviewTexture = _multiviewTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\r\n    if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\r\n        if (this.getCaps().oculusMultiview) {\r\n            ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\r\n            ext.framebufferTextureMultisampleMultiviewOVR(\r\n                gl.DRAW_FRAMEBUFFER,\r\n                gl.DEPTH_STENCIL_ATTACHMENT,\r\n                multiviewTexture._depthStencilTextureArray,\r\n                0,\r\n                multiviewTexture.samples,\r\n                0,\r\n                2\r\n            );\r\n        } else {\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\r\n        }\r\n    } else {\r\n        throw \"Invalid multiview frame buffer\";\r\n    }\r\n};\r\n\r\nEngine.prototype.bindSpaceWarpFramebuffer = function (_spaceWarpTexture: RenderTargetWrapper) {\r\n    const spaceWarpTexture = _spaceWarpTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(spaceWarpTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, spaceWarpTexture._framebuffer);\r\n    if (spaceWarpTexture._colorTextureArray && spaceWarpTexture._depthStencilTextureArray) {\r\n        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, spaceWarpTexture._colorTextureArray, 0, 0, 2);\r\n        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, spaceWarpTexture._depthStencilTextureArray, 0, 0, 2);\r\n    } else {\r\n        throw new Error(\"Invalid Space Warp framebuffer\");\r\n    }\r\n};\r\n\r\ndeclare module \"../../Cameras/camera\" {\r\n    export interface Camera {\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _useMultiviewToSingleView: boolean;\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _multiviewTexture: Nullable<RenderTargetTexture>;\r\n\r\n        /**\r\n         * @internal\r\n         * For WebXR cameras that are rendering to multiview texture arrays.\r\n         */\r\n        _renderingMultiview: boolean;\r\n\r\n        /**\r\n         * @internal\r\n         * ensures the multiview texture of the camera exists and has the specified width/height\r\n         * @param width height to set on the multiview texture\r\n         * @param height width to set on the multiview texture\r\n         */\r\n        _resizeOrCreateMultiviewTexture(width: number, height: number): void;\r\n    }\r\n}\r\n\r\nCamera.prototype._useMultiviewToSingleView = false;\r\n\r\nCamera.prototype._multiviewTexture = null;\r\n\r\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width: number, height: number) {\r\n    if (!this._multiviewTexture) {\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\r\n        this._multiviewTexture.dispose();\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    }\r\n};\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _transformMatrixR: Matrix;\r\n        /** @internal */\r\n        _multiviewSceneUbo: Nullable<UniformBuffer>;\r\n        /** @internal */\r\n        _createMultiviewUbo(): void;\r\n        /** @internal */\r\n        _updateMultiviewUbo(viewR?: Matrix, projectionR?: Matrix): void;\r\n        /** @internal */\r\n        _renderMultiviewToSingleView(camera: Camera): void;\r\n    }\r\n}\r\n\r\nfunction createMultiviewUbo(engine: Engine, name?: string) {\r\n    const ubo = new UniformBuffer(engine, undefined, true, name);\r\n    ubo.addUniform(\"viewProjection\", 16);\r\n    ubo.addUniform(\"viewProjectionR\", 16);\r\n    ubo.addUniform(\"view\", 16);\r\n    ubo.addUniform(\"projection\", 16);\r\n    ubo.addUniform(\"vEyePosition\", 4);\r\n    return ubo;\r\n}\r\n\r\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\r\n\r\nScene.prototype._transformMatrixR = Matrix.Zero();\r\nScene.prototype._multiviewSceneUbo = null;\r\nScene.prototype._createMultiviewUbo = function () {\r\n    this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\r\n};\r\nScene.prototype.createSceneUniformBuffer = function (name?: string): UniformBuffer {\r\n    if (this._multiviewSceneUbo) {\r\n        return createMultiviewUbo(this.getEngine(), name);\r\n    }\r\n    return currentCreateSceneUniformBuffer.bind(this)(name);\r\n};\r\nScene.prototype._updateMultiviewUbo = function (viewR?: Matrix, projectionR?: Matrix) {\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, this._transformMatrixR);\r\n    }\r\n\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\r\n        Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\r\n    }\r\n\r\n    if (this._multiviewSceneUbo) {\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\r\n        this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n        this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\r\n    }\r\n};\r\nScene.prototype._renderMultiviewToSingleView = function (camera: Camera) {\r\n    // Multiview is only able to be displayed directly for API's such as webXR\r\n    // This displays a multiview image by rendering to the multiview image and then\r\n    // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\r\n\r\n    // Render to a multiview texture\r\n    camera._resizeOrCreateMultiviewTexture(\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true),\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true)\r\n    );\r\n    if (!this._multiviewSceneUbo) {\r\n        this._createMultiviewUbo();\r\n    }\r\n    camera.outputRenderTarget = camera._multiviewTexture;\r\n    this._renderForCamera(camera);\r\n    camera.outputRenderTarget = null;\r\n\r\n    // Consume the multiview texture through a shader for each eye\r\n    for (let index = 0; index < camera._rigCameras.length; index++) {\r\n        const engine = this.getEngine();\r\n        this._activeCamera = camera._rigCameras[index];\r\n        engine.setViewport(this._activeCamera.viewport);\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._prepareFrame();\r\n            this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\r\n        }\r\n    }\r\n};\r\n", "import type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { PostProcess } from \"./postProcess\";\r\n\r\nimport \"../Shaders/vrMultiviewToSingleview.fragment\";\r\nimport \"../Engines/Extensions/engine.multiview\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR\r\n * This will not be used for webXR as it supports displaying texture arrays directly\r\n */\r\nexport class VRMultiviewToSingleviewPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"VRMultiviewToSingleviewPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRMultiviewToSingleviewPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a VRMultiviewToSingleview\r\n     * @param name name of the post process\r\n     * @param camera camera to be applied to\r\n     * @param scaleFactor scaling factor to the size of the output texture\r\n     */\r\n    constructor(name: string, camera: Nullable<Camera>, scaleFactor: number) {\r\n        super(name, \"vrMultiviewToSingleview\", [\"imageIndex\"], [\"multiviewSampler\"], scaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);\r\n\r\n        const cam = camera ?? this.getCamera();\r\n        this.onSizeChangedObservable.add(() => {});\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (cam._scene.activeCamera && cam._scene.activeCamera.isLeftCamera) {\r\n                effect.setInt(\"imageIndex\", 0);\r\n            } else {\r\n                effect.setInt(\"imageIndex\", 1);\r\n            }\r\n            effect.setTexture(\"multiviewSampler\", cam._multiviewTexture);\r\n        });\r\n    }\r\n}\r\n", "import type { Camera } from \"../camera\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { VRDistortionCorrectionPostProcess } from \"../../PostProcesses/vrDistortionCorrectionPostProcess\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { VRCameraMetrics } from \"../VR/vrCameraMetrics\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setVRRigMode(camera: Camera, rigParams: any) {\r\n    const metrics = <VRCameraMetrics>rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();\r\n\r\n    camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\r\n    camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\r\n    camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;\r\n\r\n    camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\r\n    camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\r\n    camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;\r\n\r\n    // For multiview camera\r\n    // First multiview will be rendered to camera._multiviewTexture\r\n    // Then this postprocess will run on each eye to copy the right texture to each eye\r\n    if (metrics.multiviewEnabled) {\r\n        if (!camera.getScene().getEngine().getCaps().multiview) {\r\n            Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n            metrics.multiviewEnabled = false;\r\n        } else {\r\n            camera._useMultiviewToSingleView = true;\r\n            camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", camera, metrics.postProcessScaleFactor);\r\n        }\r\n    }\r\n\r\n    if (metrics.compensateDistortion) {\r\n        camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", camera._rigCameras[0], false, metrics);\r\n        camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", camera._rigCameras[1], true, metrics);\r\n    }\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { VRCameraMetrics } from \"./vrCameraMetrics\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setVRRigMode } from \"../RigModes/vrRigMode\";\r\n\r\nimport \"../Inputs/arcRotateCameraVRDeviceOrientationInput\";\r\n\r\nNode.AddNodeConstructor(\"VRDeviceOrientationArcRotateCamera\", (name, scene) => {\r\n    return () => new VRDeviceOrientationArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate VR rendering (based on ArcRotateCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\r\n */\r\nexport class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {\r\n    /**\r\n     * Creates a new VRDeviceOrientationArcRotateCamera\r\n     * @param name defines camera name\r\n     * @param alpha defines the camera rotation along the longitudinal axis\r\n     * @param beta defines the camera rotation along the latitudinal axis\r\n     * @param radius defines the camera distance from its target\r\n     * @param target defines the camera target\r\n     * @param scene defines the scene the camera belongs to\r\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\r\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\r\n     */\r\n    constructor(\r\n        name: string,\r\n        alpha: number,\r\n        beta: number,\r\n        radius: number,\r\n        target: Vector3,\r\n        scene?: Scene,\r\n        compensateDistortion = true,\r\n        vrCameraMetrics: VRCameraMetrics = VRCameraMetrics.GetDefault()\r\n    ) {\r\n        super(name, alpha, beta, radius, target, scene);\r\n\r\n        vrCameraMetrics.compensateDistortion = compensateDistortion;\r\n        this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\r\n\r\n        this.inputs.addVRDeviceOrientation();\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns VRDeviceOrientationArcRotateCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDeviceOrientationArcRotateCamera\";\r\n    }\r\n\r\n    protected _setRigMode = (rigParams: any) => setVRRigMode(this, rigParams);\r\n}\r\n", "import { Camera } from \"../../Cameras/camera\";\r\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera\";\r\nimport { VRCameraMetrics } from \"./vrCameraMetrics\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setVRRigMode } from \"../RigModes/vrRigMode\";\r\n\r\nNode.AddNodeConstructor(\"VRDeviceOrientationFreeCamera\", (name, scene) => {\r\n    return () => new VRDeviceOrientationFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate VR rendering (based on FreeCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\r\n */\r\nexport class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {\r\n    /**\r\n     * Creates a new VRDeviceOrientationFreeCamera\r\n     * @param name defines camera name\r\n     * @param position defines the start position of the camera\r\n     * @param scene defines the scene the camera belongs to\r\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\r\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, compensateDistortion = true, vrCameraMetrics: VRCameraMetrics = VRCameraMetrics.GetDefault()) {\r\n        super(name, position, scene);\r\n\r\n        vrCameraMetrics.compensateDistortion = compensateDistortion;\r\n        this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns VRDeviceOrientationFreeCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDeviceOrientationFreeCamera\";\r\n    }\r\n\r\n    protected _setRigMode = (rigParams: any) => setVRRigMode(this, rigParams);\r\n}\r\n", "import { VRDeviceOrientationFreeCamera } from \"./vrDeviceOrientationFreeCamera\";\r\nimport { VRCameraMetrics } from \"./vrCameraMetrics\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setVRRigMode } from \"../RigModes/vrRigMode\";\r\n\r\nimport \"../../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"VRDeviceOrientationGamepadCamera\", (name, scene) => {\r\n    return () => new VRDeviceOrientationGamepadCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\r\n */\r\nexport class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {\r\n    /**\r\n     * Creates a new VRDeviceOrientationGamepadCamera\r\n     * @param name defines camera name\r\n     * @param position defines the start position of the camera\r\n     * @param scene defines the scene the camera belongs to\r\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\r\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, compensateDistortion = true, vrCameraMetrics: VRCameraMetrics = VRCameraMetrics.GetDefault()) {\r\n        super(name, position, scene, compensateDistortion, vrCameraMetrics);\r\n\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns VRDeviceOrientationGamepadCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDeviceOrientationGamepadCamera\";\r\n    }\r\n\r\n    protected _setRigMode = (rigParams: any) => setVRRigMode(this, rigParams);\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    if (format) {\r\n        texture.format = format;\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport {\r\n    Animation,\r\n    _staticOffsetValueColor3,\r\n    _staticOffsetValueColor4,\r\n    _staticOffsetValueQuaternion,\r\n    _staticOffsetValueSize,\r\n    _staticOffsetValueVector2,\r\n    _staticOffsetValueVector3,\r\n} from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target[targetPropertyPath[0]];\r\n\r\n            for (let index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\r\n                if (this._currentValue.addToRef) {\r\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\r\n                } else {\r\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\r\n                }\r\n            } else {\r\n                destination[this._targetPath] = this._currentValue;\r\n            }\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, -1);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const frameRange = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n        let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n        let highLimitValue = 0;\r\n\r\n        // Apply the yoyo function if required\r\n        if (loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO) {\r\n            const position = (absoluteFrame - from) / frameRange;\r\n\r\n            // Apply the yoyo curve\r\n            const yoyoPosition = Math.abs(Math.sin(position * Math.PI));\r\n\r\n            // Map the yoyo position back to the range\r\n            absoluteFrame = yoyoPosition * frameRange + from;\r\n        }\r\n\r\n        this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n        this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n        if (!loop && to >= from && absoluteFrame >= frameRange) {\r\n            // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && from >= to && absoluteFrame <= frameRange) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            const keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                const fromValue = animation._interpolate(from, this._animationState);\r\n                const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    offsetValue = _staticOffsetValueColor4;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + frameRange * hostNormalizedFrame;\r\n        } else {\r\n            if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n            } else {\r\n                currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n            }\r\n        }\r\n\r\n        const events = this._events;\r\n\r\n        // Reset event/state if looping\r\n        if ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame)) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset event, the animation is looping\r\n                    events[index].isDone = false;\r\n                }\r\n            }\r\n\r\n            this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children: Bone[] = [];\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @internal Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix; // transformation of the bone, in local space\r\n    private _absoluteMatrix: Matrix; // transformation of the bone, in world space (relative to the skeleton root)\r\n    private _bindMatrix: Matrix; // the bind matrix, in local space\r\n    private _absoluteBindMatrix: Matrix; // the bind matrix, in world space (relative to the skeleton root)\r\n    private _absoluteInverseBindMatrix: Matrix; // the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n    private _finalMatrix: Matrix; // the final matrix used to transform vertices of the mesh according to the bone, in world space (relative to the skeleton root). It is the multiplication of _absoluteInverseBindMatrix with _absoluteMatrix.\r\n    private _restMatrix: Matrix; // a matrix for the exclusive use of the end user (not used internally by the framework), in local space\r\n    private _scalingDeterminant = 1;\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @internal */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @internal */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    set _matrix(value: Matrix) {\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix (default: identity)\r\n     * @param restMatrix defines the rest matrix (default: localMatrix)\r\n     * @param bindMatrix defines the bind matrix (default: localMatrix)\r\n     * @param index defines index of the bone in the hierarchy (default: null)\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restMatrix: Nullable<Matrix> = null,\r\n        bindMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene());\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix?.clone() ?? Matrix.Identity();\r\n        this._restMatrix = restMatrix ?? this._localMatrix.clone();\r\n        this._bindMatrix = bindMatrix ?? this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        this._absoluteMatrix = new Matrix();\r\n        this._absoluteBindMatrix = new Matrix();\r\n        this._absoluteInverseBindMatrix = new Matrix();\r\n        this._finalMatrix = new Matrix();\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        this._updateAbsoluteBindMatrices();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the children of the bone\r\n     * @returns an array containing the children of the bone (can be empty if the bone has no children)\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateAbsoluteBindMatrices: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns the local matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     */\r\n    public getBindMatrix(): Matrix {\r\n        return this._bindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix.\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     */\r\n    public getRestMatrix(): Matrix {\r\n        return this._restMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     * @deprecated Please use getRestMatrix instead\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this.getRestMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest matrix to set for this bone\r\n     */\r\n    public setRestMatrix(matrix: Matrix): void {\r\n        this._restMatrix.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest to set for this bone\r\n     * @deprecated Please use setRestMatrix instead\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this.setRestMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * This will trigger a recomputation of the absolute bind and absolute inverse bind matrices for this bone and its children\r\n     * Note that the local matrix will also be set with the matrix passed in parameter!\r\n     * @param matrix the local-space bind matrix to set for this bone\r\n     */\r\n    public setBindMatrix(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * @param matrix the local-space bind to set for this bone\r\n     * @deprecated Please use setBindMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.setBindMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     */\r\n    public getFinalMatrix(): Matrix {\r\n        return this._finalMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @deprecated Please use getFinalMatrix instead\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        return this.getFinalMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to the rest matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestMatrix().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restMatrix;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     */\r\n    public getAbsoluteInverseBindMatrix(): Matrix {\r\n        return this._absoluteInverseBindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     * @deprecated Please use getAbsoluteInverseBindMatrix instead\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this.getAbsoluteInverseBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     */\r\n    public getAbsoluteMatrix(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     * @deprecated Please use getAbsoluteMatrix instead\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is overwritten by the transform of the node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the bind (and optionally the local) matrix\r\n     * @param bindMatrix defines the new matrix to set to the bind/local matrix, in local space\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be recomputed (default: true)\r\n     * @param updateLocalMatrix defines if the local matrix should also be updated with the matrix passed in parameter (default: true)\r\n     */\r\n    public updateMatrix(bindMatrix: Matrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true): void {\r\n        this._bindMatrix.copyFrom(bindMatrix);\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = bindMatrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateAbsoluteBindMatrices(bindMatrix?: Matrix, updateChildren = true): void {\r\n        if (!bindMatrix) {\r\n            bindMatrix = this._bindMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);\r\n        } else {\r\n            this._absoluteBindMatrix.copyFrom(bindMatrix);\r\n        }\r\n\r\n        this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateAbsoluteBindMatrices();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    private _updatePosition(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode, translationMode = true): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, vec.x);\r\n                lm.addAtIndex(13, vec.y);\r\n                lm.addAtIndex(14, vec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n            }\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            if (translationMode) {\r\n                tmat.setTranslationFromFloats(0, 0, 0);\r\n            }\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, tvec.x);\r\n                lm.addAtIndex(13, tvec.y);\r\n                lm.addAtIndex(14, tvec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);\r\n            }\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(vec, space, tNode, true);\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(position, space, tNode, false);\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteMatrix());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteMatrices();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            let tmat = Bone._TmpMats[0];\r\n\r\n            if (tNode && wm) {\r\n                tmat.copyFrom(this.getAbsoluteMatrix());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteMatrix();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     */\r\n    public computeAbsoluteMatrices(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);\r\n        } else {\r\n            this._absoluteMatrix.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteMatrices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this.computeAbsoluteMatrices();\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const mat = Bone._TmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restMatrix for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestMatrix(this.getLocalMatrix());\r\n    }\r\n}\r\n", "import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (this._weight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForMatrices(holder: {\r\n            totalWeight: number;\r\n            totalAdditiveWeight: number;\r\n            animations: RuntimeAnimation[];\r\n            additiveAnimations: RuntimeAnimation[];\r\n            originalValue: Matrix;\r\n        }): any;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForQuaternions(\r\n            holder: {\r\n                totalWeight: number;\r\n                totalAdditiveWeight: number;\r\n                animations: RuntimeAnimation[];\r\n                additiveAnimations: RuntimeAnimation[];\r\n                originalValue: Quaternion;\r\n            },\r\n            refQuaternion: Quaternion\r\n        ): Quaternion;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindings(): void;\r\n\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n\r\n        /**\r\n         * Gets the current delta time used by animation engine\r\n         */\r\n        deltaTime: number;\r\n    }\r\n}\r\n\r\nScene.prototype._animate = function (): void {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n\r\n    // Getting time\r\n    const now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n\r\n    const animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n\r\n    this._animationTime += this.deltaTime;\r\n    const animationTime = this._animationTime;\r\n\r\n    for (let index = 0; index < animatables.length; index++) {\r\n        const animatable = animatables[index];\r\n\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\n\r\nScene.prototype.sortActiveAnimatables = function (): void {\r\n    this._activeAnimatables.sort((a, b) => {\r\n        return a.playOrder - b.playOrder;\r\n    });\r\n};\r\n\r\nScene.prototype.beginWeightedAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    weight = 1.0,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n\r\n    return returnedAnimatable;\r\n};\r\n\r\nScene.prototype.beginAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n\r\n    const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        const animatables = target.getAnimatables();\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n\r\n    animatable.reset();\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginHierarchyAnimation = function (\r\n    target: any,\r\n    directDescendantsOnly: boolean,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.beginDirectAnimation = function (\r\n    target: any,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    } else if (to > from && speedRatio < 0) {\r\n        const temp = to;\r\n        to = from;\r\n        from = temp;\r\n    }\r\n\r\n    const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginDirectHierarchyAnimation = function (\r\n    target: Node,\r\n    directDescendantsOnly: boolean,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n    const result = [];\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n    const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n    for (const animatable of animatables) {\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function (): void {\r\n    if (this._activeAnimatables) {\r\n        for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop(undefined, undefined, true);\r\n        }\r\n        this._activeAnimatables.length = 0;\r\n    }\r\n\r\n    for (const group of this.animationGroups) {\r\n        group.stop();\r\n    }\r\n};\r\n\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindings = function (): void {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        const target = this._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    const originalAnimationIsLoopRelativeFromCurrent =\r\n                        originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\r\n                        } else if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            if (finalValue.addToRef) {\r\n                                finalValue.addToRef(originalValue, finalValue);\r\n                            } else {\r\n                                finalValue += originalValue;\r\n                            }\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\nBone.prototype.copyAnimationRange = function (\r\n    source: Bone,\r\n    rangeName: string,\r\n    frameOffset: number,\r\n    rescaleAsRequired = false,\r\n    skelDimensionsRatio: Nullable<Vector3> = null\r\n): boolean {\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n\r\n    // get animation info / verify there is such a range from the source bone\r\n    const sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    const from = sourceRange.from;\r\n    const to = sourceRange.to;\r\n    const sourceKeys = source.animations[0].getKeys();\r\n\r\n    // rescaling prep\r\n    const sourceBoneLength = source.length;\r\n    const sourceParent = source.getParent();\r\n    const parent = this.getParent();\r\n    const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n    const dimensionsScalingReqd =\r\n        rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n    const destKeys = this.animations[0].getKeys();\r\n\r\n    // loop vars declaration\r\n    let orig: { frame: number; value: Matrix };\r\n    let origTranslation: Vector3;\r\n    let mat: Matrix;\r\n\r\n    for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                } else {\r\n                    mat = orig.value;\r\n                }\r\n            } else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport type { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRCompositionLayer */\r\n// TODO (rgerd): Extend for all other subclasses of XRCompositionLayer.\r\nexport type WebXRCompositionLayerType = \"XRProjectionLayer\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRLayer */\r\nexport type WebXRLayerType = \"XRWebGLLayer\" | WebXRCompositionLayerType;\r\n\r\n/**\r\n * Wrapper over subclasses of XRLayer.\r\n * @internal\r\n */\r\nexport class WebXRLayerWrapper {\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this.layerType == \"XRWebGLLayer\" && typeof (this.layer as XRWebGLLayer).fixedFoveation == \"number\";\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        if (this.isFixedFoveationSupported) {\r\n            return (this.layer as XRWebGLLayer).fixedFoveation!;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        if (this.isFixedFoveationSupported) {\r\n            const val = Math.max(0, Math.min(1, value || 0));\r\n            (this.layer as XRWebGLLayer).fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    protected constructor(\r\n        /** The width of the layer's framebuffer. */\r\n        public getWidth: () => number,\r\n        /** The height of the layer's framebuffer. */\r\n        public getHeight: () => number,\r\n        /** The XR layer that this WebXRLayerWrapper wraps. */\r\n        public readonly layer: XRLayer,\r\n        /** The type of XR layer that is being wrapped. */\r\n        public readonly layerType: WebXRLayerType,\r\n        /** Create a render target provider for the wrapped layer. */\r\n        public createRenderTargetTextureProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider\r\n    ) {}\r\n}\r\n", "import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(\r\n        private readonly _scene: Scene,\r\n        public readonly layerWrapper: WebXRLayerWrapper\r\n    ) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\r\n        if (typeof XRWebGLBinding !== \"undefined\") {\r\n            // WebXR pre-clears textures\r\n            renderTargetTexture.skipInitialClear = true;\r\n        }\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\n\r\n/**\r\n * Wraps xr webgl layers.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerWrapper extends WebXRLayerWrapper {\r\n    /**\r\n     * @param layer is the layer to be wrapped.\r\n     * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.\r\n     */\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRWebGLLayer.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    // The dimensions will always be defined in this class.\r\n    protected _framebufferDimensions: { framebufferWidth: number; framebufferHeight: number };\r\n    private _rtt: Nullable<RenderTargetTexture>;\r\n    private _framebuffer: WebGLFramebuffer;\r\n    private _layer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public readonly layerWrapper: WebXRWebGLLayerWrapper\r\n    ) {\r\n        super(scene, layerWrapper);\r\n        this._layer = layerWrapper.layer;\r\n        this._framebufferDimensions = {\r\n            framebufferWidth: this._layer.framebufferWidth,\r\n            framebufferHeight: this._layer.framebufferHeight,\r\n        };\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const xrViewport = this._layer.getViewport(view);\r\n        if (!xrViewport) {\r\n            return false;\r\n        }\r\n        const framebufferWidth = this._framebufferDimensions.framebufferWidth;\r\n        const framebufferHeight = this._framebufferDimensions.framebufferHeight;\r\n        viewport.x = xrViewport.x / framebufferWidth;\r\n        viewport.y = xrViewport.y / framebufferHeight;\r\n        viewport.width = xrViewport.width / framebufferWidth;\r\n        viewport.height = xrViewport.height / framebufferHeight;\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const layerWidth = this._layer.framebufferWidth;\r\n        const layerHeight = this._layer.framebufferHeight;\r\n        const framebuffer = this._layer.framebuffer;\r\n\r\n        if (\r\n            !this._rtt ||\r\n            layerWidth !== this._framebufferDimensions.framebufferWidth ||\r\n            layerHeight !== this._framebufferDimensions.framebufferHeight ||\r\n            framebuffer !== this._framebuffer\r\n        ) {\r\n            this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);\r\n            this._framebufferDimensions.framebufferWidth = layerWidth;\r\n            this._framebufferDimensions.framebufferHeight = layerHeight;\r\n            this._framebuffer = framebuffer;\r\n        }\r\n\r\n        return this._rtt;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view.eye);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<ThinEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()\r\n    ) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            return Promise.resolve(createLayer());\r\n        }\r\n\r\n        return (this.canvasContext as any)\r\n            .makeXRCompatible()\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {\r\n                    // log the error, continue nonetheless!\r\n                    Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                }\r\n            )\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRLayerWrapper } from \"../webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"../webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { WebXRRenderTarget } from \"../webXRTypes\";\r\n\r\n/**\r\n * Wraps XRWebGLLayer's created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerWrapper extends WebXRLayerWrapper {\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new NativeXRLayerRenderTargetTextureProvider(sessionManager, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures for layers created by Babylon Native.\r\n * @internal\r\n */\r\nexport class NativeXRLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    private _nativeRTTProvider: WebXRLayerRenderTargetTextureProvider;\r\n    private _nativeLayer: XRWebGLLayer;\r\n\r\n    constructor(\r\n        sessionManager: WebXRSessionManager,\r\n        public readonly layerWrapper: NativeXRLayerWrapper\r\n    ) {\r\n        super(sessionManager.scene, layerWrapper);\r\n        this._nativeRTTProvider = (navigator as any).xr.getNativeRenderTargetProvider(\r\n            sessionManager.session,\r\n            this._createRenderTargetTexture.bind(this),\r\n            this._destroyRenderTargetTexture.bind(this)\r\n        );\r\n        this._nativeLayer = layerWrapper.layer;\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport): boolean {\r\n        viewport.x = 0;\r\n        viewport.y = 0;\r\n        viewport.width = 1;\r\n        viewport.height = 1;\r\n        return true;\r\n    }\r\n\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        // TODO (rgerd): Update the contract on the BabylonNative side to call this \"getRenderTargetTextureForEye\"\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(eye);\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return (this._nativeRTTProvider as any).getRenderTargetForEye(view.eye);\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return {\r\n            framebufferWidth: this._nativeLayer.framebufferWidth,\r\n            framebufferHeight: this._nativeLayer.framebufferHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the xr layer that will be used as the xr session's base layer.\r\n * @internal\r\n */\r\nexport class NativeXRRenderTarget implements WebXRRenderTarget {\r\n    public canvasContext: WebGLRenderingContext;\r\n    public xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    private _nativeRenderTarget: WebXRRenderTarget;\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        this._nativeRenderTarget = (navigator as any).xr.getWebXRRenderTarget(_xrSessionManager.scene.getEngine());\r\n    }\r\n\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        await this._nativeRenderTarget.initializeXRLayerAsync(xrSession);\r\n        this.xrLayer = this._nativeRenderTarget.xrLayer!;\r\n        return this.xrLayer;\r\n    }\r\n\r\n    dispose(): void {\r\n        /* empty */\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            return this.session.end().catch(() => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this.inXRSession = true;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: (callback: FrameRequestCallback) => this.session.requestAnimationFrame(callback),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * States of the webXR experience\r\n */\r\nexport enum WebXRState {\r\n    /**\r\n     * Transitioning to being in XR mode\r\n     */\r\n    ENTERING_XR,\r\n    /**\r\n     * Transitioning to non XR mode\r\n     */\r\n    EXITING_XR,\r\n    /**\r\n     * In XR mode and presenting\r\n     */\r\n    IN_XR,\r\n    /**\r\n     * Not entered XR mode\r\n     */\r\n    NOT_IN_XR,\r\n}\r\n\r\n/**\r\n * The state of the XR camera's tracking\r\n */\r\nexport enum WebXRTrackingState {\r\n    /**\r\n     * No transformation received, device is not being tracked\r\n     */\r\n    NOT_TRACKING,\r\n    /**\r\n     * Tracking lost - using emulated position\r\n     */\r\n    TRACKING_LOST,\r\n    /**\r\n     * Transformation tracking works normally\r\n     */\r\n    TRACKING,\r\n}\r\n\r\n/**\r\n * Abstraction of the XR render target\r\n */\r\nexport interface WebXRRenderTarget extends IDisposable {\r\n    /**\r\n     * xrpresent context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;\r\n}\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera\";\r\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { StickValues } from \"../../Gamepads/gamepad\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport type { Xbox360Pad } from \"../../Gamepads/xboxGamepad\";\r\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport type { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\r\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport type { VRCameraMetrics } from \"../../Cameras/VR/vrCameraMetrics\";\r\nimport \"../../Gamepads/gamepadSceneComponent\";\r\nimport \"../../Animations/animatable\";\r\nimport { WebXRSessionManager } from \"../../XR/webXRSessionManager\";\r\nimport type { WebXRDefaultExperience } from \"../../XR/webXRDefaultExperience\";\r\nimport { WebXRState } from \"../../XR/webXRTypes\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { CreateTorus } from \"core/Meshes/Builders/torusBuilder\";\r\n\r\n/**\r\n * Options to modify the vr teleportation behavior.\r\n */\r\nexport interface VRTeleportationOptions {\r\n    /**\r\n     * The name of the mesh which should be used as the teleportation floor. (default: null)\r\n     */\r\n    floorMeshName?: string;\r\n    /**\r\n     * A list of meshes to be used as the teleportation floor. (default: empty)\r\n     */\r\n    floorMeshes?: Mesh[];\r\n    /**\r\n     * The teleportation mode. (default: TELEPORTATIONMODE_CONSTANTTIME)\r\n     */\r\n    teleportationMode?: number;\r\n    /**\r\n     * The duration of the animation in ms, apply when animationMode is TELEPORTATIONMODE_CONSTANTTIME. (default 122ms)\r\n     */\r\n    teleportationTime?: number;\r\n    /**\r\n     * The speed of the animation in distance/sec, apply when animationMode is TELEPORTATIONMODE_CONSTANTSPEED. (default 20 units / sec)\r\n     */\r\n    teleportationSpeed?: number;\r\n    /**\r\n     * The easing function used in the animation or null for Linear. (default CircleEase)\r\n     */\r\n    easingFunction?: EasingFunction;\r\n}\r\n\r\n/**\r\n * Options to modify the vr experience helper's behavior.\r\n */\r\nexport interface VRExperienceHelperOptions {\r\n    /**\r\n     * Create a DeviceOrientationCamera to be used as your out of vr camera. (default: true)\r\n     */\r\n    createDeviceOrientationCamera?: boolean;\r\n    /**\r\n     * Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found. (default: true)\r\n     */\r\n    createFallbackVRDeviceOrientationFreeCamera?: boolean;\r\n    /**\r\n     * Uses the main button on the controller to toggle the laser casted. (default: true)\r\n     */\r\n    laserToggle?: boolean;\r\n    /**\r\n     * A list of meshes to be used as the teleportation floor. If specified, teleportation will be enabled (default: undefined)\r\n     */\r\n    floorMeshes?: Mesh[];\r\n    /**\r\n     * Distortion metrics for the fallback vrDeviceOrientationCamera (default: VRCameraMetrics.Default)\r\n     */\r\n    vrDeviceOrientationCameraMetrics?: VRCameraMetrics;\r\n    /**\r\n     * Defines if WebXR should be used (if available)\r\n     */\r\n    useXR?: boolean;\r\n}\r\n\r\nclass VRExperienceHelperGazer implements IDisposable {\r\n    /** @internal */\r\n    public _gazeTracker: Mesh;\r\n\r\n    /** @internal */\r\n    public _currentMeshSelected: Nullable<AbstractMesh>;\r\n    /** @internal */\r\n    public _currentHit: Nullable<PickingInfo>;\r\n\r\n    public static _IdCounter = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    /** @internal */\r\n    public _pointerDownOnMeshAsked: boolean = false;\r\n    /** @internal */\r\n    public _isActionableMesh: boolean = false;\r\n\r\n    /** @internal */\r\n    public _interactionsEnabled: boolean;\r\n    /** @internal */\r\n    public _teleportationEnabled: boolean;\r\n    /** @internal */\r\n    public _teleportationRequestInitiated = false;\r\n    /** @internal */\r\n    public _teleportationBackRequestInitiated = false;\r\n    /** @internal */\r\n    public _rotationRightAsked = false;\r\n    /** @internal */\r\n    public _rotationLeftAsked = false;\r\n    /** @internal */\r\n    public _dpadPressed = true;\r\n\r\n    /** @internal */\r\n    public _activePointer = false;\r\n\r\n    constructor(\r\n        public scene: Scene,\r\n        gazeTrackerToClone: Nullable<Mesh> = null\r\n    ) {\r\n        this._id = VRExperienceHelperGazer._IdCounter++;\r\n\r\n        // Gaze tracker\r\n        if (!gazeTrackerToClone) {\r\n            this._gazeTracker = CreateTorus(\r\n                \"gazeTracker\",\r\n                {\r\n                    diameter: 0.0035,\r\n                    thickness: 0.0025,\r\n                    tessellation: 20,\r\n                    updatable: false,\r\n                },\r\n                scene\r\n            );\r\n            this._gazeTracker.bakeCurrentTransformIntoVertices();\r\n            this._gazeTracker.isPickable = false;\r\n            this._gazeTracker.isVisible = false;\r\n            const targetMat = new StandardMaterial(\"targetMat\", scene);\r\n            targetMat.specularColor = Color3.Black();\r\n            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\r\n            targetMat.backFaceCulling = false;\r\n            this._gazeTracker.material = targetMat;\r\n        } else {\r\n            this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\") as Mesh;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getForwardRay(length: number): Ray {\r\n        return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\r\n    }\r\n\r\n    /** @internal */\r\n    public _selectionPointerDown() {\r\n        this._pointerDownOnMeshAsked = true;\r\n        if (this._currentHit) {\r\n            this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _selectionPointerUp() {\r\n        if (this._currentHit) {\r\n            this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });\r\n        }\r\n        this._pointerDownOnMeshAsked = false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _activatePointer() {\r\n        this._activePointer = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _deactivatePointer() {\r\n        this._activePointer = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _updatePointerDistance(distance: number = 100) {}\r\n\r\n    public dispose() {\r\n        this._interactionsEnabled = false;\r\n        this._teleportationEnabled = false;\r\n        if (this._gazeTracker) {\r\n            this._gazeTracker.dispose();\r\n        }\r\n    }\r\n}\r\n\r\nclass VRExperienceHelperCameraGazer extends VRExperienceHelperGazer {\r\n    constructor(\r\n        private _getCamera: () => Nullable<Camera>,\r\n        scene: Scene\r\n    ) {\r\n        super(scene);\r\n    }\r\n\r\n    _getForwardRay(length: number): Ray {\r\n        const camera = this._getCamera();\r\n        if (camera) {\r\n            return camera.getForwardRay(length);\r\n        } else {\r\n            return new Ray(Vector3.Zero(), Vector3.Forward());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Event containing information after VR has been entered\r\n */\r\nexport class OnAfterEnteringVRObservableEvent {\r\n    /**\r\n     * If entering vr was successful\r\n     */\r\n    public success: boolean;\r\n}\r\n\r\n/**\r\n * Helps to quickly add VR support to an existing scene.\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRHelper\r\n * @deprecated Use WebXR instead!\r\n */\r\nexport class VRExperienceHelper {\r\n    private _scene: Scene;\r\n    private _position: Vector3;\r\n    private _btnVR: Nullable<HTMLButtonElement>;\r\n    private _btnVRDisplayed: boolean;\r\n\r\n    // Have we entered VR? (this is the VRExperienceHelper state)\r\n    private _hasEnteredVR: boolean;\r\n\r\n    // Are we presenting in the fullscreen fallback?\r\n    private _fullscreenVRpresenting = false;\r\n\r\n    private _inputElement: Nullable<HTMLElement>;\r\n    private _vrDeviceOrientationCamera: Nullable<VRDeviceOrientationFreeCamera>;\r\n    private _deviceOrientationCamera: Nullable<DeviceOrientationCamera>;\r\n    private _existingCamera: Camera;\r\n\r\n    private _onKeyDown: (event: KeyboardEvent) => void;\r\n    private _onVrDisplayPresentChangeBind: any;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\r\n     */\r\n    public enableGazeEvenWhenNoPointerLock = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\r\n     */\r\n    public exitVROnDoubleTap = true;\r\n\r\n    /**\r\n     * Observable raised right before entering VR.\r\n     */\r\n    public onEnteringVRObservable = new Observable<VRExperienceHelper>();\r\n\r\n    /**\r\n     * Observable raised when entering VR has completed.\r\n     */\r\n    public onAfterEnteringVRObservable = new Observable<OnAfterEnteringVRObservableEvent>();\r\n\r\n    /**\r\n     * Observable raised when exiting VR.\r\n     */\r\n    public onExitingVRObservable = new Observable<VRExperienceHelper>();\r\n\r\n    /** Return this.onEnteringVRObservable\r\n     * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\r\n     */\r\n    public get onEnteringVR(): Observable<VRExperienceHelper> {\r\n        return this.onEnteringVRObservable;\r\n    }\r\n\r\n    /** Return this.onExitingVRObservable\r\n     * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\r\n     */\r\n    public get onExitingVR(): Observable<VRExperienceHelper> {\r\n        return this.onExitingVRObservable;\r\n    }\r\n\r\n    private _useCustomVRButton: boolean = false;\r\n    private _teleportActive = false;\r\n    private _floorMeshName: string;\r\n    private _floorMeshesCollection: Mesh[] = [];\r\n    private _teleportationMode: number = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\r\n    private _teleportationTime: number = 122;\r\n    private _teleportationSpeed: number = 20;\r\n    private _teleportationEasing: EasingFunction;\r\n    private _rotationAllowed: boolean = true;\r\n    private _teleportBackwardsVector = new Vector3(0, -1, -1);\r\n    private _teleportationTarget: Mesh;\r\n    private _isDefaultTeleportationTarget = true;\r\n    private _postProcessMove: ImageProcessingPostProcess;\r\n    private _teleportationFillColor: string = \"#444444\";\r\n    private _teleportationBorderColor: string = \"#FFFFFF\";\r\n    private _rotationAngle: number = 0;\r\n    private _haloCenter = new Vector3(0, 0, 0);\r\n    private _cameraGazer: VRExperienceHelperCameraGazer;\r\n    private _padSensibilityUp = 0.65;\r\n    private _padSensibilityDown = 0.35;\r\n\r\n    private _pickedLaserColor: Color3 = new Color3(0.2, 0.2, 1);\r\n    private _pickedGazeColor: Color3 = new Color3(0, 0, 1);\r\n\r\n    /**\r\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate\r\n     */\r\n    public onNewMeshSelected = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * Observable raised when a new mesh is picked based on meshSelectionPredicate\r\n     */\r\n    public onNewMeshPicked = new Observable<PickingInfo>();\r\n\r\n    private _circleEase: CircleEase;\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Observable raised when current selected mesh gets unselected\r\n     */\r\n    public onSelectedMeshUnselected = new Observable<AbstractMesh>();\r\n\r\n    private _raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * To be optionally changed by user to define custom ray selection\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * To be optionally changed by user to define custom selection logic (after ray selection)\r\n     */\r\n    public meshSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _defaultHeight: number;\r\n    private _teleportationInitialized = false;\r\n    private _interactionsEnabled = false;\r\n    private _displayGaze = true;\r\n    private _displayLaserPointer = true;\r\n\r\n    /**\r\n     * The mesh used to display where the user is going to teleport.\r\n     */\r\n    public get teleportationTarget(): Mesh {\r\n        return this._teleportationTarget;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to be used to display where the user is going to teleport.\r\n     */\r\n    public set teleportationTarget(value: Mesh) {\r\n        if (value) {\r\n            value.name = \"teleportationTarget\";\r\n            this._isDefaultTeleportationTarget = false;\r\n            this._teleportationTarget = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\r\n     * when set bakeCurrentTransformIntoVertices will be called on the mesh.\r\n     * See https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\r\n     */\r\n    public get gazeTrackerMesh(): Mesh {\r\n        return this._cameraGazer._gazeTracker;\r\n    }\r\n\r\n    public set gazeTrackerMesh(value: Mesh) {\r\n        if (value) {\r\n            // Dispose of existing meshes\r\n            if (this._cameraGazer._gazeTracker) {\r\n                this._cameraGazer._gazeTracker.dispose();\r\n            }\r\n\r\n            // Set and create gaze trackers on head and controllers\r\n            this._cameraGazer._gazeTracker = value;\r\n            this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\r\n            this._cameraGazer._gazeTracker.isPickable = false;\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n            this._cameraGazer._gazeTracker.name = \"gazeTracker\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\r\n     */\r\n    public updateGazeTrackerScale = true;\r\n    /**\r\n     * If the gaze trackers color should be updated when selecting meshes\r\n     */\r\n    public updateGazeTrackerColor = true;\r\n    /**\r\n     * If the controller laser color should be updated when selecting meshes\r\n     */\r\n    public updateControllerLaserColor = true;\r\n\r\n    /**\r\n     * If the ray of the gaze should be displayed.\r\n     */\r\n    public get displayGaze(): boolean {\r\n        return this._displayGaze;\r\n    }\r\n\r\n    /**\r\n     * Sets if the ray of the gaze should be displayed.\r\n     */\r\n    public set displayGaze(value: boolean) {\r\n        this._displayGaze = value;\r\n        if (!value) {\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the ray of the LaserPointer should be displayed.\r\n     */\r\n    public get displayLaserPointer(): boolean {\r\n        return this._displayLaserPointer;\r\n    }\r\n\r\n    /**\r\n     * Sets if the ray of the LaserPointer should be displayed.\r\n     */\r\n    public set displayLaserPointer(value: boolean) {\r\n        this._displayLaserPointer = value;\r\n    }\r\n\r\n    /**\r\n     * The deviceOrientationCamera used as the camera when not in VR.\r\n     */\r\n    public get deviceOrientationCamera(): Nullable<DeviceOrientationCamera> {\r\n        return this._deviceOrientationCamera;\r\n    }\r\n\r\n    /**\r\n     * Based on the current WebVR support, returns the current VR camera used.\r\n     */\r\n    public get currentVRCamera(): Nullable<Camera> {\r\n        return this._scene.activeCamera;\r\n    }\r\n\r\n    /**\r\n     * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\r\n     */\r\n    public get vrDeviceOrientationCamera(): Nullable<VRDeviceOrientationFreeCamera> {\r\n        return this._vrDeviceOrientationCamera;\r\n    }\r\n\r\n    /**\r\n     * The html button that is used to trigger entering into VR.\r\n     */\r\n    public get vrButton(): Nullable<HTMLButtonElement> {\r\n        return this._btnVR;\r\n    }\r\n\r\n    private get _teleportationRequestInitiated(): boolean {\r\n        return this._cameraGazer._teleportationRequestInitiated;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not Pointer lock should be requested when switching to\r\n     * full screen.\r\n     */\r\n    public requestPointerLockOnFullScreen = true;\r\n\r\n    // XR\r\n\r\n    /**\r\n     * If asking to force XR, this will be populated with the default xr experience\r\n     */\r\n    public xr: WebXRDefaultExperience;\r\n\r\n    /**\r\n     * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\r\n     * If this is true and no this.xr, xr exists but is not supported, using WebVR.\r\n     */\r\n    public xrTestDone: boolean = false;\r\n\r\n    /**\r\n     * Instantiates a VRExperienceHelper.\r\n     * Helps to quickly add VR support to an existing scene.\r\n     * @param scene The scene the VRExperienceHelper belongs to.\r\n     * @param webVROptions Options to modify the vr experience helper's behavior.\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** Options to modify the vr experience helper's behavior. */\r\n        public webVROptions: VRExperienceHelperOptions = {}\r\n    ) {\r\n        Logger.Warn(\"WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead\");\r\n        this._scene = scene;\r\n        this._inputElement = scene.getEngine().getInputElement();\r\n\r\n        // check for VR support:\r\n\r\n        const vrSupported = \"getVRDisplays\" in navigator;\r\n        // no VR support? force XR but only when it is not set because web vr can work without the getVRDisplays\r\n        if (!vrSupported && webVROptions.useXR === undefined) {\r\n            webVROptions.useXR = true;\r\n        }\r\n\r\n        // Parse options\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\r\n            webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\r\n        }\r\n        if (webVROptions.createDeviceOrientationCamera === undefined) {\r\n            webVROptions.createDeviceOrientationCamera = true;\r\n        }\r\n        if (webVROptions.laserToggle === undefined) {\r\n            webVROptions.laserToggle = true;\r\n        }\r\n\r\n        this._hasEnteredVR = false;\r\n\r\n        // Set position\r\n        if (this._scene.activeCamera) {\r\n            this._position = this._scene.activeCamera.position.clone();\r\n        } else {\r\n            this._position = new Vector3(0, this._defaultHeight, 0);\r\n        }\r\n\r\n        // Set non-vr camera\r\n        if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\r\n            this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene);\r\n\r\n            // Copy data from existing camera\r\n            if (this._scene.activeCamera) {\r\n                this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\r\n                this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;\r\n                // Set rotation from previous camera\r\n                if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\r\n                    const targetCamera = this._scene.activeCamera;\r\n                    if (targetCamera.rotationQuaternion) {\r\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\r\n                    } else {\r\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(\r\n                            Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z)\r\n                        );\r\n                    }\r\n                    this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\r\n                }\r\n            }\r\n\r\n            this._scene.activeCamera = this._deviceOrientationCamera;\r\n            if (this._inputElement) {\r\n                this._scene.activeCamera.attachControl();\r\n            }\r\n        } else {\r\n            this._existingCamera = this._scene.activeCamera;\r\n        }\r\n\r\n        if (this.webVROptions.useXR && (navigator as any).xr) {\r\n            // force-check XR session support\r\n            WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then((supported) => {\r\n                if (supported) {\r\n                    Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\");\r\n                    // it is possible to use XR, let's do it!\r\n                    scene\r\n                        .createDefaultXRExperienceAsync({\r\n                            floorMeshes: webVROptions.floorMeshes || [],\r\n                        })\r\n                        .then((xr) => {\r\n                            this.xr = xr;\r\n                            // connect observables\r\n                            this.xrTestDone = true;\r\n\r\n                            this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\r\n                                return this.xr.baseExperience.camera;\r\n                            }, scene);\r\n\r\n                            this.xr.baseExperience.onStateChangedObservable.add((state) => {\r\n                                // support for entering / exiting\r\n                                switch (state) {\r\n                                    case WebXRState.ENTERING_XR:\r\n                                        this.onEnteringVRObservable.notifyObservers(this);\r\n                                        if (!this._interactionsEnabled) {\r\n                                            this.xr.pointerSelection.detach();\r\n                                        }\r\n                                        this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;\r\n                                        break;\r\n                                    case WebXRState.EXITING_XR:\r\n                                        this.onExitingVRObservable.notifyObservers(this);\r\n\r\n                                        // resize to update width and height when exiting vr exits fullscreen\r\n                                        this._scene.getEngine().resize();\r\n                                        break;\r\n                                    case WebXRState.IN_XR:\r\n                                        this._hasEnteredVR = true;\r\n                                        break;\r\n                                    case WebXRState.NOT_IN_XR:\r\n                                        this._hasEnteredVR = false;\r\n                                        break;\r\n                                }\r\n                            });\r\n                        });\r\n                } else {\r\n                    // XR not supported (thou exists), continue WebVR init\r\n                    this._completeVRInit(scene, webVROptions);\r\n                }\r\n            });\r\n        } else {\r\n            // no XR, continue init synchronous\r\n            this._completeVRInit(scene, webVROptions);\r\n        }\r\n    }\r\n\r\n    private _completeVRInit(scene: Scene, webVROptions: VRExperienceHelperOptions): void {\r\n        this.xrTestDone = true;\r\n        // Create VR cameras\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\r\n            this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\r\n                \"VRDeviceOrientationVRHelper\",\r\n                this._position,\r\n                this._scene,\r\n                true,\r\n                webVROptions.vrDeviceOrientationCameraMetrics\r\n            );\r\n            this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\r\n        }\r\n\r\n        this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\r\n            return this.currentVRCamera;\r\n        }, scene);\r\n        // Create default button\r\n        if (!this._useCustomVRButton) {\r\n            this._btnVR = <HTMLButtonElement>document.createElement(\"BUTTON\");\r\n            this._btnVR.className = \"babylonVRicon\";\r\n            this._btnVR.id = \"babylonVRiconbtn\";\r\n            this._btnVR.title = \"Click to switch to VR\";\r\n            const url = !window.SVGSVGElement\r\n                ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\r\n                : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\r\n            let css =\r\n                \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n                url +\r\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\r\n            css += \".babylonVRicon.vrdisplaypresenting { display: none; }\";\r\n            // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\r\n            // css += \".babylonVRicon.vrdisplaysupported { }\";\r\n            // css += \".babylonVRicon.vrdisplayready { }\";\r\n            // css += \".babylonVRicon.vrdisplayrequesting { }\";\r\n\r\n            const style = document.createElement(\"style\");\r\n            style.appendChild(document.createTextNode(css));\r\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n\r\n            this._moveButtonToBottomRight();\r\n        }\r\n\r\n        // VR button click event\r\n        if (this._btnVR) {\r\n            this._btnVR.addEventListener(\"click\", () => {\r\n                if (!this.isInVRMode) {\r\n                    this.enterVR();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Window events\r\n\r\n        const hostWindow = this._scene.getEngine().getHostWindow();\r\n        if (!hostWindow) {\r\n            return;\r\n        }\r\n\r\n        hostWindow.addEventListener(\"resize\", this._onResize);\r\n        document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\r\n\r\n        // Display vr button when headset is connected\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\r\n            this._displayVRButton();\r\n        }\r\n\r\n        // Exiting VR mode using 'ESC' key on desktop\r\n        this._onKeyDown = (event: KeyboardEvent) => {\r\n            if (event.keyCode === 27 && this.isInVRMode) {\r\n                this.exitVR();\r\n            }\r\n        };\r\n        document.addEventListener(\"keydown\", this._onKeyDown);\r\n\r\n        // Exiting VR mode double tapping the touch screen\r\n        this._scene.onPrePointerObservable.add(\r\n            () => {\r\n                if (this._hasEnteredVR && this.exitVROnDoubleTap) {\r\n                    this.exitVR();\r\n                    if (this._fullscreenVRpresenting) {\r\n                        this._scene.getEngine().exitFullscreen();\r\n                    }\r\n                }\r\n            },\r\n            PointerEventTypes.POINTERDOUBLETAP,\r\n            false\r\n        );\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateButtonVisibility();\r\n\r\n        //create easing functions\r\n        this._circleEase = new CircleEase();\r\n        this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n        this._teleportationEasing = this._circleEase;\r\n\r\n        // Allow clicking in the vrDeviceOrientationCamera\r\n        scene.onPointerObservable.add((e) => {\r\n            if (this._interactionsEnabled) {\r\n                if (scene.activeCamera === this.vrDeviceOrientationCamera && (e.event as IPointerEvent).pointerType === \"mouse\") {\r\n                    if (e.type === PointerEventTypes.POINTERDOWN) {\r\n                        this._cameraGazer._selectionPointerDown();\r\n                    } else if (e.type === PointerEventTypes.POINTERUP) {\r\n                        this._cameraGazer._selectionPointerUp();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this.webVROptions.floorMeshes) {\r\n            this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });\r\n        }\r\n    }\r\n\r\n    private _onResize = () => {\r\n        this._moveButtonToBottomRight();\r\n    };\r\n\r\n    private _onFullscreenChange = () => {\r\n        this._fullscreenVRpresenting = !!document.fullscreenElement;\r\n        if (!this._fullscreenVRpresenting && this._inputElement) {\r\n            this.exitVR();\r\n            if (!this._useCustomVRButton && this._btnVR) {\r\n                this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + \"px\";\r\n                this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + \"px\";\r\n                // make sure the button is visible after setting its position\r\n                this._updateButtonVisibility();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets a value indicating if we are currently in VR mode.\r\n     */\r\n    public get isInVRMode(): boolean {\r\n        return (this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR) || this._fullscreenVRpresenting;\r\n    }\r\n\r\n    private _moveButtonToBottomRight() {\r\n        if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\r\n            const rect: ClientRect = this._inputElement.getBoundingClientRect();\r\n            this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\r\n            this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\r\n        }\r\n    }\r\n\r\n    private _displayVRButton() {\r\n        if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\r\n            document.body.appendChild(this._btnVR);\r\n            this._btnVRDisplayed = true;\r\n        }\r\n    }\r\n\r\n    private _updateButtonVisibility() {\r\n        if (!this._btnVR || this._useCustomVRButton) {\r\n            return;\r\n        }\r\n        this._btnVR.className = \"babylonVRicon\";\r\n        if (this.isInVRMode) {\r\n            this._btnVR.className += \" vrdisplaypresenting\";\r\n        }\r\n    }\r\n\r\n    private _cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };\r\n    /**\r\n     * Attempt to enter VR. If a headset is connected and ready, will request present on that.\r\n     * Otherwise, will use the fullscreen API.\r\n     */\r\n    public enterVR() {\r\n        if (this.xr) {\r\n            this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\r\n            return;\r\n        }\r\n        if (this.onEnteringVRObservable) {\r\n            try {\r\n                this.onEnteringVRObservable.notifyObservers(this);\r\n            } catch (err) {\r\n                Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\r\n            }\r\n        }\r\n\r\n        if (this._scene.activeCamera) {\r\n            this._position = this._scene.activeCamera.position.clone();\r\n\r\n            if (this.vrDeviceOrientationCamera) {\r\n                this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\r\n                this.vrDeviceOrientationCamera.angularSensibility = 2000;\r\n            }\r\n\r\n            // make sure that we return to the last active camera\r\n            this._existingCamera = this._scene.activeCamera;\r\n\r\n            // Remove and cache angular sensability to avoid camera rotation when in VR\r\n            if ((<any>this._existingCamera).angularSensibilityX) {\r\n                this._cachedAngularSensibility.angularSensibilityX = (<any>this._existingCamera).angularSensibilityX;\r\n                (<any>this._existingCamera).angularSensibilityX = Number.MAX_VALUE;\r\n            }\r\n            if ((<any>this._existingCamera).angularSensibilityY) {\r\n                this._cachedAngularSensibility.angularSensibilityY = (<any>this._existingCamera).angularSensibilityY;\r\n                (<any>this._existingCamera).angularSensibilityY = Number.MAX_VALUE;\r\n            }\r\n            if ((<any>this._existingCamera).angularSensibility) {\r\n                this._cachedAngularSensibility.angularSensibility = (<any>this._existingCamera).angularSensibility;\r\n                (<any>this._existingCamera).angularSensibility = Number.MAX_VALUE;\r\n            }\r\n        }\r\n\r\n        // If WebVR is supported and a headset is connected\r\n        if (this._vrDeviceOrientationCamera) {\r\n            this._vrDeviceOrientationCamera.position = this._position;\r\n            if (this._scene.activeCamera) {\r\n                this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\r\n            }\r\n            this._scene.activeCamera = this._vrDeviceOrientationCamera;\r\n            this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\r\n            this._updateButtonVisibility();\r\n            this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {\r\n                this.onAfterEnteringVRObservable.notifyObservers({ success: true });\r\n            });\r\n        }\r\n\r\n        if (this._scene.activeCamera && this._inputElement) {\r\n            this._scene.activeCamera.attachControl();\r\n        }\r\n\r\n        if (this._interactionsEnabled) {\r\n            this._scene.registerBeforeRender(this._beforeRender);\r\n        }\r\n\r\n        this._hasEnteredVR = true;\r\n    }\r\n\r\n    /**\r\n     * Attempt to exit VR, or fullscreen.\r\n     */\r\n    public exitVR() {\r\n        if (this.xr) {\r\n            this.xr.baseExperience.exitXRAsync();\r\n            return;\r\n        }\r\n        if (this._hasEnteredVR) {\r\n            if (this.onExitingVRObservable) {\r\n                try {\r\n                    this.onExitingVRObservable.notifyObservers(this);\r\n                } catch (err) {\r\n                    Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\r\n                }\r\n            }\r\n            if (this._scene.activeCamera) {\r\n                this._position = this._scene.activeCamera.position.clone();\r\n            }\r\n\r\n            if (this.vrDeviceOrientationCamera) {\r\n                this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\r\n            }\r\n\r\n            if (this._deviceOrientationCamera) {\r\n                this._deviceOrientationCamera.position = this._position;\r\n                this._scene.activeCamera = this._deviceOrientationCamera;\r\n\r\n                // Restore angular sensibility\r\n                if (this._cachedAngularSensibility.angularSensibilityX) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\r\n                    this._cachedAngularSensibility.angularSensibilityX = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibilityY) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\r\n                    this._cachedAngularSensibility.angularSensibilityY = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibility) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibility = this._cachedAngularSensibility.angularSensibility;\r\n                    this._cachedAngularSensibility.angularSensibility = null;\r\n                }\r\n            } else if (this._existingCamera) {\r\n                this._existingCamera.position = this._position;\r\n                this._scene.activeCamera = this._existingCamera;\r\n                if (this._inputElement) {\r\n                    this._scene.activeCamera.attachControl();\r\n                }\r\n\r\n                // Restore angular sensibility\r\n                if (this._cachedAngularSensibility.angularSensibilityX) {\r\n                    (<any>this._existingCamera).angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\r\n                    this._cachedAngularSensibility.angularSensibilityX = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibilityY) {\r\n                    (<any>this._existingCamera).angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\r\n                    this._cachedAngularSensibility.angularSensibilityY = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibility) {\r\n                    (<any>this._existingCamera).angularSensibility = this._cachedAngularSensibility.angularSensibility;\r\n                    this._cachedAngularSensibility.angularSensibility = null;\r\n                }\r\n            }\r\n\r\n            this._updateButtonVisibility();\r\n\r\n            if (this._interactionsEnabled) {\r\n                this._scene.unregisterBeforeRender(this._beforeRender);\r\n                this._cameraGazer._gazeTracker.isVisible = false;\r\n            }\r\n\r\n            // resize to update width and height when exiting vr exits fullscreen\r\n            this._scene.getEngine().resize();\r\n\r\n            this._hasEnteredVR = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The position of the vr experience helper.\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the vr experience helper.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._position = value;\r\n\r\n        if (this._scene.activeCamera) {\r\n            this._scene.activeCamera.position = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables controllers and user interactions such as selecting and object or clicking on an object.\r\n     */\r\n    public enableInteractions() {\r\n        if (!this._interactionsEnabled) {\r\n            // in XR it is enabled by default, but just to make sure, re-attach\r\n            if (this.xr) {\r\n                if (this.xr.baseExperience.state === WebXRState.IN_XR) {\r\n                    this.xr.pointerSelection.attach();\r\n                }\r\n                return;\r\n            }\r\n\r\n            this.raySelectionPredicate = (mesh) => {\r\n                return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);\r\n            };\r\n\r\n            this.meshSelectionPredicate = () => {\r\n                return true;\r\n            };\r\n\r\n            this._raySelectionPredicate = (mesh) => {\r\n                if (\r\n                    this._isTeleportationFloor(mesh) ||\r\n                    (mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1)\r\n                ) {\r\n                    return this.raySelectionPredicate(mesh);\r\n                }\r\n                return false;\r\n            };\r\n\r\n            this._interactionsEnabled = true;\r\n        }\r\n    }\r\n\r\n    private _beforeRender = () => {\r\n        if (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock) {\r\n            // no-op\r\n        } else {\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n        }\r\n    };\r\n\r\n    private _isTeleportationFloor(mesh: AbstractMesh): boolean {\r\n        for (let i = 0; i < this._floorMeshesCollection.length; i++) {\r\n            if (this._floorMeshesCollection[i].id === mesh.id) {\r\n                return true;\r\n            }\r\n        }\r\n        if (this._floorMeshName && mesh.name === this._floorMeshName) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Adds a floor mesh to be used for teleportation.\r\n     * @param floorMesh the mesh to be used for teleportation.\r\n     */\r\n    public addFloorMesh(floorMesh: Mesh): void {\r\n        if (!this._floorMeshesCollection) {\r\n            return;\r\n        }\r\n\r\n        if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\r\n            return;\r\n        }\r\n\r\n        this._floorMeshesCollection.push(floorMesh);\r\n    }\r\n\r\n    /**\r\n     * Removes a floor mesh from being used for teleportation.\r\n     * @param floorMesh the mesh to be removed.\r\n     */\r\n    public removeFloorMesh(floorMesh: Mesh): void {\r\n        if (!this._floorMeshesCollection) {\r\n            return;\r\n        }\r\n\r\n        const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\r\n        if (meshIndex !== -1) {\r\n            this._floorMeshesCollection.splice(meshIndex, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables interactions and teleportation using the VR controllers and gaze.\r\n     * @param vrTeleportationOptions options to modify teleportation behavior.\r\n     */\r\n    public enableTeleportation(vrTeleportationOptions: VRTeleportationOptions = {}) {\r\n        if (!this._teleportationInitialized) {\r\n            this.enableInteractions();\r\n\r\n            if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\r\n                const floorMeshes: AbstractMesh[] = vrTeleportationOptions.floorMeshes || [];\r\n                if (!floorMeshes.length) {\r\n                    const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName!);\r\n                    if (floorMesh) {\r\n                        floorMeshes.push(floorMesh);\r\n                    }\r\n                }\r\n                if (this.xr) {\r\n                    floorMeshes.forEach((mesh) => {\r\n                        this.xr.teleportation.addFloorMesh(mesh);\r\n                    });\r\n                    if (!this.xr.teleportation.attached) {\r\n                        this.xr.teleportation.attach();\r\n                    }\r\n                    return;\r\n                } else if (!this.xrTestDone) {\r\n                    const waitForXr = () => {\r\n                        if (this.xrTestDone) {\r\n                            this._scene.unregisterBeforeRender(waitForXr);\r\n                            if (this.xr) {\r\n                                if (!this.xr.teleportation.attached) {\r\n                                    this.xr.teleportation.attach();\r\n                                }\r\n                            } else {\r\n                                this.enableTeleportation(vrTeleportationOptions);\r\n                            }\r\n                        }\r\n                    };\r\n                    this._scene.registerBeforeRender(waitForXr);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (vrTeleportationOptions.floorMeshName) {\r\n                this._floorMeshName = vrTeleportationOptions.floorMeshName;\r\n            }\r\n            if (vrTeleportationOptions.floorMeshes) {\r\n                this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\r\n            }\r\n\r\n            if (vrTeleportationOptions.teleportationMode) {\r\n                this._teleportationMode = vrTeleportationOptions.teleportationMode;\r\n            }\r\n            if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\r\n                this._teleportationTime = vrTeleportationOptions.teleportationTime;\r\n            }\r\n            if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\r\n                this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\r\n            }\r\n            if (vrTeleportationOptions.easingFunction !== undefined) {\r\n                this._teleportationEasing = vrTeleportationOptions.easingFunction;\r\n            }\r\n\r\n            // Creates an image processing post process for the vignette not relying\r\n            // on the main scene configuration for image processing to reduce setup and spaces\r\n            // (gamma/linear) conflicts.\r\n            const imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n            imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\r\n            imageProcessingConfiguration.vignetteEnabled = true;\r\n            this._teleportationInitialized = true;\r\n            if (this._isDefaultTeleportationTarget) {\r\n                this._createTeleportationCircles();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onNewGamepadConnected = (gamepad: Gamepad) => {\r\n        if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n            if (gamepad.leftStick) {\r\n                gamepad.onleftstickchanged((stickValues) => {\r\n                    if (this._teleportationInitialized && this.teleportationEnabled) {\r\n                        // Listening to classic/xbox gamepad only if no VR controller is active\r\n                        this._checkTeleportWithRay(stickValues, this._cameraGazer);\r\n                        this._checkTeleportBackwards(stickValues, this._cameraGazer);\r\n                    }\r\n                });\r\n            }\r\n            if (gamepad.rightStick) {\r\n                gamepad.onrightstickchanged((stickValues) => {\r\n                    if (this._teleportationInitialized) {\r\n                        this._checkRotate(stickValues, this._cameraGazer);\r\n                    }\r\n                });\r\n            }\r\n            if (gamepad.type === Gamepad.XBOX) {\r\n                (<Xbox360Pad>gamepad).onbuttondown((buttonPressed: Xbox360Button) => {\r\n                    if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\r\n                        this._cameraGazer._selectionPointerDown();\r\n                    }\r\n                });\r\n                (<Xbox360Pad>gamepad).onbuttonup((buttonPressed: Xbox360Button) => {\r\n                    if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\r\n                        this._cameraGazer._selectionPointerUp();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    private _checkTeleportWithRay(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Dont teleport if another gaze already requested teleportation\r\n        if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n        if (!gazer._teleportationRequestInitiated) {\r\n            if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._activatePointer();\r\n                gazer._teleportationRequestInitiated = true;\r\n            }\r\n        } else {\r\n            // Listening to the proper controller values changes to confirm teleportation\r\n            if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\r\n                if (this._teleportActive) {\r\n                    this.teleportCamera(this._haloCenter);\r\n                }\r\n\r\n                gazer._teleportationRequestInitiated = false;\r\n            }\r\n        }\r\n    }\r\n    private _checkRotate(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Only rotate when user is not currently selecting a teleportation location\r\n        if (gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n\r\n        if (!gazer._rotationLeftAsked) {\r\n            if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._rotationLeftAsked = true;\r\n                if (this._rotationAllowed) {\r\n                    this._rotateCamera(false);\r\n                }\r\n            }\r\n        } else {\r\n            if (stateObject.x > -this._padSensibilityDown) {\r\n                gazer._rotationLeftAsked = false;\r\n            }\r\n        }\r\n\r\n        if (!gazer._rotationRightAsked) {\r\n            if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._rotationRightAsked = true;\r\n                if (this._rotationAllowed) {\r\n                    this._rotateCamera(true);\r\n                }\r\n            }\r\n        } else {\r\n            if (stateObject.x < this._padSensibilityDown) {\r\n                gazer._rotationRightAsked = false;\r\n            }\r\n        }\r\n    }\r\n    private _checkTeleportBackwards(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Only teleport backwards when user is not currently selecting a teleportation location\r\n        if (gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n        // Teleport backwards\r\n        if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\r\n            if (!gazer._teleportationBackRequestInitiated) {\r\n                if (!this.currentVRCamera) {\r\n                    return;\r\n                }\r\n\r\n                // Get rotation and position of the current camera\r\n                const rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\r\n                const position = this.currentVRCamera.position;\r\n\r\n                // Get matrix with only the y rotation of the device rotation\r\n                rotation.toEulerAnglesToRef(this._workingVector);\r\n                this._workingVector.z = 0;\r\n                this._workingVector.x = 0;\r\n                Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\r\n                this._workingQuaternion.toRotationMatrix(this._workingMatrix);\r\n\r\n                // Rotate backwards ray by device rotation to cast at the ground behind the user\r\n                Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\r\n\r\n                // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\r\n                const ray = new Ray(position, this._workingVector);\r\n                const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\r\n                if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\r\n                    this.teleportCamera(hit.pickedPoint);\r\n                }\r\n\r\n                gazer._teleportationBackRequestInitiated = true;\r\n            }\r\n        } else {\r\n            gazer._teleportationBackRequestInitiated = false;\r\n        }\r\n    }\r\n\r\n    private _createTeleportationCircles() {\r\n        this._teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, this._scene);\r\n        this._teleportationTarget.isPickable = false;\r\n\r\n        const length = 512;\r\n        const dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\r\n        dynamicTexture.hasAlpha = true;\r\n        const context = dynamicTexture.getContext();\r\n\r\n        const centerX = length / 2;\r\n        const centerY = length / 2;\r\n        const radius = 200;\r\n\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.fillStyle = this._teleportationFillColor;\r\n        context.fill();\r\n        context.lineWidth = 10;\r\n        context.strokeStyle = this._teleportationBorderColor;\r\n        context.stroke();\r\n        context.closePath();\r\n        dynamicTexture.update();\r\n\r\n        const teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\r\n        teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n        this._teleportationTarget.material = teleportationCircleMaterial;\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 25,\r\n                updatable: false,\r\n            },\r\n            this._scene\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = this._teleportationTarget;\r\n\r\n        const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n\r\n        const keys = [];\r\n        keys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        keys.push({\r\n            frame: 30,\r\n            value: 0.4,\r\n        });\r\n        keys.push({\r\n            frame: 60,\r\n            value: 0,\r\n        });\r\n\r\n        animationInnerCircle.setKeys(keys);\r\n\r\n        const easingFunction = new SineEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n        animationInnerCircle.setEasingFunction(easingFunction);\r\n\r\n        torus.animations = [];\r\n        torus.animations.push(animationInnerCircle);\r\n\r\n        this._scene.beginAnimation(torus, 0, 60, true);\r\n\r\n        this._hideTeleportationTarget();\r\n    }\r\n\r\n    private _hideTeleportationTarget() {\r\n        this._teleportActive = false;\r\n        if (this._teleportationInitialized) {\r\n            this._teleportationTarget.isVisible = false;\r\n            if (this._isDefaultTeleportationTarget) {\r\n                (<Mesh>this._teleportationTarget.getChildren()[0]).isVisible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _rotateCamera(right: boolean) {\r\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\r\n            return;\r\n        }\r\n\r\n        if (right) {\r\n            this._rotationAngle++;\r\n        } else {\r\n            this._rotationAngle--;\r\n        }\r\n\r\n        this.currentVRCamera.animations = [];\r\n\r\n        const target = Quaternion.FromRotationMatrix(Matrix.RotationY((Math.PI / 4) * this._rotationAngle));\r\n\r\n        const animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const animationRotationKeys = [];\r\n        animationRotationKeys.push({\r\n            frame: 0,\r\n            value: this.currentVRCamera.rotationQuaternion,\r\n        });\r\n        animationRotationKeys.push({\r\n            frame: 6,\r\n            value: target,\r\n        });\r\n\r\n        animationRotation.setKeys(animationRotationKeys);\r\n\r\n        animationRotation.setEasingFunction(this._circleEase);\r\n\r\n        this.currentVRCamera.animations.push(animationRotation);\r\n\r\n        this._postProcessMove.animations = [];\r\n\r\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteWeightKeys = [];\r\n        vignetteWeightKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: 3,\r\n            value: 4,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: 6,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP.setKeys(vignetteWeightKeys);\r\n        animationPP.setEasingFunction(this._circleEase);\r\n        this._postProcessMove.animations.push(animationPP);\r\n\r\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteStretchKeys = [];\r\n        vignetteStretchKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: 3,\r\n            value: 10,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: 6,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP2.setKeys(vignetteStretchKeys);\r\n        animationPP2.setEasingFunction(this._circleEase);\r\n        this._postProcessMove.animations.push(animationPP2);\r\n\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\r\n        this._postProcessMove.samples = 4;\r\n        this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\r\n    }\r\n\r\n    private _workingVector = Vector3.Zero();\r\n    private _workingQuaternion = Quaternion.Identity();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Time Constant Teleportation Mode\r\n     */\r\n    public static readonly TELEPORTATIONMODE_CONSTANTTIME = 0;\r\n    /**\r\n     * Speed Constant Teleportation Mode\r\n     */\r\n    public static readonly TELEPORTATIONMODE_CONSTANTSPEED = 1;\r\n\r\n    /**\r\n     * Teleports the users feet to the desired location\r\n     * @param location The location where the user's feet should be placed\r\n     */\r\n    public teleportCamera(location: Vector3) {\r\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\r\n            return;\r\n        }\r\n        // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\r\n        // offset of the headset from the anchor.\r\n\r\n        this._workingVector.copyFrom(location);\r\n        // Add height to account for user's height offset\r\n        if (this.isInVRMode) {\r\n            // no-op\r\n        } else {\r\n            this._workingVector.y += this._defaultHeight;\r\n        }\r\n\r\n        this.onBeforeCameraTeleport.notifyObservers(this._workingVector);\r\n\r\n        // Animations FPS\r\n        const FPS = 90;\r\n        let speedRatio, lastFrame;\r\n        if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\r\n            lastFrame = FPS;\r\n            const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\r\n            speedRatio = this._teleportationSpeed / dist;\r\n        } else {\r\n            // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\r\n            lastFrame = Math.round((this._teleportationTime * FPS) / 1000);\r\n            speedRatio = 1;\r\n        }\r\n\r\n        // Create animation from the camera's position to the new location\r\n        this.currentVRCamera.animations = [];\r\n        const animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const animationCameraTeleportationKeys = [\r\n            {\r\n                frame: 0,\r\n                value: this.currentVRCamera.position,\r\n            },\r\n            {\r\n                frame: lastFrame,\r\n                value: this._workingVector,\r\n            },\r\n        ];\r\n\r\n        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\r\n        animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\r\n        this.currentVRCamera.animations.push(animationCameraTeleportation);\r\n\r\n        this._postProcessMove.animations = [];\r\n\r\n        // Calculate the mid frame for vignette animations\r\n        const midFrame = Math.round(lastFrame / 2);\r\n\r\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteWeightKeys = [];\r\n        vignetteWeightKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: midFrame,\r\n            value: 8,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: lastFrame,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP.setKeys(vignetteWeightKeys);\r\n        this._postProcessMove.animations.push(animationPP);\r\n\r\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteStretchKeys = [];\r\n        vignetteStretchKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: midFrame,\r\n            value: 10,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: lastFrame,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP2.setKeys(vignetteStretchKeys);\r\n        this._postProcessMove.animations.push(animationPP2);\r\n\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\r\n\r\n        this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {\r\n            this.onAfterCameraTeleport.notifyObservers(this._workingVector);\r\n        });\r\n\r\n        this._hideTeleportationTarget();\r\n    }\r\n\r\n    /**\r\n     * Permanently set new colors for the laser pointer\r\n     * @param color the new laser color\r\n     * @param pickedColor the new laser color when picked mesh detected\r\n     */\r\n    public setLaserColor(color: Color3, pickedColor: Color3 = this._pickedLaserColor) {\r\n        this._pickedLaserColor = pickedColor;\r\n    }\r\n\r\n    /**\r\n     * Set lighting enabled / disabled on the laser pointer of both controllers\r\n     * @param enabled should the lighting be enabled on the laser pointer\r\n     */\r\n    public setLaserLightingState(_enabled: boolean = true) {\r\n        // no-op\r\n    }\r\n\r\n    /**\r\n     * Permanently set new colors for the gaze pointer\r\n     * @param color the new gaze color\r\n     * @param pickedColor the new gaze color when picked mesh detected\r\n     */\r\n    public setGazeColor(color: Color3, pickedColor: Color3 = this._pickedGazeColor) {\r\n        this._pickedGazeColor = pickedColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the laser ray from the vr controllers.\r\n     * @param color new color for the ray.\r\n     */\r\n    public changeLaserColor(_color: Color3) {\r\n        if (!this.updateControllerLaserColor) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the ray from the vr headsets gaze.\r\n     * @param color new color for the ray.\r\n     */\r\n    public changeGazeColor(color: Color3) {\r\n        if (!this.updateGazeTrackerColor) {\r\n            return;\r\n        }\r\n        if (!(<StandardMaterial>this._cameraGazer._gazeTracker.material)) {\r\n            return;\r\n        }\r\n        (<StandardMaterial>this._cameraGazer._gazeTracker.material).emissiveColor = color;\r\n    }\r\n\r\n    /**\r\n     * Exits VR and disposes of the vr experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.isInVRMode) {\r\n            this.exitVR();\r\n        }\r\n\r\n        if (this._postProcessMove) {\r\n            this._postProcessMove.dispose();\r\n        }\r\n\r\n        if (this._vrDeviceOrientationCamera) {\r\n            this._vrDeviceOrientationCamera.dispose();\r\n        }\r\n        if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\r\n            document.body.removeChild(this._btnVR);\r\n        }\r\n\r\n        if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\r\n            this._deviceOrientationCamera.dispose();\r\n        }\r\n\r\n        if (this._cameraGazer) {\r\n            this._cameraGazer.dispose();\r\n        }\r\n\r\n        if (this._teleportationTarget) {\r\n            this._teleportationTarget.dispose();\r\n        }\r\n\r\n        if (this.xr) {\r\n            this.xr.dispose();\r\n        }\r\n\r\n        this._floorMeshesCollection.length = 0;\r\n\r\n        document.removeEventListener(\"keydown\", this._onKeyDown);\r\n        window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\r\n\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n        document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\r\n\r\n        this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\r\n\r\n        this._scene.unregisterBeforeRender(this._beforeRender);\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the VRExperienceHelper class\r\n     * @returns \"VRExperienceHelper\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRExperienceHelper\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["e", "_CameraProperty", "JoystickAxis", "name", "name", "name", "AnimationKeyInterpolation", "name", "name", "name", "target", "name", "name", "name", "Xbox360Button", "Xbox360Dpad", "DualShockButton", "DualShockDpad", "name", "name", "name", "name", "name", "name", "name", "name", "shader", "name", "name", "name", "name", "name", "name", "name", "name", "shader", "name", "name", "shader", "name", "name", "name", "name", "name", "name", "target", "name", "index", "_a", "rejectionReason", "WebXRState", "WebXRTrackingState"]
}
